// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: qry_responses.proto

#include "qry_responses.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace iroha {
namespace protocol {
PROTOBUF_CONSTEXPR Asset::Asset(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.asset_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.domain_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.precision_)*/0u
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct AssetDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AssetDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~AssetDefaultTypeInternal() {}
  union {
    Asset _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AssetDefaultTypeInternal _Asset_default_instance_;
PROTOBUF_CONSTEXPR Domain::Domain(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.domain_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.default_role_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct DomainDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DomainDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DomainDefaultTypeInternal() {}
  union {
    Domain _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DomainDefaultTypeInternal _Domain_default_instance_;
PROTOBUF_CONSTEXPR Account::Account(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.account_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.domain_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.json_data_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.quorum_)*/0u
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct AccountDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AccountDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~AccountDefaultTypeInternal() {}
  union {
    Account _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AccountDefaultTypeInternal _Account_default_instance_;
PROTOBUF_CONSTEXPR AccountAsset::AccountAsset(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.asset_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.account_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.balance_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct AccountAssetDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AccountAssetDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~AccountAssetDefaultTypeInternal() {}
  union {
    AccountAsset _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AccountAssetDefaultTypeInternal _AccountAsset_default_instance_;
PROTOBUF_CONSTEXPR AccountAssetResponse::AccountAssetResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.account_assets_)*/{}
  , /*decltype(_impl_.total_number_)*/0u
  , /*decltype(_impl_.opt_next_asset_id_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct AccountAssetResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AccountAssetResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~AccountAssetResponseDefaultTypeInternal() {}
  union {
    AccountAssetResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AccountAssetResponseDefaultTypeInternal _AccountAssetResponse_default_instance_;
PROTOBUF_CONSTEXPR AccountDetailResponse::AccountDetailResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.detail_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.next_record_id_)*/nullptr
  , /*decltype(_impl_.total_number_)*/uint64_t{0u}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct AccountDetailResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AccountDetailResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~AccountDetailResponseDefaultTypeInternal() {}
  union {
    AccountDetailResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AccountDetailResponseDefaultTypeInternal _AccountDetailResponse_default_instance_;
PROTOBUF_CONSTEXPR AccountResponse::AccountResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.account_roles_)*/{}
  , /*decltype(_impl_.account_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct AccountResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AccountResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~AccountResponseDefaultTypeInternal() {}
  union {
    AccountResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AccountResponseDefaultTypeInternal _AccountResponse_default_instance_;
PROTOBUF_CONSTEXPR AssetResponse::AssetResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.asset_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct AssetResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AssetResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~AssetResponseDefaultTypeInternal() {}
  union {
    AssetResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AssetResponseDefaultTypeInternal _AssetResponse_default_instance_;
PROTOBUF_CONSTEXPR RolesResponse::RolesResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.roles_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct RolesResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RolesResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RolesResponseDefaultTypeInternal() {}
  union {
    RolesResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RolesResponseDefaultTypeInternal _RolesResponse_default_instance_;
PROTOBUF_CONSTEXPR RolePermissionsResponse::RolePermissionsResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.permissions_)*/{}
  , /*decltype(_impl_._permissions_cached_byte_size_)*/{0}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct RolePermissionsResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RolePermissionsResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RolePermissionsResponseDefaultTypeInternal() {}
  union {
    RolePermissionsResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RolePermissionsResponseDefaultTypeInternal _RolePermissionsResponse_default_instance_;
PROTOBUF_CONSTEXPR ErrorResponse::ErrorResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.message_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.reason_)*/0
  , /*decltype(_impl_.error_code_)*/0u
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ErrorResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ErrorResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ErrorResponseDefaultTypeInternal() {}
  union {
    ErrorResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ErrorResponseDefaultTypeInternal _ErrorResponse_default_instance_;
PROTOBUF_CONSTEXPR SignatoriesResponse::SignatoriesResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.keys_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct SignatoriesResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SignatoriesResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SignatoriesResponseDefaultTypeInternal() {}
  union {
    SignatoriesResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SignatoriesResponseDefaultTypeInternal _SignatoriesResponse_default_instance_;
PROTOBUF_CONSTEXPR TransactionsResponse::TransactionsResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.transactions_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct TransactionsResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TransactionsResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TransactionsResponseDefaultTypeInternal() {}
  union {
    TransactionsResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TransactionsResponseDefaultTypeInternal _TransactionsResponse_default_instance_;
PROTOBUF_CONSTEXPR TransactionsPageResponse::TransactionsPageResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.transactions_)*/{}
  , /*decltype(_impl_.all_transactions_size_)*/0u
  , /*decltype(_impl_.next_page_tag_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct TransactionsPageResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TransactionsPageResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TransactionsPageResponseDefaultTypeInternal() {}
  union {
    TransactionsPageResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TransactionsPageResponseDefaultTypeInternal _TransactionsPageResponse_default_instance_;
PROTOBUF_CONSTEXPR PendingTransactionsPageResponse_BatchInfo::PendingTransactionsPageResponse_BatchInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.first_tx_hash_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.batch_size_)*/0u
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct PendingTransactionsPageResponse_BatchInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PendingTransactionsPageResponse_BatchInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PendingTransactionsPageResponse_BatchInfoDefaultTypeInternal() {}
  union {
    PendingTransactionsPageResponse_BatchInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PendingTransactionsPageResponse_BatchInfoDefaultTypeInternal _PendingTransactionsPageResponse_BatchInfo_default_instance_;
PROTOBUF_CONSTEXPR PendingTransactionsPageResponse::PendingTransactionsPageResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.transactions_)*/{}
  , /*decltype(_impl_.next_batch_info_)*/nullptr
  , /*decltype(_impl_.all_transactions_size_)*/0u
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct PendingTransactionsPageResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PendingTransactionsPageResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PendingTransactionsPageResponseDefaultTypeInternal() {}
  union {
    PendingTransactionsPageResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PendingTransactionsPageResponseDefaultTypeInternal _PendingTransactionsPageResponse_default_instance_;
PROTOBUF_CONSTEXPR PeersResponse::PeersResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.peers_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct PeersResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PeersResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PeersResponseDefaultTypeInternal() {}
  union {
    PeersResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PeersResponseDefaultTypeInternal _PeersResponse_default_instance_;
PROTOBUF_CONSTEXPR EngineReceiptsResponse::EngineReceiptsResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.engine_receipts_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct EngineReceiptsResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EngineReceiptsResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~EngineReceiptsResponseDefaultTypeInternal() {}
  union {
    EngineReceiptsResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EngineReceiptsResponseDefaultTypeInternal _EngineReceiptsResponse_default_instance_;
PROTOBUF_CONSTEXPR QueryResponse::QueryResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.query_hash_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.response_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct QueryResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR QueryResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~QueryResponseDefaultTypeInternal() {}
  union {
    QueryResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 QueryResponseDefaultTypeInternal _QueryResponse_default_instance_;
PROTOBUF_CONSTEXPR BlockResponse::BlockResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.block_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct BlockResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BlockResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~BlockResponseDefaultTypeInternal() {}
  union {
    BlockResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BlockResponseDefaultTypeInternal _BlockResponse_default_instance_;
PROTOBUF_CONSTEXPR BlockErrorResponse::BlockErrorResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.message_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct BlockErrorResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BlockErrorResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~BlockErrorResponseDefaultTypeInternal() {}
  union {
    BlockErrorResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BlockErrorResponseDefaultTypeInternal _BlockErrorResponse_default_instance_;
PROTOBUF_CONSTEXPR BlockQueryResponse::BlockQueryResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.response_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct BlockQueryResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BlockQueryResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~BlockQueryResponseDefaultTypeInternal() {}
  union {
    BlockQueryResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BlockQueryResponseDefaultTypeInternal _BlockQueryResponse_default_instance_;
PROTOBUF_CONSTEXPR HealthcheckData::HealthcheckData(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.opt_memory_consumption_)*/{}
  , /*decltype(_impl_.opt_is_healthy_)*/{}
  , /*decltype(_impl_.opt_is_syncing_)*/{}
  , /*decltype(_impl_.opt_last_block_height_)*/{}
  , /*decltype(_impl_.opt_last_block_reject_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct HealthcheckDataDefaultTypeInternal {
  PROTOBUF_CONSTEXPR HealthcheckDataDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~HealthcheckDataDefaultTypeInternal() {}
  union {
    HealthcheckData _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 HealthcheckDataDefaultTypeInternal _HealthcheckData_default_instance_;
}  // namespace protocol
}  // namespace iroha
static ::_pb::Metadata file_level_metadata_qry_5fresponses_2eproto[23];
static const ::_pb::EnumDescriptor* file_level_enum_descriptors_qry_5fresponses_2eproto[1];
static constexpr ::_pb::ServiceDescriptor const** file_level_service_descriptors_qry_5fresponses_2eproto = nullptr;

const uint32_t TableStruct_qry_5fresponses_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::iroha::protocol::Asset, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::iroha::protocol::Asset, _impl_.asset_id_),
  PROTOBUF_FIELD_OFFSET(::iroha::protocol::Asset, _impl_.domain_id_),
  PROTOBUF_FIELD_OFFSET(::iroha::protocol::Asset, _impl_.precision_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::iroha::protocol::Domain, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::iroha::protocol::Domain, _impl_.domain_id_),
  PROTOBUF_FIELD_OFFSET(::iroha::protocol::Domain, _impl_.default_role_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::iroha::protocol::Account, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::iroha::protocol::Account, _impl_.account_id_),
  PROTOBUF_FIELD_OFFSET(::iroha::protocol::Account, _impl_.domain_id_),
  PROTOBUF_FIELD_OFFSET(::iroha::protocol::Account, _impl_.quorum_),
  PROTOBUF_FIELD_OFFSET(::iroha::protocol::Account, _impl_.json_data_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::iroha::protocol::AccountAsset, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::iroha::protocol::AccountAsset, _impl_.asset_id_),
  PROTOBUF_FIELD_OFFSET(::iroha::protocol::AccountAsset, _impl_.account_id_),
  PROTOBUF_FIELD_OFFSET(::iroha::protocol::AccountAsset, _impl_.balance_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::iroha::protocol::AccountAssetResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::iroha::protocol::AccountAssetResponse, _impl_._oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::iroha::protocol::AccountAssetResponse, _impl_.account_assets_),
  PROTOBUF_FIELD_OFFSET(::iroha::protocol::AccountAssetResponse, _impl_.total_number_),
  ::_pbi::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::iroha::protocol::AccountAssetResponse, _impl_.opt_next_asset_id_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::iroha::protocol::AccountDetailResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::iroha::protocol::AccountDetailResponse, _impl_.detail_),
  PROTOBUF_FIELD_OFFSET(::iroha::protocol::AccountDetailResponse, _impl_.total_number_),
  PROTOBUF_FIELD_OFFSET(::iroha::protocol::AccountDetailResponse, _impl_.next_record_id_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::iroha::protocol::AccountResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::iroha::protocol::AccountResponse, _impl_.account_),
  PROTOBUF_FIELD_OFFSET(::iroha::protocol::AccountResponse, _impl_.account_roles_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::iroha::protocol::AssetResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::iroha::protocol::AssetResponse, _impl_.asset_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::iroha::protocol::RolesResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::iroha::protocol::RolesResponse, _impl_.roles_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::iroha::protocol::RolePermissionsResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::iroha::protocol::RolePermissionsResponse, _impl_.permissions_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::iroha::protocol::ErrorResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::iroha::protocol::ErrorResponse, _impl_.reason_),
  PROTOBUF_FIELD_OFFSET(::iroha::protocol::ErrorResponse, _impl_.message_),
  PROTOBUF_FIELD_OFFSET(::iroha::protocol::ErrorResponse, _impl_.error_code_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::iroha::protocol::SignatoriesResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::iroha::protocol::SignatoriesResponse, _impl_.keys_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::iroha::protocol::TransactionsResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::iroha::protocol::TransactionsResponse, _impl_.transactions_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::iroha::protocol::TransactionsPageResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::iroha::protocol::TransactionsPageResponse, _impl_._oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::iroha::protocol::TransactionsPageResponse, _impl_.transactions_),
  PROTOBUF_FIELD_OFFSET(::iroha::protocol::TransactionsPageResponse, _impl_.all_transactions_size_),
  ::_pbi::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::iroha::protocol::TransactionsPageResponse, _impl_.next_page_tag_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::iroha::protocol::PendingTransactionsPageResponse_BatchInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::iroha::protocol::PendingTransactionsPageResponse_BatchInfo, _impl_.first_tx_hash_),
  PROTOBUF_FIELD_OFFSET(::iroha::protocol::PendingTransactionsPageResponse_BatchInfo, _impl_.batch_size_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::iroha::protocol::PendingTransactionsPageResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::iroha::protocol::PendingTransactionsPageResponse, _impl_.transactions_),
  PROTOBUF_FIELD_OFFSET(::iroha::protocol::PendingTransactionsPageResponse, _impl_.all_transactions_size_),
  PROTOBUF_FIELD_OFFSET(::iroha::protocol::PendingTransactionsPageResponse, _impl_.next_batch_info_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::iroha::protocol::PeersResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::iroha::protocol::PeersResponse, _impl_.peers_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::iroha::protocol::EngineReceiptsResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::iroha::protocol::EngineReceiptsResponse, _impl_.engine_receipts_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::iroha::protocol::QueryResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::iroha::protocol::QueryResponse, _impl_._oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::iroha::protocol::QueryResponse, _impl_.query_hash_),
  PROTOBUF_FIELD_OFFSET(::iroha::protocol::QueryResponse, _impl_.response_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::iroha::protocol::BlockResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::iroha::protocol::BlockResponse, _impl_.block_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::iroha::protocol::BlockErrorResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::iroha::protocol::BlockErrorResponse, _impl_.message_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::iroha::protocol::BlockQueryResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::iroha::protocol::BlockQueryResponse, _impl_._oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::iroha::protocol::BlockQueryResponse, _impl_.response_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::iroha::protocol::HealthcheckData, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::iroha::protocol::HealthcheckData, _impl_._oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::iroha::protocol::HealthcheckData, _impl_.opt_memory_consumption_),
  PROTOBUF_FIELD_OFFSET(::iroha::protocol::HealthcheckData, _impl_.opt_is_healthy_),
  PROTOBUF_FIELD_OFFSET(::iroha::protocol::HealthcheckData, _impl_.opt_is_syncing_),
  PROTOBUF_FIELD_OFFSET(::iroha::protocol::HealthcheckData, _impl_.opt_last_block_height_),
  PROTOBUF_FIELD_OFFSET(::iroha::protocol::HealthcheckData, _impl_.opt_last_block_reject_),
};
static const ::_pbi::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, -1, -1, sizeof(::iroha::protocol::Asset)},
  { 9, -1, -1, sizeof(::iroha::protocol::Domain)},
  { 17, -1, -1, sizeof(::iroha::protocol::Account)},
  { 27, -1, -1, sizeof(::iroha::protocol::AccountAsset)},
  { 36, -1, -1, sizeof(::iroha::protocol::AccountAssetResponse)},
  { 46, -1, -1, sizeof(::iroha::protocol::AccountDetailResponse)},
  { 55, -1, -1, sizeof(::iroha::protocol::AccountResponse)},
  { 63, -1, -1, sizeof(::iroha::protocol::AssetResponse)},
  { 70, -1, -1, sizeof(::iroha::protocol::RolesResponse)},
  { 77, -1, -1, sizeof(::iroha::protocol::RolePermissionsResponse)},
  { 84, -1, -1, sizeof(::iroha::protocol::ErrorResponse)},
  { 93, -1, -1, sizeof(::iroha::protocol::SignatoriesResponse)},
  { 100, -1, -1, sizeof(::iroha::protocol::TransactionsResponse)},
  { 107, -1, -1, sizeof(::iroha::protocol::TransactionsPageResponse)},
  { 117, -1, -1, sizeof(::iroha::protocol::PendingTransactionsPageResponse_BatchInfo)},
  { 125, -1, -1, sizeof(::iroha::protocol::PendingTransactionsPageResponse)},
  { 134, -1, -1, sizeof(::iroha::protocol::PeersResponse)},
  { 141, -1, -1, sizeof(::iroha::protocol::EngineReceiptsResponse)},
  { 148, -1, -1, sizeof(::iroha::protocol::QueryResponse)},
  { 170, -1, -1, sizeof(::iroha::protocol::BlockResponse)},
  { 177, -1, -1, sizeof(::iroha::protocol::BlockErrorResponse)},
  { 184, -1, -1, sizeof(::iroha::protocol::BlockQueryResponse)},
  { 193, -1, -1, sizeof(::iroha::protocol::HealthcheckData)},
};

static const ::_pb::Message* const file_default_instances[] = {
  &::iroha::protocol::_Asset_default_instance_._instance,
  &::iroha::protocol::_Domain_default_instance_._instance,
  &::iroha::protocol::_Account_default_instance_._instance,
  &::iroha::protocol::_AccountAsset_default_instance_._instance,
  &::iroha::protocol::_AccountAssetResponse_default_instance_._instance,
  &::iroha::protocol::_AccountDetailResponse_default_instance_._instance,
  &::iroha::protocol::_AccountResponse_default_instance_._instance,
  &::iroha::protocol::_AssetResponse_default_instance_._instance,
  &::iroha::protocol::_RolesResponse_default_instance_._instance,
  &::iroha::protocol::_RolePermissionsResponse_default_instance_._instance,
  &::iroha::protocol::_ErrorResponse_default_instance_._instance,
  &::iroha::protocol::_SignatoriesResponse_default_instance_._instance,
  &::iroha::protocol::_TransactionsResponse_default_instance_._instance,
  &::iroha::protocol::_TransactionsPageResponse_default_instance_._instance,
  &::iroha::protocol::_PendingTransactionsPageResponse_BatchInfo_default_instance_._instance,
  &::iroha::protocol::_PendingTransactionsPageResponse_default_instance_._instance,
  &::iroha::protocol::_PeersResponse_default_instance_._instance,
  &::iroha::protocol::_EngineReceiptsResponse_default_instance_._instance,
  &::iroha::protocol::_QueryResponse_default_instance_._instance,
  &::iroha::protocol::_BlockResponse_default_instance_._instance,
  &::iroha::protocol::_BlockErrorResponse_default_instance_._instance,
  &::iroha::protocol::_BlockQueryResponse_default_instance_._instance,
  &::iroha::protocol::_HealthcheckData_default_instance_._instance,
};

const char descriptor_table_protodef_qry_5fresponses_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\023qry_responses.proto\022\016iroha.protocol\032\013b"
  "lock.proto\032\021transaction.proto\032\017primitive"
  ".proto\"\?\n\005Asset\022\020\n\010asset_id\030\001 \001(\t\022\021\n\tdom"
  "ain_id\030\002 \001(\t\022\021\n\tprecision\030\003 \001(\r\"1\n\006Domai"
  "n\022\021\n\tdomain_id\030\001 \001(\t\022\024\n\014default_role\030\002 \001"
  "(\t\"S\n\007Account\022\022\n\naccount_id\030\001 \001(\t\022\021\n\tdom"
  "ain_id\030\002 \001(\t\022\016\n\006quorum\030\003 \001(\r\022\021\n\tjson_dat"
  "a\030\004 \001(\t\"E\n\014AccountAsset\022\020\n\010asset_id\030\001 \001("
  "\t\022\022\n\naccount_id\030\002 \001(\t\022\017\n\007balance\030\003 \001(\t\"\220"
  "\001\n\024AccountAssetResponse\0224\n\016account_asset"
  "s\030\001 \003(\0132\034.iroha.protocol.AccountAsset\022\024\n"
  "\014total_number\030\002 \001(\r\022\027\n\rnext_asset_id\030\003 \001"
  "(\tH\000B\023\n\021opt_next_asset_id\"|\n\025AccountDeta"
  "ilResponse\022\016\n\006detail\030\001 \001(\t\022\024\n\014total_numb"
  "er\030\002 \001(\004\022=\n\016next_record_id\030\003 \001(\0132%.iroha"
  ".protocol.AccountDetailRecordId\"R\n\017Accou"
  "ntResponse\022(\n\007account\030\001 \001(\0132\027.iroha.prot"
  "ocol.Account\022\025\n\raccount_roles\030\002 \003(\t\"5\n\rA"
  "ssetResponse\022$\n\005asset\030\001 \001(\0132\025.iroha.prot"
  "ocol.Asset\"\036\n\rRolesResponse\022\r\n\005roles\030\001 \003"
  "(\t\"N\n\027RolePermissionsResponse\0223\n\013permiss"
  "ions\030\001 \003(\0162\036.iroha.protocol.RolePermissi"
  "on\"\243\002\n\rErrorResponse\0224\n\006reason\030\001 \001(\0162$.i"
  "roha.protocol.ErrorResponse.Reason\022\017\n\007me"
  "ssage\030\002 \001(\t\022\022\n\nerror_code\030\003 \001(\r\"\266\001\n\006Reas"
  "on\022\025\n\021STATELESS_INVALID\020\000\022\024\n\020STATEFUL_IN"
  "VALID\020\001\022\016\n\nNO_ACCOUNT\020\002\022\025\n\021NO_ACCOUNT_AS"
  "SETS\020\003\022\025\n\021NO_ACCOUNT_DETAIL\020\004\022\022\n\016NO_SIGN"
  "ATORIES\020\005\022\021\n\rNOT_SUPPORTED\020\006\022\014\n\010NO_ASSET"
  "\020\007\022\014\n\010NO_ROLES\020\010\"#\n\023SignatoriesResponse\022"
  "\014\n\004keys\030\001 \003(\t\"I\n\024TransactionsResponse\0221\n"
  "\014transactions\030\001 \003(\0132\033.iroha.protocol.Tra"
  "nsaction\"\225\001\n\030TransactionsPageResponse\0221\n"
  "\014transactions\030\001 \003(\0132\033.iroha.protocol.Tra"
  "nsaction\022\035\n\025all_transactions_size\030\002 \001(\r\022"
  "\026\n\014next_tx_hash\030\003 \001(\tH\000B\017\n\rnext_page_tag"
  "\"\377\001\n\037PendingTransactionsPageResponse\0221\n\014"
  "transactions\030\001 \003(\0132\033.iroha.protocol.Tran"
  "saction\022\035\n\025all_transactions_size\030\002 \001(\r\022R"
  "\n\017next_batch_info\030\003 \001(\01329.iroha.protocol"
  ".PendingTransactionsPageResponse.BatchIn"
  "fo\0326\n\tBatchInfo\022\025\n\rfirst_tx_hash\030\001 \001(\t\022\022"
  "\n\nbatch_size\030\002 \001(\r\"4\n\rPeersResponse\022#\n\005p"
  "eers\030\001 \003(\0132\024.iroha.protocol.Peer\"P\n\026Engi"
  "neReceiptsResponse\0226\n\017engine_receipts\030\001 "
  "\003(\0132\035.iroha.protocol.EngineReceipt\"\361\007\n\rQ"
  "ueryResponse\022G\n\027account_assets_response\030"
  "\001 \001(\0132$.iroha.protocol.AccountAssetRespo"
  "nseH\000\022H\n\027account_detail_response\030\002 \001(\0132%"
  ".iroha.protocol.AccountDetailResponseH\000\022"
  ";\n\020account_response\030\003 \001(\0132\037.iroha.protoc"
  "ol.AccountResponseH\000\0227\n\016error_response\030\004"
  " \001(\0132\035.iroha.protocol.ErrorResponseH\000\022C\n"
  "\024signatories_response\030\005 \001(\0132#.iroha.prot"
  "ocol.SignatoriesResponseH\000\022E\n\025transactio"
  "ns_response\030\006 \001(\0132$.iroha.protocol.Trans"
  "actionsResponseH\000\0227\n\016asset_response\030\007 \001("
  "\0132\035.iroha.protocol.AssetResponseH\000\0227\n\016ro"
  "les_response\030\010 \001(\0132\035.iroha.protocol.Role"
  "sResponseH\000\022L\n\031role_permissions_response"
  "\030\t \001(\0132\'.iroha.protocol.RolePermissionsR"
  "esponseH\000\022N\n\032transactions_page_response\030"
  "\013 \001(\0132(.iroha.protocol.TransactionsPageR"
  "esponseH\000\022]\n\"pending_transactions_page_r"
  "esponse\030\r \001(\0132/.iroha.protocol.PendingTr"
  "ansactionsPageResponseH\000\0227\n\016block_respon"
  "se\030\014 \001(\0132\035.iroha.protocol.BlockResponseH"
  "\000\0227\n\016peers_response\030\016 \001(\0132\035.iroha.protoc"
  "ol.PeersResponseH\000\022J\n\030engine_receipts_re"
  "sponse\030\017 \001(\0132&.iroha.protocol.EngineRece"
  "iptsResponseH\000\022\022\n\nquery_hash\030\n \001(\tB\n\n\010re"
  "sponse\"5\n\rBlockResponse\022$\n\005block\030\001 \001(\0132\025"
  ".iroha.protocol.Block\"%\n\022BlockErrorRespo"
  "nse\022\017\n\007message\030\001 \001(\t\"\235\001\n\022BlockQueryRespo"
  "nse\0227\n\016block_response\030\001 \001(\0132\035.iroha.prot"
  "ocol.BlockResponseH\000\022B\n\024block_error_resp"
  "onse\030\002 \001(\0132\".iroha.protocol.BlockErrorRe"
  "sponseH\000B\n\n\010response\"\205\002\n\017HealthcheckData"
  "\022\034\n\022memory_consumption\030\001 \001(\004H\000\022\024\n\nis_hea"
  "lthy\030\002 \001(\010H\001\022\024\n\nis_syncing\030\003 \001(\010H\002\022\033\n\021la"
  "st_block_height\030\004 \001(\004H\003\022\033\n\021last_block_re"
  "ject\030\005 \001(\004H\004B\030\n\026opt_memory_consumptionB\020"
  "\n\016opt_is_healthyB\020\n\016opt_is_syncingB\027\n\025op"
  "t_last_block_heightB\027\n\025opt_last_block_re"
  "jectB\032Z\030iroha.generated/protocolb\006proto3"
  ;
static const ::_pbi::DescriptorTable* const descriptor_table_qry_5fresponses_2eproto_deps[3] = {
  &::descriptor_table_block_2eproto,
  &::descriptor_table_primitive_2eproto,
  &::descriptor_table_transaction_2eproto,
};
static ::_pbi::once_flag descriptor_table_qry_5fresponses_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_qry_5fresponses_2eproto = {
    false, false, 3400, descriptor_table_protodef_qry_5fresponses_2eproto,
    "qry_responses.proto",
    &descriptor_table_qry_5fresponses_2eproto_once, descriptor_table_qry_5fresponses_2eproto_deps, 3, 23,
    schemas, file_default_instances, TableStruct_qry_5fresponses_2eproto::offsets,
    file_level_metadata_qry_5fresponses_2eproto, file_level_enum_descriptors_qry_5fresponses_2eproto,
    file_level_service_descriptors_qry_5fresponses_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_qry_5fresponses_2eproto_getter() {
  return &descriptor_table_qry_5fresponses_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_qry_5fresponses_2eproto(&descriptor_table_qry_5fresponses_2eproto);
namespace iroha {
namespace protocol {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ErrorResponse_Reason_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_qry_5fresponses_2eproto);
  return file_level_enum_descriptors_qry_5fresponses_2eproto[0];
}
bool ErrorResponse_Reason_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ErrorResponse_Reason ErrorResponse::STATELESS_INVALID;
constexpr ErrorResponse_Reason ErrorResponse::STATEFUL_INVALID;
constexpr ErrorResponse_Reason ErrorResponse::NO_ACCOUNT;
constexpr ErrorResponse_Reason ErrorResponse::NO_ACCOUNT_ASSETS;
constexpr ErrorResponse_Reason ErrorResponse::NO_ACCOUNT_DETAIL;
constexpr ErrorResponse_Reason ErrorResponse::NO_SIGNATORIES;
constexpr ErrorResponse_Reason ErrorResponse::NOT_SUPPORTED;
constexpr ErrorResponse_Reason ErrorResponse::NO_ASSET;
constexpr ErrorResponse_Reason ErrorResponse::NO_ROLES;
constexpr ErrorResponse_Reason ErrorResponse::Reason_MIN;
constexpr ErrorResponse_Reason ErrorResponse::Reason_MAX;
constexpr int ErrorResponse::Reason_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

// ===================================================================

class Asset::_Internal {
 public:
};

Asset::Asset(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:iroha.protocol.Asset)
}
Asset::Asset(const Asset& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Asset* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.asset_id_){}
    , decltype(_impl_.domain_id_){}
    , decltype(_impl_.precision_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.asset_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.asset_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_asset_id().empty()) {
    _this->_impl_.asset_id_.Set(from._internal_asset_id(), 
      _this->GetArenaForAllocation());
  }
  _impl_.domain_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.domain_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_domain_id().empty()) {
    _this->_impl_.domain_id_.Set(from._internal_domain_id(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.precision_ = from._impl_.precision_;
  // @@protoc_insertion_point(copy_constructor:iroha.protocol.Asset)
}

inline void Asset::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.asset_id_){}
    , decltype(_impl_.domain_id_){}
    , decltype(_impl_.precision_){0u}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.asset_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.asset_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.domain_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.domain_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Asset::~Asset() {
  // @@protoc_insertion_point(destructor:iroha.protocol.Asset)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Asset::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.asset_id_.Destroy();
  _impl_.domain_id_.Destroy();
}

void Asset::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Asset::Clear() {
// @@protoc_insertion_point(message_clear_start:iroha.protocol.Asset)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.asset_id_.ClearToEmpty();
  _impl_.domain_id_.ClearToEmpty();
  _impl_.precision_ = 0u;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Asset::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string asset_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_asset_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "iroha.protocol.Asset.asset_id"));
        } else
          goto handle_unusual;
        continue;
      // string domain_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_domain_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "iroha.protocol.Asset.domain_id"));
        } else
          goto handle_unusual;
        continue;
      // uint32 precision = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.precision_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Asset::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:iroha.protocol.Asset)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string asset_id = 1;
  if (!this->_internal_asset_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_asset_id().data(), static_cast<int>(this->_internal_asset_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "iroha.protocol.Asset.asset_id");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_asset_id(), target);
  }

  // string domain_id = 2;
  if (!this->_internal_domain_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_domain_id().data(), static_cast<int>(this->_internal_domain_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "iroha.protocol.Asset.domain_id");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_domain_id(), target);
  }

  // uint32 precision = 3;
  if (this->_internal_precision() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_precision(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:iroha.protocol.Asset)
  return target;
}

size_t Asset::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:iroha.protocol.Asset)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string asset_id = 1;
  if (!this->_internal_asset_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_asset_id());
  }

  // string domain_id = 2;
  if (!this->_internal_domain_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_domain_id());
  }

  // uint32 precision = 3;
  if (this->_internal_precision() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_precision());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Asset::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Asset::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Asset::GetClassData() const { return &_class_data_; }


void Asset::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Asset*>(&to_msg);
  auto& from = static_cast<const Asset&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:iroha.protocol.Asset)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_asset_id().empty()) {
    _this->_internal_set_asset_id(from._internal_asset_id());
  }
  if (!from._internal_domain_id().empty()) {
    _this->_internal_set_domain_id(from._internal_domain_id());
  }
  if (from._internal_precision() != 0) {
    _this->_internal_set_precision(from._internal_precision());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Asset::CopyFrom(const Asset& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:iroha.protocol.Asset)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Asset::IsInitialized() const {
  return true;
}

void Asset::InternalSwap(Asset* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.asset_id_, lhs_arena,
      &other->_impl_.asset_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.domain_id_, lhs_arena,
      &other->_impl_.domain_id_, rhs_arena
  );
  swap(_impl_.precision_, other->_impl_.precision_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Asset::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_qry_5fresponses_2eproto_getter, &descriptor_table_qry_5fresponses_2eproto_once,
      file_level_metadata_qry_5fresponses_2eproto[0]);
}

// ===================================================================

class Domain::_Internal {
 public:
};

Domain::Domain(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:iroha.protocol.Domain)
}
Domain::Domain(const Domain& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Domain* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.domain_id_){}
    , decltype(_impl_.default_role_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.domain_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.domain_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_domain_id().empty()) {
    _this->_impl_.domain_id_.Set(from._internal_domain_id(), 
      _this->GetArenaForAllocation());
  }
  _impl_.default_role_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.default_role_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_default_role().empty()) {
    _this->_impl_.default_role_.Set(from._internal_default_role(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:iroha.protocol.Domain)
}

inline void Domain::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.domain_id_){}
    , decltype(_impl_.default_role_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.domain_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.domain_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.default_role_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.default_role_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Domain::~Domain() {
  // @@protoc_insertion_point(destructor:iroha.protocol.Domain)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Domain::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.domain_id_.Destroy();
  _impl_.default_role_.Destroy();
}

void Domain::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Domain::Clear() {
// @@protoc_insertion_point(message_clear_start:iroha.protocol.Domain)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.domain_id_.ClearToEmpty();
  _impl_.default_role_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Domain::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string domain_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_domain_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "iroha.protocol.Domain.domain_id"));
        } else
          goto handle_unusual;
        continue;
      // string default_role = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_default_role();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "iroha.protocol.Domain.default_role"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Domain::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:iroha.protocol.Domain)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string domain_id = 1;
  if (!this->_internal_domain_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_domain_id().data(), static_cast<int>(this->_internal_domain_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "iroha.protocol.Domain.domain_id");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_domain_id(), target);
  }

  // string default_role = 2;
  if (!this->_internal_default_role().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_default_role().data(), static_cast<int>(this->_internal_default_role().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "iroha.protocol.Domain.default_role");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_default_role(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:iroha.protocol.Domain)
  return target;
}

size_t Domain::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:iroha.protocol.Domain)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string domain_id = 1;
  if (!this->_internal_domain_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_domain_id());
  }

  // string default_role = 2;
  if (!this->_internal_default_role().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_default_role());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Domain::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Domain::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Domain::GetClassData() const { return &_class_data_; }


void Domain::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Domain*>(&to_msg);
  auto& from = static_cast<const Domain&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:iroha.protocol.Domain)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_domain_id().empty()) {
    _this->_internal_set_domain_id(from._internal_domain_id());
  }
  if (!from._internal_default_role().empty()) {
    _this->_internal_set_default_role(from._internal_default_role());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Domain::CopyFrom(const Domain& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:iroha.protocol.Domain)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Domain::IsInitialized() const {
  return true;
}

void Domain::InternalSwap(Domain* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.domain_id_, lhs_arena,
      &other->_impl_.domain_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.default_role_, lhs_arena,
      &other->_impl_.default_role_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata Domain::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_qry_5fresponses_2eproto_getter, &descriptor_table_qry_5fresponses_2eproto_once,
      file_level_metadata_qry_5fresponses_2eproto[1]);
}

// ===================================================================

class Account::_Internal {
 public:
};

Account::Account(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:iroha.protocol.Account)
}
Account::Account(const Account& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Account* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.account_id_){}
    , decltype(_impl_.domain_id_){}
    , decltype(_impl_.json_data_){}
    , decltype(_impl_.quorum_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.account_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.account_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_account_id().empty()) {
    _this->_impl_.account_id_.Set(from._internal_account_id(), 
      _this->GetArenaForAllocation());
  }
  _impl_.domain_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.domain_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_domain_id().empty()) {
    _this->_impl_.domain_id_.Set(from._internal_domain_id(), 
      _this->GetArenaForAllocation());
  }
  _impl_.json_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.json_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_json_data().empty()) {
    _this->_impl_.json_data_.Set(from._internal_json_data(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.quorum_ = from._impl_.quorum_;
  // @@protoc_insertion_point(copy_constructor:iroha.protocol.Account)
}

inline void Account::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.account_id_){}
    , decltype(_impl_.domain_id_){}
    , decltype(_impl_.json_data_){}
    , decltype(_impl_.quorum_){0u}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.account_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.account_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.domain_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.domain_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.json_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.json_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Account::~Account() {
  // @@protoc_insertion_point(destructor:iroha.protocol.Account)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Account::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.account_id_.Destroy();
  _impl_.domain_id_.Destroy();
  _impl_.json_data_.Destroy();
}

void Account::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Account::Clear() {
// @@protoc_insertion_point(message_clear_start:iroha.protocol.Account)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.account_id_.ClearToEmpty();
  _impl_.domain_id_.ClearToEmpty();
  _impl_.json_data_.ClearToEmpty();
  _impl_.quorum_ = 0u;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Account::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string account_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_account_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "iroha.protocol.Account.account_id"));
        } else
          goto handle_unusual;
        continue;
      // string domain_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_domain_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "iroha.protocol.Account.domain_id"));
        } else
          goto handle_unusual;
        continue;
      // uint32 quorum = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.quorum_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string json_data = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_json_data();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "iroha.protocol.Account.json_data"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Account::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:iroha.protocol.Account)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string account_id = 1;
  if (!this->_internal_account_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_account_id().data(), static_cast<int>(this->_internal_account_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "iroha.protocol.Account.account_id");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_account_id(), target);
  }

  // string domain_id = 2;
  if (!this->_internal_domain_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_domain_id().data(), static_cast<int>(this->_internal_domain_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "iroha.protocol.Account.domain_id");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_domain_id(), target);
  }

  // uint32 quorum = 3;
  if (this->_internal_quorum() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_quorum(), target);
  }

  // string json_data = 4;
  if (!this->_internal_json_data().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_json_data().data(), static_cast<int>(this->_internal_json_data().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "iroha.protocol.Account.json_data");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_json_data(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:iroha.protocol.Account)
  return target;
}

size_t Account::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:iroha.protocol.Account)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string account_id = 1;
  if (!this->_internal_account_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_account_id());
  }

  // string domain_id = 2;
  if (!this->_internal_domain_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_domain_id());
  }

  // string json_data = 4;
  if (!this->_internal_json_data().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_json_data());
  }

  // uint32 quorum = 3;
  if (this->_internal_quorum() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_quorum());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Account::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Account::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Account::GetClassData() const { return &_class_data_; }


void Account::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Account*>(&to_msg);
  auto& from = static_cast<const Account&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:iroha.protocol.Account)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_account_id().empty()) {
    _this->_internal_set_account_id(from._internal_account_id());
  }
  if (!from._internal_domain_id().empty()) {
    _this->_internal_set_domain_id(from._internal_domain_id());
  }
  if (!from._internal_json_data().empty()) {
    _this->_internal_set_json_data(from._internal_json_data());
  }
  if (from._internal_quorum() != 0) {
    _this->_internal_set_quorum(from._internal_quorum());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Account::CopyFrom(const Account& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:iroha.protocol.Account)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Account::IsInitialized() const {
  return true;
}

void Account::InternalSwap(Account* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.account_id_, lhs_arena,
      &other->_impl_.account_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.domain_id_, lhs_arena,
      &other->_impl_.domain_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.json_data_, lhs_arena,
      &other->_impl_.json_data_, rhs_arena
  );
  swap(_impl_.quorum_, other->_impl_.quorum_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Account::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_qry_5fresponses_2eproto_getter, &descriptor_table_qry_5fresponses_2eproto_once,
      file_level_metadata_qry_5fresponses_2eproto[2]);
}

// ===================================================================

class AccountAsset::_Internal {
 public:
};

AccountAsset::AccountAsset(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:iroha.protocol.AccountAsset)
}
AccountAsset::AccountAsset(const AccountAsset& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  AccountAsset* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.asset_id_){}
    , decltype(_impl_.account_id_){}
    , decltype(_impl_.balance_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.asset_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.asset_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_asset_id().empty()) {
    _this->_impl_.asset_id_.Set(from._internal_asset_id(), 
      _this->GetArenaForAllocation());
  }
  _impl_.account_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.account_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_account_id().empty()) {
    _this->_impl_.account_id_.Set(from._internal_account_id(), 
      _this->GetArenaForAllocation());
  }
  _impl_.balance_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.balance_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_balance().empty()) {
    _this->_impl_.balance_.Set(from._internal_balance(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:iroha.protocol.AccountAsset)
}

inline void AccountAsset::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.asset_id_){}
    , decltype(_impl_.account_id_){}
    , decltype(_impl_.balance_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.asset_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.asset_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.account_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.account_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.balance_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.balance_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

AccountAsset::~AccountAsset() {
  // @@protoc_insertion_point(destructor:iroha.protocol.AccountAsset)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AccountAsset::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.asset_id_.Destroy();
  _impl_.account_id_.Destroy();
  _impl_.balance_.Destroy();
}

void AccountAsset::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AccountAsset::Clear() {
// @@protoc_insertion_point(message_clear_start:iroha.protocol.AccountAsset)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.asset_id_.ClearToEmpty();
  _impl_.account_id_.ClearToEmpty();
  _impl_.balance_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AccountAsset::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string asset_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_asset_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "iroha.protocol.AccountAsset.asset_id"));
        } else
          goto handle_unusual;
        continue;
      // string account_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_account_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "iroha.protocol.AccountAsset.account_id"));
        } else
          goto handle_unusual;
        continue;
      // string balance = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_balance();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "iroha.protocol.AccountAsset.balance"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AccountAsset::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:iroha.protocol.AccountAsset)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string asset_id = 1;
  if (!this->_internal_asset_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_asset_id().data(), static_cast<int>(this->_internal_asset_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "iroha.protocol.AccountAsset.asset_id");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_asset_id(), target);
  }

  // string account_id = 2;
  if (!this->_internal_account_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_account_id().data(), static_cast<int>(this->_internal_account_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "iroha.protocol.AccountAsset.account_id");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_account_id(), target);
  }

  // string balance = 3;
  if (!this->_internal_balance().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_balance().data(), static_cast<int>(this->_internal_balance().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "iroha.protocol.AccountAsset.balance");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_balance(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:iroha.protocol.AccountAsset)
  return target;
}

size_t AccountAsset::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:iroha.protocol.AccountAsset)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string asset_id = 1;
  if (!this->_internal_asset_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_asset_id());
  }

  // string account_id = 2;
  if (!this->_internal_account_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_account_id());
  }

  // string balance = 3;
  if (!this->_internal_balance().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_balance());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AccountAsset::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    AccountAsset::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AccountAsset::GetClassData() const { return &_class_data_; }


void AccountAsset::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<AccountAsset*>(&to_msg);
  auto& from = static_cast<const AccountAsset&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:iroha.protocol.AccountAsset)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_asset_id().empty()) {
    _this->_internal_set_asset_id(from._internal_asset_id());
  }
  if (!from._internal_account_id().empty()) {
    _this->_internal_set_account_id(from._internal_account_id());
  }
  if (!from._internal_balance().empty()) {
    _this->_internal_set_balance(from._internal_balance());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AccountAsset::CopyFrom(const AccountAsset& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:iroha.protocol.AccountAsset)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AccountAsset::IsInitialized() const {
  return true;
}

void AccountAsset::InternalSwap(AccountAsset* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.asset_id_, lhs_arena,
      &other->_impl_.asset_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.account_id_, lhs_arena,
      &other->_impl_.account_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.balance_, lhs_arena,
      &other->_impl_.balance_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata AccountAsset::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_qry_5fresponses_2eproto_getter, &descriptor_table_qry_5fresponses_2eproto_once,
      file_level_metadata_qry_5fresponses_2eproto[3]);
}

// ===================================================================

class AccountAssetResponse::_Internal {
 public:
};

AccountAssetResponse::AccountAssetResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:iroha.protocol.AccountAssetResponse)
}
AccountAssetResponse::AccountAssetResponse(const AccountAssetResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  AccountAssetResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.account_assets_){from._impl_.account_assets_}
    , decltype(_impl_.total_number_){}
    , decltype(_impl_.opt_next_asset_id_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.total_number_ = from._impl_.total_number_;
  clear_has_opt_next_asset_id();
  switch (from.opt_next_asset_id_case()) {
    case kNextAssetId: {
      _this->_internal_set_next_asset_id(from._internal_next_asset_id());
      break;
    }
    case OPT_NEXT_ASSET_ID_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:iroha.protocol.AccountAssetResponse)
}

inline void AccountAssetResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.account_assets_){arena}
    , decltype(_impl_.total_number_){0u}
    , decltype(_impl_.opt_next_asset_id_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_opt_next_asset_id();
}

AccountAssetResponse::~AccountAssetResponse() {
  // @@protoc_insertion_point(destructor:iroha.protocol.AccountAssetResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AccountAssetResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.account_assets_.~RepeatedPtrField();
  if (has_opt_next_asset_id()) {
    clear_opt_next_asset_id();
  }
}

void AccountAssetResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AccountAssetResponse::clear_opt_next_asset_id() {
// @@protoc_insertion_point(one_of_clear_start:iroha.protocol.AccountAssetResponse)
  switch (opt_next_asset_id_case()) {
    case kNextAssetId: {
      _impl_.opt_next_asset_id_.next_asset_id_.Destroy();
      break;
    }
    case OPT_NEXT_ASSET_ID_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = OPT_NEXT_ASSET_ID_NOT_SET;
}


void AccountAssetResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:iroha.protocol.AccountAssetResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.account_assets_.Clear();
  _impl_.total_number_ = 0u;
  clear_opt_next_asset_id();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AccountAssetResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .iroha.protocol.AccountAsset account_assets = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_account_assets(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // uint32 total_number = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.total_number_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string next_asset_id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_next_asset_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "iroha.protocol.AccountAssetResponse.next_asset_id"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AccountAssetResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:iroha.protocol.AccountAssetResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .iroha.protocol.AccountAsset account_assets = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_account_assets_size()); i < n; i++) {
    const auto& repfield = this->_internal_account_assets(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  // uint32 total_number = 2;
  if (this->_internal_total_number() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_total_number(), target);
  }

  // string next_asset_id = 3;
  if (_internal_has_next_asset_id()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_next_asset_id().data(), static_cast<int>(this->_internal_next_asset_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "iroha.protocol.AccountAssetResponse.next_asset_id");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_next_asset_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:iroha.protocol.AccountAssetResponse)
  return target;
}

size_t AccountAssetResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:iroha.protocol.AccountAssetResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .iroha.protocol.AccountAsset account_assets = 1;
  total_size += 1UL * this->_internal_account_assets_size();
  for (const auto& msg : this->_impl_.account_assets_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // uint32 total_number = 2;
  if (this->_internal_total_number() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_total_number());
  }

  switch (opt_next_asset_id_case()) {
    // string next_asset_id = 3;
    case kNextAssetId: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_next_asset_id());
      break;
    }
    case OPT_NEXT_ASSET_ID_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AccountAssetResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    AccountAssetResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AccountAssetResponse::GetClassData() const { return &_class_data_; }


void AccountAssetResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<AccountAssetResponse*>(&to_msg);
  auto& from = static_cast<const AccountAssetResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:iroha.protocol.AccountAssetResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.account_assets_.MergeFrom(from._impl_.account_assets_);
  if (from._internal_total_number() != 0) {
    _this->_internal_set_total_number(from._internal_total_number());
  }
  switch (from.opt_next_asset_id_case()) {
    case kNextAssetId: {
      _this->_internal_set_next_asset_id(from._internal_next_asset_id());
      break;
    }
    case OPT_NEXT_ASSET_ID_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AccountAssetResponse::CopyFrom(const AccountAssetResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:iroha.protocol.AccountAssetResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AccountAssetResponse::IsInitialized() const {
  return true;
}

void AccountAssetResponse::InternalSwap(AccountAssetResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.account_assets_.InternalSwap(&other->_impl_.account_assets_);
  swap(_impl_.total_number_, other->_impl_.total_number_);
  swap(_impl_.opt_next_asset_id_, other->_impl_.opt_next_asset_id_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata AccountAssetResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_qry_5fresponses_2eproto_getter, &descriptor_table_qry_5fresponses_2eproto_once,
      file_level_metadata_qry_5fresponses_2eproto[4]);
}

// ===================================================================

class AccountDetailResponse::_Internal {
 public:
  static const ::iroha::protocol::AccountDetailRecordId& next_record_id(const AccountDetailResponse* msg);
};

const ::iroha::protocol::AccountDetailRecordId&
AccountDetailResponse::_Internal::next_record_id(const AccountDetailResponse* msg) {
  return *msg->_impl_.next_record_id_;
}
void AccountDetailResponse::clear_next_record_id() {
  if (GetArenaForAllocation() == nullptr && _impl_.next_record_id_ != nullptr) {
    delete _impl_.next_record_id_;
  }
  _impl_.next_record_id_ = nullptr;
}
AccountDetailResponse::AccountDetailResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:iroha.protocol.AccountDetailResponse)
}
AccountDetailResponse::AccountDetailResponse(const AccountDetailResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  AccountDetailResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.detail_){}
    , decltype(_impl_.next_record_id_){nullptr}
    , decltype(_impl_.total_number_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.detail_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.detail_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_detail().empty()) {
    _this->_impl_.detail_.Set(from._internal_detail(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_next_record_id()) {
    _this->_impl_.next_record_id_ = new ::iroha::protocol::AccountDetailRecordId(*from._impl_.next_record_id_);
  }
  _this->_impl_.total_number_ = from._impl_.total_number_;
  // @@protoc_insertion_point(copy_constructor:iroha.protocol.AccountDetailResponse)
}

inline void AccountDetailResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.detail_){}
    , decltype(_impl_.next_record_id_){nullptr}
    , decltype(_impl_.total_number_){uint64_t{0u}}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.detail_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.detail_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

AccountDetailResponse::~AccountDetailResponse() {
  // @@protoc_insertion_point(destructor:iroha.protocol.AccountDetailResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AccountDetailResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.detail_.Destroy();
  if (this != internal_default_instance()) delete _impl_.next_record_id_;
}

void AccountDetailResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AccountDetailResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:iroha.protocol.AccountDetailResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.detail_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.next_record_id_ != nullptr) {
    delete _impl_.next_record_id_;
  }
  _impl_.next_record_id_ = nullptr;
  _impl_.total_number_ = uint64_t{0u};
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AccountDetailResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string detail = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_detail();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "iroha.protocol.AccountDetailResponse.detail"));
        } else
          goto handle_unusual;
        continue;
      // uint64 total_number = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.total_number_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .iroha.protocol.AccountDetailRecordId next_record_id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_next_record_id(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AccountDetailResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:iroha.protocol.AccountDetailResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string detail = 1;
  if (!this->_internal_detail().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_detail().data(), static_cast<int>(this->_internal_detail().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "iroha.protocol.AccountDetailResponse.detail");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_detail(), target);
  }

  // uint64 total_number = 2;
  if (this->_internal_total_number() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_total_number(), target);
  }

  // .iroha.protocol.AccountDetailRecordId next_record_id = 3;
  if (this->_internal_has_next_record_id()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::next_record_id(this),
        _Internal::next_record_id(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:iroha.protocol.AccountDetailResponse)
  return target;
}

size_t AccountDetailResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:iroha.protocol.AccountDetailResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string detail = 1;
  if (!this->_internal_detail().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_detail());
  }

  // .iroha.protocol.AccountDetailRecordId next_record_id = 3;
  if (this->_internal_has_next_record_id()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.next_record_id_);
  }

  // uint64 total_number = 2;
  if (this->_internal_total_number() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_total_number());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AccountDetailResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    AccountDetailResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AccountDetailResponse::GetClassData() const { return &_class_data_; }


void AccountDetailResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<AccountDetailResponse*>(&to_msg);
  auto& from = static_cast<const AccountDetailResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:iroha.protocol.AccountDetailResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_detail().empty()) {
    _this->_internal_set_detail(from._internal_detail());
  }
  if (from._internal_has_next_record_id()) {
    _this->_internal_mutable_next_record_id()->::iroha::protocol::AccountDetailRecordId::MergeFrom(
        from._internal_next_record_id());
  }
  if (from._internal_total_number() != 0) {
    _this->_internal_set_total_number(from._internal_total_number());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AccountDetailResponse::CopyFrom(const AccountDetailResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:iroha.protocol.AccountDetailResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AccountDetailResponse::IsInitialized() const {
  return true;
}

void AccountDetailResponse::InternalSwap(AccountDetailResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.detail_, lhs_arena,
      &other->_impl_.detail_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AccountDetailResponse, _impl_.total_number_)
      + sizeof(AccountDetailResponse::_impl_.total_number_)
      - PROTOBUF_FIELD_OFFSET(AccountDetailResponse, _impl_.next_record_id_)>(
          reinterpret_cast<char*>(&_impl_.next_record_id_),
          reinterpret_cast<char*>(&other->_impl_.next_record_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata AccountDetailResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_qry_5fresponses_2eproto_getter, &descriptor_table_qry_5fresponses_2eproto_once,
      file_level_metadata_qry_5fresponses_2eproto[5]);
}

// ===================================================================

class AccountResponse::_Internal {
 public:
  static const ::iroha::protocol::Account& account(const AccountResponse* msg);
};

const ::iroha::protocol::Account&
AccountResponse::_Internal::account(const AccountResponse* msg) {
  return *msg->_impl_.account_;
}
AccountResponse::AccountResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:iroha.protocol.AccountResponse)
}
AccountResponse::AccountResponse(const AccountResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  AccountResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.account_roles_){from._impl_.account_roles_}
    , decltype(_impl_.account_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_account()) {
    _this->_impl_.account_ = new ::iroha::protocol::Account(*from._impl_.account_);
  }
  // @@protoc_insertion_point(copy_constructor:iroha.protocol.AccountResponse)
}

inline void AccountResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.account_roles_){arena}
    , decltype(_impl_.account_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

AccountResponse::~AccountResponse() {
  // @@protoc_insertion_point(destructor:iroha.protocol.AccountResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AccountResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.account_roles_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.account_;
}

void AccountResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AccountResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:iroha.protocol.AccountResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.account_roles_.Clear();
  if (GetArenaForAllocation() == nullptr && _impl_.account_ != nullptr) {
    delete _impl_.account_;
  }
  _impl_.account_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AccountResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .iroha.protocol.Account account = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_account(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated string account_roles = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_account_roles();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            CHK_(::_pbi::VerifyUTF8(str, "iroha.protocol.AccountResponse.account_roles"));
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AccountResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:iroha.protocol.AccountResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .iroha.protocol.Account account = 1;
  if (this->_internal_has_account()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::account(this),
        _Internal::account(this).GetCachedSize(), target, stream);
  }

  // repeated string account_roles = 2;
  for (int i = 0, n = this->_internal_account_roles_size(); i < n; i++) {
    const auto& s = this->_internal_account_roles(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "iroha.protocol.AccountResponse.account_roles");
    target = stream->WriteString(2, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:iroha.protocol.AccountResponse)
  return target;
}

size_t AccountResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:iroha.protocol.AccountResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string account_roles = 2;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.account_roles_.size());
  for (int i = 0, n = _impl_.account_roles_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.account_roles_.Get(i));
  }

  // .iroha.protocol.Account account = 1;
  if (this->_internal_has_account()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.account_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AccountResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    AccountResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AccountResponse::GetClassData() const { return &_class_data_; }


void AccountResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<AccountResponse*>(&to_msg);
  auto& from = static_cast<const AccountResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:iroha.protocol.AccountResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.account_roles_.MergeFrom(from._impl_.account_roles_);
  if (from._internal_has_account()) {
    _this->_internal_mutable_account()->::iroha::protocol::Account::MergeFrom(
        from._internal_account());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AccountResponse::CopyFrom(const AccountResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:iroha.protocol.AccountResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AccountResponse::IsInitialized() const {
  return true;
}

void AccountResponse::InternalSwap(AccountResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.account_roles_.InternalSwap(&other->_impl_.account_roles_);
  swap(_impl_.account_, other->_impl_.account_);
}

::PROTOBUF_NAMESPACE_ID::Metadata AccountResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_qry_5fresponses_2eproto_getter, &descriptor_table_qry_5fresponses_2eproto_once,
      file_level_metadata_qry_5fresponses_2eproto[6]);
}

// ===================================================================

class AssetResponse::_Internal {
 public:
  static const ::iroha::protocol::Asset& asset(const AssetResponse* msg);
};

const ::iroha::protocol::Asset&
AssetResponse::_Internal::asset(const AssetResponse* msg) {
  return *msg->_impl_.asset_;
}
AssetResponse::AssetResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:iroha.protocol.AssetResponse)
}
AssetResponse::AssetResponse(const AssetResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  AssetResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.asset_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_asset()) {
    _this->_impl_.asset_ = new ::iroha::protocol::Asset(*from._impl_.asset_);
  }
  // @@protoc_insertion_point(copy_constructor:iroha.protocol.AssetResponse)
}

inline void AssetResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.asset_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

AssetResponse::~AssetResponse() {
  // @@protoc_insertion_point(destructor:iroha.protocol.AssetResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AssetResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.asset_;
}

void AssetResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AssetResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:iroha.protocol.AssetResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.asset_ != nullptr) {
    delete _impl_.asset_;
  }
  _impl_.asset_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AssetResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .iroha.protocol.Asset asset = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_asset(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AssetResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:iroha.protocol.AssetResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .iroha.protocol.Asset asset = 1;
  if (this->_internal_has_asset()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::asset(this),
        _Internal::asset(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:iroha.protocol.AssetResponse)
  return target;
}

size_t AssetResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:iroha.protocol.AssetResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .iroha.protocol.Asset asset = 1;
  if (this->_internal_has_asset()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.asset_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AssetResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    AssetResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AssetResponse::GetClassData() const { return &_class_data_; }


void AssetResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<AssetResponse*>(&to_msg);
  auto& from = static_cast<const AssetResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:iroha.protocol.AssetResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_asset()) {
    _this->_internal_mutable_asset()->::iroha::protocol::Asset::MergeFrom(
        from._internal_asset());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AssetResponse::CopyFrom(const AssetResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:iroha.protocol.AssetResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AssetResponse::IsInitialized() const {
  return true;
}

void AssetResponse::InternalSwap(AssetResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.asset_, other->_impl_.asset_);
}

::PROTOBUF_NAMESPACE_ID::Metadata AssetResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_qry_5fresponses_2eproto_getter, &descriptor_table_qry_5fresponses_2eproto_once,
      file_level_metadata_qry_5fresponses_2eproto[7]);
}

// ===================================================================

class RolesResponse::_Internal {
 public:
};

RolesResponse::RolesResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:iroha.protocol.RolesResponse)
}
RolesResponse::RolesResponse(const RolesResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  RolesResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.roles_){from._impl_.roles_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:iroha.protocol.RolesResponse)
}

inline void RolesResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.roles_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

RolesResponse::~RolesResponse() {
  // @@protoc_insertion_point(destructor:iroha.protocol.RolesResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RolesResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.roles_.~RepeatedPtrField();
}

void RolesResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void RolesResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:iroha.protocol.RolesResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.roles_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RolesResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated string roles = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_roles();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            CHK_(::_pbi::VerifyUTF8(str, "iroha.protocol.RolesResponse.roles"));
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RolesResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:iroha.protocol.RolesResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated string roles = 1;
  for (int i = 0, n = this->_internal_roles_size(); i < n; i++) {
    const auto& s = this->_internal_roles(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "iroha.protocol.RolesResponse.roles");
    target = stream->WriteString(1, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:iroha.protocol.RolesResponse)
  return target;
}

size_t RolesResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:iroha.protocol.RolesResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string roles = 1;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.roles_.size());
  for (int i = 0, n = _impl_.roles_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.roles_.Get(i));
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RolesResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    RolesResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RolesResponse::GetClassData() const { return &_class_data_; }


void RolesResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<RolesResponse*>(&to_msg);
  auto& from = static_cast<const RolesResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:iroha.protocol.RolesResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.roles_.MergeFrom(from._impl_.roles_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RolesResponse::CopyFrom(const RolesResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:iroha.protocol.RolesResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RolesResponse::IsInitialized() const {
  return true;
}

void RolesResponse::InternalSwap(RolesResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.roles_.InternalSwap(&other->_impl_.roles_);
}

::PROTOBUF_NAMESPACE_ID::Metadata RolesResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_qry_5fresponses_2eproto_getter, &descriptor_table_qry_5fresponses_2eproto_once,
      file_level_metadata_qry_5fresponses_2eproto[8]);
}

// ===================================================================

class RolePermissionsResponse::_Internal {
 public:
};

RolePermissionsResponse::RolePermissionsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:iroha.protocol.RolePermissionsResponse)
}
RolePermissionsResponse::RolePermissionsResponse(const RolePermissionsResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  RolePermissionsResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.permissions_){from._impl_.permissions_}
    , /*decltype(_impl_._permissions_cached_byte_size_)*/{0}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:iroha.protocol.RolePermissionsResponse)
}

inline void RolePermissionsResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.permissions_){arena}
    , /*decltype(_impl_._permissions_cached_byte_size_)*/{0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

RolePermissionsResponse::~RolePermissionsResponse() {
  // @@protoc_insertion_point(destructor:iroha.protocol.RolePermissionsResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RolePermissionsResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.permissions_.~RepeatedField();
}

void RolePermissionsResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void RolePermissionsResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:iroha.protocol.RolePermissionsResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.permissions_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RolePermissionsResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .iroha.protocol.RolePermission permissions = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedEnumParser(_internal_mutable_permissions(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 8) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_add_permissions(static_cast<::iroha::protocol::RolePermission>(val));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RolePermissionsResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:iroha.protocol.RolePermissionsResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .iroha.protocol.RolePermission permissions = 1;
  {
    int byte_size = _impl_._permissions_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteEnumPacked(
          1, _impl_.permissions_, byte_size, target);
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:iroha.protocol.RolePermissionsResponse)
  return target;
}

size_t RolePermissionsResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:iroha.protocol.RolePermissionsResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .iroha.protocol.RolePermission permissions = 1;
  {
    size_t data_size = 0;
    unsigned int count = static_cast<unsigned int>(this->_internal_permissions_size());for (unsigned int i = 0; i < count; i++) {
      data_size += ::_pbi::WireFormatLite::EnumSize(
        this->_internal_permissions(static_cast<int>(i)));
    }
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    int cached_size = ::_pbi::ToCachedSize(data_size);
    _impl_._permissions_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RolePermissionsResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    RolePermissionsResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RolePermissionsResponse::GetClassData() const { return &_class_data_; }


void RolePermissionsResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<RolePermissionsResponse*>(&to_msg);
  auto& from = static_cast<const RolePermissionsResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:iroha.protocol.RolePermissionsResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.permissions_.MergeFrom(from._impl_.permissions_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RolePermissionsResponse::CopyFrom(const RolePermissionsResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:iroha.protocol.RolePermissionsResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RolePermissionsResponse::IsInitialized() const {
  return true;
}

void RolePermissionsResponse::InternalSwap(RolePermissionsResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.permissions_.InternalSwap(&other->_impl_.permissions_);
}

::PROTOBUF_NAMESPACE_ID::Metadata RolePermissionsResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_qry_5fresponses_2eproto_getter, &descriptor_table_qry_5fresponses_2eproto_once,
      file_level_metadata_qry_5fresponses_2eproto[9]);
}

// ===================================================================

class ErrorResponse::_Internal {
 public:
};

ErrorResponse::ErrorResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:iroha.protocol.ErrorResponse)
}
ErrorResponse::ErrorResponse(const ErrorResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ErrorResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.message_){}
    , decltype(_impl_.reason_){}
    , decltype(_impl_.error_code_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.message_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.message_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_message().empty()) {
    _this->_impl_.message_.Set(from._internal_message(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.reason_, &from._impl_.reason_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.error_code_) -
    reinterpret_cast<char*>(&_impl_.reason_)) + sizeof(_impl_.error_code_));
  // @@protoc_insertion_point(copy_constructor:iroha.protocol.ErrorResponse)
}

inline void ErrorResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.message_){}
    , decltype(_impl_.reason_){0}
    , decltype(_impl_.error_code_){0u}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.message_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.message_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ErrorResponse::~ErrorResponse() {
  // @@protoc_insertion_point(destructor:iroha.protocol.ErrorResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ErrorResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.message_.Destroy();
}

void ErrorResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ErrorResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:iroha.protocol.ErrorResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.message_.ClearToEmpty();
  ::memset(&_impl_.reason_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.error_code_) -
      reinterpret_cast<char*>(&_impl_.reason_)) + sizeof(_impl_.error_code_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ErrorResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .iroha.protocol.ErrorResponse.Reason reason = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_reason(static_cast<::iroha::protocol::ErrorResponse_Reason>(val));
        } else
          goto handle_unusual;
        continue;
      // string message = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_message();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "iroha.protocol.ErrorResponse.message"));
        } else
          goto handle_unusual;
        continue;
      // uint32 error_code = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.error_code_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ErrorResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:iroha.protocol.ErrorResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .iroha.protocol.ErrorResponse.Reason reason = 1;
  if (this->_internal_reason() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_reason(), target);
  }

  // string message = 2;
  if (!this->_internal_message().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_message().data(), static_cast<int>(this->_internal_message().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "iroha.protocol.ErrorResponse.message");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_message(), target);
  }

  // uint32 error_code = 3;
  if (this->_internal_error_code() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_error_code(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:iroha.protocol.ErrorResponse)
  return target;
}

size_t ErrorResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:iroha.protocol.ErrorResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string message = 2;
  if (!this->_internal_message().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_message());
  }

  // .iroha.protocol.ErrorResponse.Reason reason = 1;
  if (this->_internal_reason() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_reason());
  }

  // uint32 error_code = 3;
  if (this->_internal_error_code() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_error_code());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ErrorResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ErrorResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ErrorResponse::GetClassData() const { return &_class_data_; }


void ErrorResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ErrorResponse*>(&to_msg);
  auto& from = static_cast<const ErrorResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:iroha.protocol.ErrorResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_message().empty()) {
    _this->_internal_set_message(from._internal_message());
  }
  if (from._internal_reason() != 0) {
    _this->_internal_set_reason(from._internal_reason());
  }
  if (from._internal_error_code() != 0) {
    _this->_internal_set_error_code(from._internal_error_code());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ErrorResponse::CopyFrom(const ErrorResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:iroha.protocol.ErrorResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ErrorResponse::IsInitialized() const {
  return true;
}

void ErrorResponse::InternalSwap(ErrorResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.message_, lhs_arena,
      &other->_impl_.message_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ErrorResponse, _impl_.error_code_)
      + sizeof(ErrorResponse::_impl_.error_code_)
      - PROTOBUF_FIELD_OFFSET(ErrorResponse, _impl_.reason_)>(
          reinterpret_cast<char*>(&_impl_.reason_),
          reinterpret_cast<char*>(&other->_impl_.reason_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ErrorResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_qry_5fresponses_2eproto_getter, &descriptor_table_qry_5fresponses_2eproto_once,
      file_level_metadata_qry_5fresponses_2eproto[10]);
}

// ===================================================================

class SignatoriesResponse::_Internal {
 public:
};

SignatoriesResponse::SignatoriesResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:iroha.protocol.SignatoriesResponse)
}
SignatoriesResponse::SignatoriesResponse(const SignatoriesResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SignatoriesResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.keys_){from._impl_.keys_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:iroha.protocol.SignatoriesResponse)
}

inline void SignatoriesResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.keys_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

SignatoriesResponse::~SignatoriesResponse() {
  // @@protoc_insertion_point(destructor:iroha.protocol.SignatoriesResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SignatoriesResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.keys_.~RepeatedPtrField();
}

void SignatoriesResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SignatoriesResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:iroha.protocol.SignatoriesResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.keys_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SignatoriesResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated string keys = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_keys();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            CHK_(::_pbi::VerifyUTF8(str, "iroha.protocol.SignatoriesResponse.keys"));
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SignatoriesResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:iroha.protocol.SignatoriesResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated string keys = 1;
  for (int i = 0, n = this->_internal_keys_size(); i < n; i++) {
    const auto& s = this->_internal_keys(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "iroha.protocol.SignatoriesResponse.keys");
    target = stream->WriteString(1, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:iroha.protocol.SignatoriesResponse)
  return target;
}

size_t SignatoriesResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:iroha.protocol.SignatoriesResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string keys = 1;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.keys_.size());
  for (int i = 0, n = _impl_.keys_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.keys_.Get(i));
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SignatoriesResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SignatoriesResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SignatoriesResponse::GetClassData() const { return &_class_data_; }


void SignatoriesResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SignatoriesResponse*>(&to_msg);
  auto& from = static_cast<const SignatoriesResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:iroha.protocol.SignatoriesResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.keys_.MergeFrom(from._impl_.keys_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SignatoriesResponse::CopyFrom(const SignatoriesResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:iroha.protocol.SignatoriesResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SignatoriesResponse::IsInitialized() const {
  return true;
}

void SignatoriesResponse::InternalSwap(SignatoriesResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.keys_.InternalSwap(&other->_impl_.keys_);
}

::PROTOBUF_NAMESPACE_ID::Metadata SignatoriesResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_qry_5fresponses_2eproto_getter, &descriptor_table_qry_5fresponses_2eproto_once,
      file_level_metadata_qry_5fresponses_2eproto[11]);
}

// ===================================================================

class TransactionsResponse::_Internal {
 public:
};

void TransactionsResponse::clear_transactions() {
  _impl_.transactions_.Clear();
}
TransactionsResponse::TransactionsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:iroha.protocol.TransactionsResponse)
}
TransactionsResponse::TransactionsResponse(const TransactionsResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TransactionsResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.transactions_){from._impl_.transactions_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:iroha.protocol.TransactionsResponse)
}

inline void TransactionsResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.transactions_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

TransactionsResponse::~TransactionsResponse() {
  // @@protoc_insertion_point(destructor:iroha.protocol.TransactionsResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TransactionsResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.transactions_.~RepeatedPtrField();
}

void TransactionsResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TransactionsResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:iroha.protocol.TransactionsResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.transactions_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TransactionsResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .iroha.protocol.Transaction transactions = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_transactions(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TransactionsResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:iroha.protocol.TransactionsResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .iroha.protocol.Transaction transactions = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_transactions_size()); i < n; i++) {
    const auto& repfield = this->_internal_transactions(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:iroha.protocol.TransactionsResponse)
  return target;
}

size_t TransactionsResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:iroha.protocol.TransactionsResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .iroha.protocol.Transaction transactions = 1;
  total_size += 1UL * this->_internal_transactions_size();
  for (const auto& msg : this->_impl_.transactions_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TransactionsResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TransactionsResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TransactionsResponse::GetClassData() const { return &_class_data_; }


void TransactionsResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TransactionsResponse*>(&to_msg);
  auto& from = static_cast<const TransactionsResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:iroha.protocol.TransactionsResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.transactions_.MergeFrom(from._impl_.transactions_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TransactionsResponse::CopyFrom(const TransactionsResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:iroha.protocol.TransactionsResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TransactionsResponse::IsInitialized() const {
  return true;
}

void TransactionsResponse::InternalSwap(TransactionsResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.transactions_.InternalSwap(&other->_impl_.transactions_);
}

::PROTOBUF_NAMESPACE_ID::Metadata TransactionsResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_qry_5fresponses_2eproto_getter, &descriptor_table_qry_5fresponses_2eproto_once,
      file_level_metadata_qry_5fresponses_2eproto[12]);
}

// ===================================================================

class TransactionsPageResponse::_Internal {
 public:
};

void TransactionsPageResponse::clear_transactions() {
  _impl_.transactions_.Clear();
}
TransactionsPageResponse::TransactionsPageResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:iroha.protocol.TransactionsPageResponse)
}
TransactionsPageResponse::TransactionsPageResponse(const TransactionsPageResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TransactionsPageResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.transactions_){from._impl_.transactions_}
    , decltype(_impl_.all_transactions_size_){}
    , decltype(_impl_.next_page_tag_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.all_transactions_size_ = from._impl_.all_transactions_size_;
  clear_has_next_page_tag();
  switch (from.next_page_tag_case()) {
    case kNextTxHash: {
      _this->_internal_set_next_tx_hash(from._internal_next_tx_hash());
      break;
    }
    case NEXT_PAGE_TAG_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:iroha.protocol.TransactionsPageResponse)
}

inline void TransactionsPageResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.transactions_){arena}
    , decltype(_impl_.all_transactions_size_){0u}
    , decltype(_impl_.next_page_tag_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_next_page_tag();
}

TransactionsPageResponse::~TransactionsPageResponse() {
  // @@protoc_insertion_point(destructor:iroha.protocol.TransactionsPageResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TransactionsPageResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.transactions_.~RepeatedPtrField();
  if (has_next_page_tag()) {
    clear_next_page_tag();
  }
}

void TransactionsPageResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TransactionsPageResponse::clear_next_page_tag() {
// @@protoc_insertion_point(one_of_clear_start:iroha.protocol.TransactionsPageResponse)
  switch (next_page_tag_case()) {
    case kNextTxHash: {
      _impl_.next_page_tag_.next_tx_hash_.Destroy();
      break;
    }
    case NEXT_PAGE_TAG_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = NEXT_PAGE_TAG_NOT_SET;
}


void TransactionsPageResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:iroha.protocol.TransactionsPageResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.transactions_.Clear();
  _impl_.all_transactions_size_ = 0u;
  clear_next_page_tag();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TransactionsPageResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .iroha.protocol.Transaction transactions = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_transactions(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // uint32 all_transactions_size = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.all_transactions_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string next_tx_hash = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_next_tx_hash();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "iroha.protocol.TransactionsPageResponse.next_tx_hash"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TransactionsPageResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:iroha.protocol.TransactionsPageResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .iroha.protocol.Transaction transactions = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_transactions_size()); i < n; i++) {
    const auto& repfield = this->_internal_transactions(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  // uint32 all_transactions_size = 2;
  if (this->_internal_all_transactions_size() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_all_transactions_size(), target);
  }

  // string next_tx_hash = 3;
  if (_internal_has_next_tx_hash()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_next_tx_hash().data(), static_cast<int>(this->_internal_next_tx_hash().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "iroha.protocol.TransactionsPageResponse.next_tx_hash");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_next_tx_hash(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:iroha.protocol.TransactionsPageResponse)
  return target;
}

size_t TransactionsPageResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:iroha.protocol.TransactionsPageResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .iroha.protocol.Transaction transactions = 1;
  total_size += 1UL * this->_internal_transactions_size();
  for (const auto& msg : this->_impl_.transactions_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // uint32 all_transactions_size = 2;
  if (this->_internal_all_transactions_size() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_all_transactions_size());
  }

  switch (next_page_tag_case()) {
    // string next_tx_hash = 3;
    case kNextTxHash: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_next_tx_hash());
      break;
    }
    case NEXT_PAGE_TAG_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TransactionsPageResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TransactionsPageResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TransactionsPageResponse::GetClassData() const { return &_class_data_; }


void TransactionsPageResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TransactionsPageResponse*>(&to_msg);
  auto& from = static_cast<const TransactionsPageResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:iroha.protocol.TransactionsPageResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.transactions_.MergeFrom(from._impl_.transactions_);
  if (from._internal_all_transactions_size() != 0) {
    _this->_internal_set_all_transactions_size(from._internal_all_transactions_size());
  }
  switch (from.next_page_tag_case()) {
    case kNextTxHash: {
      _this->_internal_set_next_tx_hash(from._internal_next_tx_hash());
      break;
    }
    case NEXT_PAGE_TAG_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TransactionsPageResponse::CopyFrom(const TransactionsPageResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:iroha.protocol.TransactionsPageResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TransactionsPageResponse::IsInitialized() const {
  return true;
}

void TransactionsPageResponse::InternalSwap(TransactionsPageResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.transactions_.InternalSwap(&other->_impl_.transactions_);
  swap(_impl_.all_transactions_size_, other->_impl_.all_transactions_size_);
  swap(_impl_.next_page_tag_, other->_impl_.next_page_tag_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata TransactionsPageResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_qry_5fresponses_2eproto_getter, &descriptor_table_qry_5fresponses_2eproto_once,
      file_level_metadata_qry_5fresponses_2eproto[13]);
}

// ===================================================================

class PendingTransactionsPageResponse_BatchInfo::_Internal {
 public:
};

PendingTransactionsPageResponse_BatchInfo::PendingTransactionsPageResponse_BatchInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:iroha.protocol.PendingTransactionsPageResponse.BatchInfo)
}
PendingTransactionsPageResponse_BatchInfo::PendingTransactionsPageResponse_BatchInfo(const PendingTransactionsPageResponse_BatchInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PendingTransactionsPageResponse_BatchInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.first_tx_hash_){}
    , decltype(_impl_.batch_size_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.first_tx_hash_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.first_tx_hash_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_first_tx_hash().empty()) {
    _this->_impl_.first_tx_hash_.Set(from._internal_first_tx_hash(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.batch_size_ = from._impl_.batch_size_;
  // @@protoc_insertion_point(copy_constructor:iroha.protocol.PendingTransactionsPageResponse.BatchInfo)
}

inline void PendingTransactionsPageResponse_BatchInfo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.first_tx_hash_){}
    , decltype(_impl_.batch_size_){0u}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.first_tx_hash_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.first_tx_hash_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

PendingTransactionsPageResponse_BatchInfo::~PendingTransactionsPageResponse_BatchInfo() {
  // @@protoc_insertion_point(destructor:iroha.protocol.PendingTransactionsPageResponse.BatchInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PendingTransactionsPageResponse_BatchInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.first_tx_hash_.Destroy();
}

void PendingTransactionsPageResponse_BatchInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PendingTransactionsPageResponse_BatchInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:iroha.protocol.PendingTransactionsPageResponse.BatchInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.first_tx_hash_.ClearToEmpty();
  _impl_.batch_size_ = 0u;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PendingTransactionsPageResponse_BatchInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string first_tx_hash = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_first_tx_hash();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "iroha.protocol.PendingTransactionsPageResponse.BatchInfo.first_tx_hash"));
        } else
          goto handle_unusual;
        continue;
      // uint32 batch_size = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.batch_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PendingTransactionsPageResponse_BatchInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:iroha.protocol.PendingTransactionsPageResponse.BatchInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string first_tx_hash = 1;
  if (!this->_internal_first_tx_hash().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_first_tx_hash().data(), static_cast<int>(this->_internal_first_tx_hash().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "iroha.protocol.PendingTransactionsPageResponse.BatchInfo.first_tx_hash");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_first_tx_hash(), target);
  }

  // uint32 batch_size = 2;
  if (this->_internal_batch_size() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_batch_size(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:iroha.protocol.PendingTransactionsPageResponse.BatchInfo)
  return target;
}

size_t PendingTransactionsPageResponse_BatchInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:iroha.protocol.PendingTransactionsPageResponse.BatchInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string first_tx_hash = 1;
  if (!this->_internal_first_tx_hash().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_first_tx_hash());
  }

  // uint32 batch_size = 2;
  if (this->_internal_batch_size() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_batch_size());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PendingTransactionsPageResponse_BatchInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PendingTransactionsPageResponse_BatchInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PendingTransactionsPageResponse_BatchInfo::GetClassData() const { return &_class_data_; }


void PendingTransactionsPageResponse_BatchInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PendingTransactionsPageResponse_BatchInfo*>(&to_msg);
  auto& from = static_cast<const PendingTransactionsPageResponse_BatchInfo&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:iroha.protocol.PendingTransactionsPageResponse.BatchInfo)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_first_tx_hash().empty()) {
    _this->_internal_set_first_tx_hash(from._internal_first_tx_hash());
  }
  if (from._internal_batch_size() != 0) {
    _this->_internal_set_batch_size(from._internal_batch_size());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PendingTransactionsPageResponse_BatchInfo::CopyFrom(const PendingTransactionsPageResponse_BatchInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:iroha.protocol.PendingTransactionsPageResponse.BatchInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PendingTransactionsPageResponse_BatchInfo::IsInitialized() const {
  return true;
}

void PendingTransactionsPageResponse_BatchInfo::InternalSwap(PendingTransactionsPageResponse_BatchInfo* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.first_tx_hash_, lhs_arena,
      &other->_impl_.first_tx_hash_, rhs_arena
  );
  swap(_impl_.batch_size_, other->_impl_.batch_size_);
}

::PROTOBUF_NAMESPACE_ID::Metadata PendingTransactionsPageResponse_BatchInfo::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_qry_5fresponses_2eproto_getter, &descriptor_table_qry_5fresponses_2eproto_once,
      file_level_metadata_qry_5fresponses_2eproto[14]);
}

// ===================================================================

class PendingTransactionsPageResponse::_Internal {
 public:
  static const ::iroha::protocol::PendingTransactionsPageResponse_BatchInfo& next_batch_info(const PendingTransactionsPageResponse* msg);
};

const ::iroha::protocol::PendingTransactionsPageResponse_BatchInfo&
PendingTransactionsPageResponse::_Internal::next_batch_info(const PendingTransactionsPageResponse* msg) {
  return *msg->_impl_.next_batch_info_;
}
void PendingTransactionsPageResponse::clear_transactions() {
  _impl_.transactions_.Clear();
}
PendingTransactionsPageResponse::PendingTransactionsPageResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:iroha.protocol.PendingTransactionsPageResponse)
}
PendingTransactionsPageResponse::PendingTransactionsPageResponse(const PendingTransactionsPageResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PendingTransactionsPageResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.transactions_){from._impl_.transactions_}
    , decltype(_impl_.next_batch_info_){nullptr}
    , decltype(_impl_.all_transactions_size_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_next_batch_info()) {
    _this->_impl_.next_batch_info_ = new ::iroha::protocol::PendingTransactionsPageResponse_BatchInfo(*from._impl_.next_batch_info_);
  }
  _this->_impl_.all_transactions_size_ = from._impl_.all_transactions_size_;
  // @@protoc_insertion_point(copy_constructor:iroha.protocol.PendingTransactionsPageResponse)
}

inline void PendingTransactionsPageResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.transactions_){arena}
    , decltype(_impl_.next_batch_info_){nullptr}
    , decltype(_impl_.all_transactions_size_){0u}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

PendingTransactionsPageResponse::~PendingTransactionsPageResponse() {
  // @@protoc_insertion_point(destructor:iroha.protocol.PendingTransactionsPageResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PendingTransactionsPageResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.transactions_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.next_batch_info_;
}

void PendingTransactionsPageResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PendingTransactionsPageResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:iroha.protocol.PendingTransactionsPageResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.transactions_.Clear();
  if (GetArenaForAllocation() == nullptr && _impl_.next_batch_info_ != nullptr) {
    delete _impl_.next_batch_info_;
  }
  _impl_.next_batch_info_ = nullptr;
  _impl_.all_transactions_size_ = 0u;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PendingTransactionsPageResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .iroha.protocol.Transaction transactions = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_transactions(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // uint32 all_transactions_size = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.all_transactions_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .iroha.protocol.PendingTransactionsPageResponse.BatchInfo next_batch_info = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_next_batch_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PendingTransactionsPageResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:iroha.protocol.PendingTransactionsPageResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .iroha.protocol.Transaction transactions = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_transactions_size()); i < n; i++) {
    const auto& repfield = this->_internal_transactions(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  // uint32 all_transactions_size = 2;
  if (this->_internal_all_transactions_size() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_all_transactions_size(), target);
  }

  // .iroha.protocol.PendingTransactionsPageResponse.BatchInfo next_batch_info = 3;
  if (this->_internal_has_next_batch_info()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::next_batch_info(this),
        _Internal::next_batch_info(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:iroha.protocol.PendingTransactionsPageResponse)
  return target;
}

size_t PendingTransactionsPageResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:iroha.protocol.PendingTransactionsPageResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .iroha.protocol.Transaction transactions = 1;
  total_size += 1UL * this->_internal_transactions_size();
  for (const auto& msg : this->_impl_.transactions_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // .iroha.protocol.PendingTransactionsPageResponse.BatchInfo next_batch_info = 3;
  if (this->_internal_has_next_batch_info()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.next_batch_info_);
  }

  // uint32 all_transactions_size = 2;
  if (this->_internal_all_transactions_size() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_all_transactions_size());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PendingTransactionsPageResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PendingTransactionsPageResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PendingTransactionsPageResponse::GetClassData() const { return &_class_data_; }


void PendingTransactionsPageResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PendingTransactionsPageResponse*>(&to_msg);
  auto& from = static_cast<const PendingTransactionsPageResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:iroha.protocol.PendingTransactionsPageResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.transactions_.MergeFrom(from._impl_.transactions_);
  if (from._internal_has_next_batch_info()) {
    _this->_internal_mutable_next_batch_info()->::iroha::protocol::PendingTransactionsPageResponse_BatchInfo::MergeFrom(
        from._internal_next_batch_info());
  }
  if (from._internal_all_transactions_size() != 0) {
    _this->_internal_set_all_transactions_size(from._internal_all_transactions_size());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PendingTransactionsPageResponse::CopyFrom(const PendingTransactionsPageResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:iroha.protocol.PendingTransactionsPageResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PendingTransactionsPageResponse::IsInitialized() const {
  return true;
}

void PendingTransactionsPageResponse::InternalSwap(PendingTransactionsPageResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.transactions_.InternalSwap(&other->_impl_.transactions_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PendingTransactionsPageResponse, _impl_.all_transactions_size_)
      + sizeof(PendingTransactionsPageResponse::_impl_.all_transactions_size_)
      - PROTOBUF_FIELD_OFFSET(PendingTransactionsPageResponse, _impl_.next_batch_info_)>(
          reinterpret_cast<char*>(&_impl_.next_batch_info_),
          reinterpret_cast<char*>(&other->_impl_.next_batch_info_));
}

::PROTOBUF_NAMESPACE_ID::Metadata PendingTransactionsPageResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_qry_5fresponses_2eproto_getter, &descriptor_table_qry_5fresponses_2eproto_once,
      file_level_metadata_qry_5fresponses_2eproto[15]);
}

// ===================================================================

class PeersResponse::_Internal {
 public:
};

void PeersResponse::clear_peers() {
  _impl_.peers_.Clear();
}
PeersResponse::PeersResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:iroha.protocol.PeersResponse)
}
PeersResponse::PeersResponse(const PeersResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PeersResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.peers_){from._impl_.peers_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:iroha.protocol.PeersResponse)
}

inline void PeersResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.peers_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

PeersResponse::~PeersResponse() {
  // @@protoc_insertion_point(destructor:iroha.protocol.PeersResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PeersResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.peers_.~RepeatedPtrField();
}

void PeersResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PeersResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:iroha.protocol.PeersResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.peers_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PeersResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .iroha.protocol.Peer peers = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_peers(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PeersResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:iroha.protocol.PeersResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .iroha.protocol.Peer peers = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_peers_size()); i < n; i++) {
    const auto& repfield = this->_internal_peers(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:iroha.protocol.PeersResponse)
  return target;
}

size_t PeersResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:iroha.protocol.PeersResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .iroha.protocol.Peer peers = 1;
  total_size += 1UL * this->_internal_peers_size();
  for (const auto& msg : this->_impl_.peers_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PeersResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PeersResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PeersResponse::GetClassData() const { return &_class_data_; }


void PeersResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PeersResponse*>(&to_msg);
  auto& from = static_cast<const PeersResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:iroha.protocol.PeersResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.peers_.MergeFrom(from._impl_.peers_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PeersResponse::CopyFrom(const PeersResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:iroha.protocol.PeersResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PeersResponse::IsInitialized() const {
  return true;
}

void PeersResponse::InternalSwap(PeersResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.peers_.InternalSwap(&other->_impl_.peers_);
}

::PROTOBUF_NAMESPACE_ID::Metadata PeersResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_qry_5fresponses_2eproto_getter, &descriptor_table_qry_5fresponses_2eproto_once,
      file_level_metadata_qry_5fresponses_2eproto[16]);
}

// ===================================================================

class EngineReceiptsResponse::_Internal {
 public:
};

void EngineReceiptsResponse::clear_engine_receipts() {
  _impl_.engine_receipts_.Clear();
}
EngineReceiptsResponse::EngineReceiptsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:iroha.protocol.EngineReceiptsResponse)
}
EngineReceiptsResponse::EngineReceiptsResponse(const EngineReceiptsResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  EngineReceiptsResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.engine_receipts_){from._impl_.engine_receipts_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:iroha.protocol.EngineReceiptsResponse)
}

inline void EngineReceiptsResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.engine_receipts_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

EngineReceiptsResponse::~EngineReceiptsResponse() {
  // @@protoc_insertion_point(destructor:iroha.protocol.EngineReceiptsResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void EngineReceiptsResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.engine_receipts_.~RepeatedPtrField();
}

void EngineReceiptsResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void EngineReceiptsResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:iroha.protocol.EngineReceiptsResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.engine_receipts_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* EngineReceiptsResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .iroha.protocol.EngineReceipt engine_receipts = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_engine_receipts(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* EngineReceiptsResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:iroha.protocol.EngineReceiptsResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .iroha.protocol.EngineReceipt engine_receipts = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_engine_receipts_size()); i < n; i++) {
    const auto& repfield = this->_internal_engine_receipts(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:iroha.protocol.EngineReceiptsResponse)
  return target;
}

size_t EngineReceiptsResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:iroha.protocol.EngineReceiptsResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .iroha.protocol.EngineReceipt engine_receipts = 1;
  total_size += 1UL * this->_internal_engine_receipts_size();
  for (const auto& msg : this->_impl_.engine_receipts_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData EngineReceiptsResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    EngineReceiptsResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*EngineReceiptsResponse::GetClassData() const { return &_class_data_; }


void EngineReceiptsResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<EngineReceiptsResponse*>(&to_msg);
  auto& from = static_cast<const EngineReceiptsResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:iroha.protocol.EngineReceiptsResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.engine_receipts_.MergeFrom(from._impl_.engine_receipts_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void EngineReceiptsResponse::CopyFrom(const EngineReceiptsResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:iroha.protocol.EngineReceiptsResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EngineReceiptsResponse::IsInitialized() const {
  return true;
}

void EngineReceiptsResponse::InternalSwap(EngineReceiptsResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.engine_receipts_.InternalSwap(&other->_impl_.engine_receipts_);
}

::PROTOBUF_NAMESPACE_ID::Metadata EngineReceiptsResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_qry_5fresponses_2eproto_getter, &descriptor_table_qry_5fresponses_2eproto_once,
      file_level_metadata_qry_5fresponses_2eproto[17]);
}

// ===================================================================

class QueryResponse::_Internal {
 public:
  static const ::iroha::protocol::AccountAssetResponse& account_assets_response(const QueryResponse* msg);
  static const ::iroha::protocol::AccountDetailResponse& account_detail_response(const QueryResponse* msg);
  static const ::iroha::protocol::AccountResponse& account_response(const QueryResponse* msg);
  static const ::iroha::protocol::ErrorResponse& error_response(const QueryResponse* msg);
  static const ::iroha::protocol::SignatoriesResponse& signatories_response(const QueryResponse* msg);
  static const ::iroha::protocol::TransactionsResponse& transactions_response(const QueryResponse* msg);
  static const ::iroha::protocol::AssetResponse& asset_response(const QueryResponse* msg);
  static const ::iroha::protocol::RolesResponse& roles_response(const QueryResponse* msg);
  static const ::iroha::protocol::RolePermissionsResponse& role_permissions_response(const QueryResponse* msg);
  static const ::iroha::protocol::TransactionsPageResponse& transactions_page_response(const QueryResponse* msg);
  static const ::iroha::protocol::PendingTransactionsPageResponse& pending_transactions_page_response(const QueryResponse* msg);
  static const ::iroha::protocol::BlockResponse& block_response(const QueryResponse* msg);
  static const ::iroha::protocol::PeersResponse& peers_response(const QueryResponse* msg);
  static const ::iroha::protocol::EngineReceiptsResponse& engine_receipts_response(const QueryResponse* msg);
};

const ::iroha::protocol::AccountAssetResponse&
QueryResponse::_Internal::account_assets_response(const QueryResponse* msg) {
  return *msg->_impl_.response_.account_assets_response_;
}
const ::iroha::protocol::AccountDetailResponse&
QueryResponse::_Internal::account_detail_response(const QueryResponse* msg) {
  return *msg->_impl_.response_.account_detail_response_;
}
const ::iroha::protocol::AccountResponse&
QueryResponse::_Internal::account_response(const QueryResponse* msg) {
  return *msg->_impl_.response_.account_response_;
}
const ::iroha::protocol::ErrorResponse&
QueryResponse::_Internal::error_response(const QueryResponse* msg) {
  return *msg->_impl_.response_.error_response_;
}
const ::iroha::protocol::SignatoriesResponse&
QueryResponse::_Internal::signatories_response(const QueryResponse* msg) {
  return *msg->_impl_.response_.signatories_response_;
}
const ::iroha::protocol::TransactionsResponse&
QueryResponse::_Internal::transactions_response(const QueryResponse* msg) {
  return *msg->_impl_.response_.transactions_response_;
}
const ::iroha::protocol::AssetResponse&
QueryResponse::_Internal::asset_response(const QueryResponse* msg) {
  return *msg->_impl_.response_.asset_response_;
}
const ::iroha::protocol::RolesResponse&
QueryResponse::_Internal::roles_response(const QueryResponse* msg) {
  return *msg->_impl_.response_.roles_response_;
}
const ::iroha::protocol::RolePermissionsResponse&
QueryResponse::_Internal::role_permissions_response(const QueryResponse* msg) {
  return *msg->_impl_.response_.role_permissions_response_;
}
const ::iroha::protocol::TransactionsPageResponse&
QueryResponse::_Internal::transactions_page_response(const QueryResponse* msg) {
  return *msg->_impl_.response_.transactions_page_response_;
}
const ::iroha::protocol::PendingTransactionsPageResponse&
QueryResponse::_Internal::pending_transactions_page_response(const QueryResponse* msg) {
  return *msg->_impl_.response_.pending_transactions_page_response_;
}
const ::iroha::protocol::BlockResponse&
QueryResponse::_Internal::block_response(const QueryResponse* msg) {
  return *msg->_impl_.response_.block_response_;
}
const ::iroha::protocol::PeersResponse&
QueryResponse::_Internal::peers_response(const QueryResponse* msg) {
  return *msg->_impl_.response_.peers_response_;
}
const ::iroha::protocol::EngineReceiptsResponse&
QueryResponse::_Internal::engine_receipts_response(const QueryResponse* msg) {
  return *msg->_impl_.response_.engine_receipts_response_;
}
void QueryResponse::set_allocated_account_assets_response(::iroha::protocol::AccountAssetResponse* account_assets_response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_response();
  if (account_assets_response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(account_assets_response);
    if (message_arena != submessage_arena) {
      account_assets_response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, account_assets_response, submessage_arena);
    }
    set_has_account_assets_response();
    _impl_.response_.account_assets_response_ = account_assets_response;
  }
  // @@protoc_insertion_point(field_set_allocated:iroha.protocol.QueryResponse.account_assets_response)
}
void QueryResponse::set_allocated_account_detail_response(::iroha::protocol::AccountDetailResponse* account_detail_response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_response();
  if (account_detail_response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(account_detail_response);
    if (message_arena != submessage_arena) {
      account_detail_response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, account_detail_response, submessage_arena);
    }
    set_has_account_detail_response();
    _impl_.response_.account_detail_response_ = account_detail_response;
  }
  // @@protoc_insertion_point(field_set_allocated:iroha.protocol.QueryResponse.account_detail_response)
}
void QueryResponse::set_allocated_account_response(::iroha::protocol::AccountResponse* account_response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_response();
  if (account_response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(account_response);
    if (message_arena != submessage_arena) {
      account_response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, account_response, submessage_arena);
    }
    set_has_account_response();
    _impl_.response_.account_response_ = account_response;
  }
  // @@protoc_insertion_point(field_set_allocated:iroha.protocol.QueryResponse.account_response)
}
void QueryResponse::set_allocated_error_response(::iroha::protocol::ErrorResponse* error_response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_response();
  if (error_response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(error_response);
    if (message_arena != submessage_arena) {
      error_response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, error_response, submessage_arena);
    }
    set_has_error_response();
    _impl_.response_.error_response_ = error_response;
  }
  // @@protoc_insertion_point(field_set_allocated:iroha.protocol.QueryResponse.error_response)
}
void QueryResponse::set_allocated_signatories_response(::iroha::protocol::SignatoriesResponse* signatories_response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_response();
  if (signatories_response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(signatories_response);
    if (message_arena != submessage_arena) {
      signatories_response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, signatories_response, submessage_arena);
    }
    set_has_signatories_response();
    _impl_.response_.signatories_response_ = signatories_response;
  }
  // @@protoc_insertion_point(field_set_allocated:iroha.protocol.QueryResponse.signatories_response)
}
void QueryResponse::set_allocated_transactions_response(::iroha::protocol::TransactionsResponse* transactions_response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_response();
  if (transactions_response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(transactions_response);
    if (message_arena != submessage_arena) {
      transactions_response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, transactions_response, submessage_arena);
    }
    set_has_transactions_response();
    _impl_.response_.transactions_response_ = transactions_response;
  }
  // @@protoc_insertion_point(field_set_allocated:iroha.protocol.QueryResponse.transactions_response)
}
void QueryResponse::set_allocated_asset_response(::iroha::protocol::AssetResponse* asset_response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_response();
  if (asset_response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(asset_response);
    if (message_arena != submessage_arena) {
      asset_response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, asset_response, submessage_arena);
    }
    set_has_asset_response();
    _impl_.response_.asset_response_ = asset_response;
  }
  // @@protoc_insertion_point(field_set_allocated:iroha.protocol.QueryResponse.asset_response)
}
void QueryResponse::set_allocated_roles_response(::iroha::protocol::RolesResponse* roles_response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_response();
  if (roles_response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(roles_response);
    if (message_arena != submessage_arena) {
      roles_response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, roles_response, submessage_arena);
    }
    set_has_roles_response();
    _impl_.response_.roles_response_ = roles_response;
  }
  // @@protoc_insertion_point(field_set_allocated:iroha.protocol.QueryResponse.roles_response)
}
void QueryResponse::set_allocated_role_permissions_response(::iroha::protocol::RolePermissionsResponse* role_permissions_response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_response();
  if (role_permissions_response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(role_permissions_response);
    if (message_arena != submessage_arena) {
      role_permissions_response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, role_permissions_response, submessage_arena);
    }
    set_has_role_permissions_response();
    _impl_.response_.role_permissions_response_ = role_permissions_response;
  }
  // @@protoc_insertion_point(field_set_allocated:iroha.protocol.QueryResponse.role_permissions_response)
}
void QueryResponse::set_allocated_transactions_page_response(::iroha::protocol::TransactionsPageResponse* transactions_page_response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_response();
  if (transactions_page_response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(transactions_page_response);
    if (message_arena != submessage_arena) {
      transactions_page_response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, transactions_page_response, submessage_arena);
    }
    set_has_transactions_page_response();
    _impl_.response_.transactions_page_response_ = transactions_page_response;
  }
  // @@protoc_insertion_point(field_set_allocated:iroha.protocol.QueryResponse.transactions_page_response)
}
void QueryResponse::set_allocated_pending_transactions_page_response(::iroha::protocol::PendingTransactionsPageResponse* pending_transactions_page_response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_response();
  if (pending_transactions_page_response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(pending_transactions_page_response);
    if (message_arena != submessage_arena) {
      pending_transactions_page_response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pending_transactions_page_response, submessage_arena);
    }
    set_has_pending_transactions_page_response();
    _impl_.response_.pending_transactions_page_response_ = pending_transactions_page_response;
  }
  // @@protoc_insertion_point(field_set_allocated:iroha.protocol.QueryResponse.pending_transactions_page_response)
}
void QueryResponse::set_allocated_block_response(::iroha::protocol::BlockResponse* block_response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_response();
  if (block_response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(block_response);
    if (message_arena != submessage_arena) {
      block_response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, block_response, submessage_arena);
    }
    set_has_block_response();
    _impl_.response_.block_response_ = block_response;
  }
  // @@protoc_insertion_point(field_set_allocated:iroha.protocol.QueryResponse.block_response)
}
void QueryResponse::set_allocated_peers_response(::iroha::protocol::PeersResponse* peers_response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_response();
  if (peers_response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(peers_response);
    if (message_arena != submessage_arena) {
      peers_response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, peers_response, submessage_arena);
    }
    set_has_peers_response();
    _impl_.response_.peers_response_ = peers_response;
  }
  // @@protoc_insertion_point(field_set_allocated:iroha.protocol.QueryResponse.peers_response)
}
void QueryResponse::set_allocated_engine_receipts_response(::iroha::protocol::EngineReceiptsResponse* engine_receipts_response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_response();
  if (engine_receipts_response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(engine_receipts_response);
    if (message_arena != submessage_arena) {
      engine_receipts_response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, engine_receipts_response, submessage_arena);
    }
    set_has_engine_receipts_response();
    _impl_.response_.engine_receipts_response_ = engine_receipts_response;
  }
  // @@protoc_insertion_point(field_set_allocated:iroha.protocol.QueryResponse.engine_receipts_response)
}
QueryResponse::QueryResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:iroha.protocol.QueryResponse)
}
QueryResponse::QueryResponse(const QueryResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  QueryResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.query_hash_){}
    , decltype(_impl_.response_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.query_hash_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.query_hash_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_query_hash().empty()) {
    _this->_impl_.query_hash_.Set(from._internal_query_hash(), 
      _this->GetArenaForAllocation());
  }
  clear_has_response();
  switch (from.response_case()) {
    case kAccountAssetsResponse: {
      _this->_internal_mutable_account_assets_response()->::iroha::protocol::AccountAssetResponse::MergeFrom(
          from._internal_account_assets_response());
      break;
    }
    case kAccountDetailResponse: {
      _this->_internal_mutable_account_detail_response()->::iroha::protocol::AccountDetailResponse::MergeFrom(
          from._internal_account_detail_response());
      break;
    }
    case kAccountResponse: {
      _this->_internal_mutable_account_response()->::iroha::protocol::AccountResponse::MergeFrom(
          from._internal_account_response());
      break;
    }
    case kErrorResponse: {
      _this->_internal_mutable_error_response()->::iroha::protocol::ErrorResponse::MergeFrom(
          from._internal_error_response());
      break;
    }
    case kSignatoriesResponse: {
      _this->_internal_mutable_signatories_response()->::iroha::protocol::SignatoriesResponse::MergeFrom(
          from._internal_signatories_response());
      break;
    }
    case kTransactionsResponse: {
      _this->_internal_mutable_transactions_response()->::iroha::protocol::TransactionsResponse::MergeFrom(
          from._internal_transactions_response());
      break;
    }
    case kAssetResponse: {
      _this->_internal_mutable_asset_response()->::iroha::protocol::AssetResponse::MergeFrom(
          from._internal_asset_response());
      break;
    }
    case kRolesResponse: {
      _this->_internal_mutable_roles_response()->::iroha::protocol::RolesResponse::MergeFrom(
          from._internal_roles_response());
      break;
    }
    case kRolePermissionsResponse: {
      _this->_internal_mutable_role_permissions_response()->::iroha::protocol::RolePermissionsResponse::MergeFrom(
          from._internal_role_permissions_response());
      break;
    }
    case kTransactionsPageResponse: {
      _this->_internal_mutable_transactions_page_response()->::iroha::protocol::TransactionsPageResponse::MergeFrom(
          from._internal_transactions_page_response());
      break;
    }
    case kPendingTransactionsPageResponse: {
      _this->_internal_mutable_pending_transactions_page_response()->::iroha::protocol::PendingTransactionsPageResponse::MergeFrom(
          from._internal_pending_transactions_page_response());
      break;
    }
    case kBlockResponse: {
      _this->_internal_mutable_block_response()->::iroha::protocol::BlockResponse::MergeFrom(
          from._internal_block_response());
      break;
    }
    case kPeersResponse: {
      _this->_internal_mutable_peers_response()->::iroha::protocol::PeersResponse::MergeFrom(
          from._internal_peers_response());
      break;
    }
    case kEngineReceiptsResponse: {
      _this->_internal_mutable_engine_receipts_response()->::iroha::protocol::EngineReceiptsResponse::MergeFrom(
          from._internal_engine_receipts_response());
      break;
    }
    case RESPONSE_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:iroha.protocol.QueryResponse)
}

inline void QueryResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.query_hash_){}
    , decltype(_impl_.response_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  _impl_.query_hash_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.query_hash_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  clear_has_response();
}

QueryResponse::~QueryResponse() {
  // @@protoc_insertion_point(destructor:iroha.protocol.QueryResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void QueryResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.query_hash_.Destroy();
  if (has_response()) {
    clear_response();
  }
}

void QueryResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void QueryResponse::clear_response() {
// @@protoc_insertion_point(one_of_clear_start:iroha.protocol.QueryResponse)
  switch (response_case()) {
    case kAccountAssetsResponse: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.response_.account_assets_response_;
      }
      break;
    }
    case kAccountDetailResponse: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.response_.account_detail_response_;
      }
      break;
    }
    case kAccountResponse: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.response_.account_response_;
      }
      break;
    }
    case kErrorResponse: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.response_.error_response_;
      }
      break;
    }
    case kSignatoriesResponse: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.response_.signatories_response_;
      }
      break;
    }
    case kTransactionsResponse: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.response_.transactions_response_;
      }
      break;
    }
    case kAssetResponse: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.response_.asset_response_;
      }
      break;
    }
    case kRolesResponse: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.response_.roles_response_;
      }
      break;
    }
    case kRolePermissionsResponse: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.response_.role_permissions_response_;
      }
      break;
    }
    case kTransactionsPageResponse: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.response_.transactions_page_response_;
      }
      break;
    }
    case kPendingTransactionsPageResponse: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.response_.pending_transactions_page_response_;
      }
      break;
    }
    case kBlockResponse: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.response_.block_response_;
      }
      break;
    }
    case kPeersResponse: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.response_.peers_response_;
      }
      break;
    }
    case kEngineReceiptsResponse: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.response_.engine_receipts_response_;
      }
      break;
    }
    case RESPONSE_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = RESPONSE_NOT_SET;
}


void QueryResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:iroha.protocol.QueryResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.query_hash_.ClearToEmpty();
  clear_response();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* QueryResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .iroha.protocol.AccountAssetResponse account_assets_response = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_account_assets_response(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .iroha.protocol.AccountDetailResponse account_detail_response = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_account_detail_response(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .iroha.protocol.AccountResponse account_response = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_account_response(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .iroha.protocol.ErrorResponse error_response = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_error_response(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .iroha.protocol.SignatoriesResponse signatories_response = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_signatories_response(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .iroha.protocol.TransactionsResponse transactions_response = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_transactions_response(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .iroha.protocol.AssetResponse asset_response = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_asset_response(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .iroha.protocol.RolesResponse roles_response = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_roles_response(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .iroha.protocol.RolePermissionsResponse role_permissions_response = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_role_permissions_response(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string query_hash = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          auto str = _internal_mutable_query_hash();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "iroha.protocol.QueryResponse.query_hash"));
        } else
          goto handle_unusual;
        continue;
      // .iroha.protocol.TransactionsPageResponse transactions_page_response = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_transactions_page_response(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .iroha.protocol.BlockResponse block_response = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          ptr = ctx->ParseMessage(_internal_mutable_block_response(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .iroha.protocol.PendingTransactionsPageResponse pending_transactions_page_response = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 106)) {
          ptr = ctx->ParseMessage(_internal_mutable_pending_transactions_page_response(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .iroha.protocol.PeersResponse peers_response = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 114)) {
          ptr = ctx->ParseMessage(_internal_mutable_peers_response(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .iroha.protocol.EngineReceiptsResponse engine_receipts_response = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 122)) {
          ptr = ctx->ParseMessage(_internal_mutable_engine_receipts_response(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* QueryResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:iroha.protocol.QueryResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .iroha.protocol.AccountAssetResponse account_assets_response = 1;
  if (_internal_has_account_assets_response()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::account_assets_response(this),
        _Internal::account_assets_response(this).GetCachedSize(), target, stream);
  }

  // .iroha.protocol.AccountDetailResponse account_detail_response = 2;
  if (_internal_has_account_detail_response()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::account_detail_response(this),
        _Internal::account_detail_response(this).GetCachedSize(), target, stream);
  }

  // .iroha.protocol.AccountResponse account_response = 3;
  if (_internal_has_account_response()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::account_response(this),
        _Internal::account_response(this).GetCachedSize(), target, stream);
  }

  // .iroha.protocol.ErrorResponse error_response = 4;
  if (_internal_has_error_response()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::error_response(this),
        _Internal::error_response(this).GetCachedSize(), target, stream);
  }

  // .iroha.protocol.SignatoriesResponse signatories_response = 5;
  if (_internal_has_signatories_response()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::signatories_response(this),
        _Internal::signatories_response(this).GetCachedSize(), target, stream);
  }

  // .iroha.protocol.TransactionsResponse transactions_response = 6;
  if (_internal_has_transactions_response()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::transactions_response(this),
        _Internal::transactions_response(this).GetCachedSize(), target, stream);
  }

  // .iroha.protocol.AssetResponse asset_response = 7;
  if (_internal_has_asset_response()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, _Internal::asset_response(this),
        _Internal::asset_response(this).GetCachedSize(), target, stream);
  }

  // .iroha.protocol.RolesResponse roles_response = 8;
  if (_internal_has_roles_response()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(8, _Internal::roles_response(this),
        _Internal::roles_response(this).GetCachedSize(), target, stream);
  }

  // .iroha.protocol.RolePermissionsResponse role_permissions_response = 9;
  if (_internal_has_role_permissions_response()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(9, _Internal::role_permissions_response(this),
        _Internal::role_permissions_response(this).GetCachedSize(), target, stream);
  }

  // string query_hash = 10;
  if (!this->_internal_query_hash().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_query_hash().data(), static_cast<int>(this->_internal_query_hash().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "iroha.protocol.QueryResponse.query_hash");
    target = stream->WriteStringMaybeAliased(
        10, this->_internal_query_hash(), target);
  }

  // .iroha.protocol.TransactionsPageResponse transactions_page_response = 11;
  if (_internal_has_transactions_page_response()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(11, _Internal::transactions_page_response(this),
        _Internal::transactions_page_response(this).GetCachedSize(), target, stream);
  }

  // .iroha.protocol.BlockResponse block_response = 12;
  if (_internal_has_block_response()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(12, _Internal::block_response(this),
        _Internal::block_response(this).GetCachedSize(), target, stream);
  }

  // .iroha.protocol.PendingTransactionsPageResponse pending_transactions_page_response = 13;
  if (_internal_has_pending_transactions_page_response()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(13, _Internal::pending_transactions_page_response(this),
        _Internal::pending_transactions_page_response(this).GetCachedSize(), target, stream);
  }

  // .iroha.protocol.PeersResponse peers_response = 14;
  if (_internal_has_peers_response()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(14, _Internal::peers_response(this),
        _Internal::peers_response(this).GetCachedSize(), target, stream);
  }

  // .iroha.protocol.EngineReceiptsResponse engine_receipts_response = 15;
  if (_internal_has_engine_receipts_response()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(15, _Internal::engine_receipts_response(this),
        _Internal::engine_receipts_response(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:iroha.protocol.QueryResponse)
  return target;
}

size_t QueryResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:iroha.protocol.QueryResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string query_hash = 10;
  if (!this->_internal_query_hash().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_query_hash());
  }

  switch (response_case()) {
    // .iroha.protocol.AccountAssetResponse account_assets_response = 1;
    case kAccountAssetsResponse: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.response_.account_assets_response_);
      break;
    }
    // .iroha.protocol.AccountDetailResponse account_detail_response = 2;
    case kAccountDetailResponse: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.response_.account_detail_response_);
      break;
    }
    // .iroha.protocol.AccountResponse account_response = 3;
    case kAccountResponse: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.response_.account_response_);
      break;
    }
    // .iroha.protocol.ErrorResponse error_response = 4;
    case kErrorResponse: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.response_.error_response_);
      break;
    }
    // .iroha.protocol.SignatoriesResponse signatories_response = 5;
    case kSignatoriesResponse: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.response_.signatories_response_);
      break;
    }
    // .iroha.protocol.TransactionsResponse transactions_response = 6;
    case kTransactionsResponse: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.response_.transactions_response_);
      break;
    }
    // .iroha.protocol.AssetResponse asset_response = 7;
    case kAssetResponse: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.response_.asset_response_);
      break;
    }
    // .iroha.protocol.RolesResponse roles_response = 8;
    case kRolesResponse: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.response_.roles_response_);
      break;
    }
    // .iroha.protocol.RolePermissionsResponse role_permissions_response = 9;
    case kRolePermissionsResponse: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.response_.role_permissions_response_);
      break;
    }
    // .iroha.protocol.TransactionsPageResponse transactions_page_response = 11;
    case kTransactionsPageResponse: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.response_.transactions_page_response_);
      break;
    }
    // .iroha.protocol.PendingTransactionsPageResponse pending_transactions_page_response = 13;
    case kPendingTransactionsPageResponse: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.response_.pending_transactions_page_response_);
      break;
    }
    // .iroha.protocol.BlockResponse block_response = 12;
    case kBlockResponse: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.response_.block_response_);
      break;
    }
    // .iroha.protocol.PeersResponse peers_response = 14;
    case kPeersResponse: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.response_.peers_response_);
      break;
    }
    // .iroha.protocol.EngineReceiptsResponse engine_receipts_response = 15;
    case kEngineReceiptsResponse: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.response_.engine_receipts_response_);
      break;
    }
    case RESPONSE_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData QueryResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    QueryResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*QueryResponse::GetClassData() const { return &_class_data_; }


void QueryResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<QueryResponse*>(&to_msg);
  auto& from = static_cast<const QueryResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:iroha.protocol.QueryResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_query_hash().empty()) {
    _this->_internal_set_query_hash(from._internal_query_hash());
  }
  switch (from.response_case()) {
    case kAccountAssetsResponse: {
      _this->_internal_mutable_account_assets_response()->::iroha::protocol::AccountAssetResponse::MergeFrom(
          from._internal_account_assets_response());
      break;
    }
    case kAccountDetailResponse: {
      _this->_internal_mutable_account_detail_response()->::iroha::protocol::AccountDetailResponse::MergeFrom(
          from._internal_account_detail_response());
      break;
    }
    case kAccountResponse: {
      _this->_internal_mutable_account_response()->::iroha::protocol::AccountResponse::MergeFrom(
          from._internal_account_response());
      break;
    }
    case kErrorResponse: {
      _this->_internal_mutable_error_response()->::iroha::protocol::ErrorResponse::MergeFrom(
          from._internal_error_response());
      break;
    }
    case kSignatoriesResponse: {
      _this->_internal_mutable_signatories_response()->::iroha::protocol::SignatoriesResponse::MergeFrom(
          from._internal_signatories_response());
      break;
    }
    case kTransactionsResponse: {
      _this->_internal_mutable_transactions_response()->::iroha::protocol::TransactionsResponse::MergeFrom(
          from._internal_transactions_response());
      break;
    }
    case kAssetResponse: {
      _this->_internal_mutable_asset_response()->::iroha::protocol::AssetResponse::MergeFrom(
          from._internal_asset_response());
      break;
    }
    case kRolesResponse: {
      _this->_internal_mutable_roles_response()->::iroha::protocol::RolesResponse::MergeFrom(
          from._internal_roles_response());
      break;
    }
    case kRolePermissionsResponse: {
      _this->_internal_mutable_role_permissions_response()->::iroha::protocol::RolePermissionsResponse::MergeFrom(
          from._internal_role_permissions_response());
      break;
    }
    case kTransactionsPageResponse: {
      _this->_internal_mutable_transactions_page_response()->::iroha::protocol::TransactionsPageResponse::MergeFrom(
          from._internal_transactions_page_response());
      break;
    }
    case kPendingTransactionsPageResponse: {
      _this->_internal_mutable_pending_transactions_page_response()->::iroha::protocol::PendingTransactionsPageResponse::MergeFrom(
          from._internal_pending_transactions_page_response());
      break;
    }
    case kBlockResponse: {
      _this->_internal_mutable_block_response()->::iroha::protocol::BlockResponse::MergeFrom(
          from._internal_block_response());
      break;
    }
    case kPeersResponse: {
      _this->_internal_mutable_peers_response()->::iroha::protocol::PeersResponse::MergeFrom(
          from._internal_peers_response());
      break;
    }
    case kEngineReceiptsResponse: {
      _this->_internal_mutable_engine_receipts_response()->::iroha::protocol::EngineReceiptsResponse::MergeFrom(
          from._internal_engine_receipts_response());
      break;
    }
    case RESPONSE_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void QueryResponse::CopyFrom(const QueryResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:iroha.protocol.QueryResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool QueryResponse::IsInitialized() const {
  return true;
}

void QueryResponse::InternalSwap(QueryResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.query_hash_, lhs_arena,
      &other->_impl_.query_hash_, rhs_arena
  );
  swap(_impl_.response_, other->_impl_.response_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata QueryResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_qry_5fresponses_2eproto_getter, &descriptor_table_qry_5fresponses_2eproto_once,
      file_level_metadata_qry_5fresponses_2eproto[18]);
}

// ===================================================================

class BlockResponse::_Internal {
 public:
  static const ::iroha::protocol::Block& block(const BlockResponse* msg);
};

const ::iroha::protocol::Block&
BlockResponse::_Internal::block(const BlockResponse* msg) {
  return *msg->_impl_.block_;
}
void BlockResponse::clear_block() {
  if (GetArenaForAllocation() == nullptr && _impl_.block_ != nullptr) {
    delete _impl_.block_;
  }
  _impl_.block_ = nullptr;
}
BlockResponse::BlockResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:iroha.protocol.BlockResponse)
}
BlockResponse::BlockResponse(const BlockResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  BlockResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.block_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_block()) {
    _this->_impl_.block_ = new ::iroha::protocol::Block(*from._impl_.block_);
  }
  // @@protoc_insertion_point(copy_constructor:iroha.protocol.BlockResponse)
}

inline void BlockResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.block_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

BlockResponse::~BlockResponse() {
  // @@protoc_insertion_point(destructor:iroha.protocol.BlockResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void BlockResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.block_;
}

void BlockResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void BlockResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:iroha.protocol.BlockResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.block_ != nullptr) {
    delete _impl_.block_;
  }
  _impl_.block_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* BlockResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .iroha.protocol.Block block = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_block(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* BlockResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:iroha.protocol.BlockResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .iroha.protocol.Block block = 1;
  if (this->_internal_has_block()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::block(this),
        _Internal::block(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:iroha.protocol.BlockResponse)
  return target;
}

size_t BlockResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:iroha.protocol.BlockResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .iroha.protocol.Block block = 1;
  if (this->_internal_has_block()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.block_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData BlockResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    BlockResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*BlockResponse::GetClassData() const { return &_class_data_; }


void BlockResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<BlockResponse*>(&to_msg);
  auto& from = static_cast<const BlockResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:iroha.protocol.BlockResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_block()) {
    _this->_internal_mutable_block()->::iroha::protocol::Block::MergeFrom(
        from._internal_block());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void BlockResponse::CopyFrom(const BlockResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:iroha.protocol.BlockResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BlockResponse::IsInitialized() const {
  return true;
}

void BlockResponse::InternalSwap(BlockResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.block_, other->_impl_.block_);
}

::PROTOBUF_NAMESPACE_ID::Metadata BlockResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_qry_5fresponses_2eproto_getter, &descriptor_table_qry_5fresponses_2eproto_once,
      file_level_metadata_qry_5fresponses_2eproto[19]);
}

// ===================================================================

class BlockErrorResponse::_Internal {
 public:
};

BlockErrorResponse::BlockErrorResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:iroha.protocol.BlockErrorResponse)
}
BlockErrorResponse::BlockErrorResponse(const BlockErrorResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  BlockErrorResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.message_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.message_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.message_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_message().empty()) {
    _this->_impl_.message_.Set(from._internal_message(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:iroha.protocol.BlockErrorResponse)
}

inline void BlockErrorResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.message_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.message_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.message_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

BlockErrorResponse::~BlockErrorResponse() {
  // @@protoc_insertion_point(destructor:iroha.protocol.BlockErrorResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void BlockErrorResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.message_.Destroy();
}

void BlockErrorResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void BlockErrorResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:iroha.protocol.BlockErrorResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.message_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* BlockErrorResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string message = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_message();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "iroha.protocol.BlockErrorResponse.message"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* BlockErrorResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:iroha.protocol.BlockErrorResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string message = 1;
  if (!this->_internal_message().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_message().data(), static_cast<int>(this->_internal_message().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "iroha.protocol.BlockErrorResponse.message");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_message(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:iroha.protocol.BlockErrorResponse)
  return target;
}

size_t BlockErrorResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:iroha.protocol.BlockErrorResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string message = 1;
  if (!this->_internal_message().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_message());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData BlockErrorResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    BlockErrorResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*BlockErrorResponse::GetClassData() const { return &_class_data_; }


void BlockErrorResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<BlockErrorResponse*>(&to_msg);
  auto& from = static_cast<const BlockErrorResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:iroha.protocol.BlockErrorResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_message().empty()) {
    _this->_internal_set_message(from._internal_message());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void BlockErrorResponse::CopyFrom(const BlockErrorResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:iroha.protocol.BlockErrorResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BlockErrorResponse::IsInitialized() const {
  return true;
}

void BlockErrorResponse::InternalSwap(BlockErrorResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.message_, lhs_arena,
      &other->_impl_.message_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata BlockErrorResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_qry_5fresponses_2eproto_getter, &descriptor_table_qry_5fresponses_2eproto_once,
      file_level_metadata_qry_5fresponses_2eproto[20]);
}

// ===================================================================

class BlockQueryResponse::_Internal {
 public:
  static const ::iroha::protocol::BlockResponse& block_response(const BlockQueryResponse* msg);
  static const ::iroha::protocol::BlockErrorResponse& block_error_response(const BlockQueryResponse* msg);
};

const ::iroha::protocol::BlockResponse&
BlockQueryResponse::_Internal::block_response(const BlockQueryResponse* msg) {
  return *msg->_impl_.response_.block_response_;
}
const ::iroha::protocol::BlockErrorResponse&
BlockQueryResponse::_Internal::block_error_response(const BlockQueryResponse* msg) {
  return *msg->_impl_.response_.block_error_response_;
}
void BlockQueryResponse::set_allocated_block_response(::iroha::protocol::BlockResponse* block_response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_response();
  if (block_response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(block_response);
    if (message_arena != submessage_arena) {
      block_response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, block_response, submessage_arena);
    }
    set_has_block_response();
    _impl_.response_.block_response_ = block_response;
  }
  // @@protoc_insertion_point(field_set_allocated:iroha.protocol.BlockQueryResponse.block_response)
}
void BlockQueryResponse::set_allocated_block_error_response(::iroha::protocol::BlockErrorResponse* block_error_response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_response();
  if (block_error_response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(block_error_response);
    if (message_arena != submessage_arena) {
      block_error_response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, block_error_response, submessage_arena);
    }
    set_has_block_error_response();
    _impl_.response_.block_error_response_ = block_error_response;
  }
  // @@protoc_insertion_point(field_set_allocated:iroha.protocol.BlockQueryResponse.block_error_response)
}
BlockQueryResponse::BlockQueryResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:iroha.protocol.BlockQueryResponse)
}
BlockQueryResponse::BlockQueryResponse(const BlockQueryResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  BlockQueryResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.response_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  clear_has_response();
  switch (from.response_case()) {
    case kBlockResponse: {
      _this->_internal_mutable_block_response()->::iroha::protocol::BlockResponse::MergeFrom(
          from._internal_block_response());
      break;
    }
    case kBlockErrorResponse: {
      _this->_internal_mutable_block_error_response()->::iroha::protocol::BlockErrorResponse::MergeFrom(
          from._internal_block_error_response());
      break;
    }
    case RESPONSE_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:iroha.protocol.BlockQueryResponse)
}

inline void BlockQueryResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.response_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_response();
}

BlockQueryResponse::~BlockQueryResponse() {
  // @@protoc_insertion_point(destructor:iroha.protocol.BlockQueryResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void BlockQueryResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_response()) {
    clear_response();
  }
}

void BlockQueryResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void BlockQueryResponse::clear_response() {
// @@protoc_insertion_point(one_of_clear_start:iroha.protocol.BlockQueryResponse)
  switch (response_case()) {
    case kBlockResponse: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.response_.block_response_;
      }
      break;
    }
    case kBlockErrorResponse: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.response_.block_error_response_;
      }
      break;
    }
    case RESPONSE_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = RESPONSE_NOT_SET;
}


void BlockQueryResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:iroha.protocol.BlockQueryResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_response();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* BlockQueryResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .iroha.protocol.BlockResponse block_response = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_block_response(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .iroha.protocol.BlockErrorResponse block_error_response = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_block_error_response(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* BlockQueryResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:iroha.protocol.BlockQueryResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .iroha.protocol.BlockResponse block_response = 1;
  if (_internal_has_block_response()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::block_response(this),
        _Internal::block_response(this).GetCachedSize(), target, stream);
  }

  // .iroha.protocol.BlockErrorResponse block_error_response = 2;
  if (_internal_has_block_error_response()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::block_error_response(this),
        _Internal::block_error_response(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:iroha.protocol.BlockQueryResponse)
  return target;
}

size_t BlockQueryResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:iroha.protocol.BlockQueryResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (response_case()) {
    // .iroha.protocol.BlockResponse block_response = 1;
    case kBlockResponse: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.response_.block_response_);
      break;
    }
    // .iroha.protocol.BlockErrorResponse block_error_response = 2;
    case kBlockErrorResponse: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.response_.block_error_response_);
      break;
    }
    case RESPONSE_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData BlockQueryResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    BlockQueryResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*BlockQueryResponse::GetClassData() const { return &_class_data_; }


void BlockQueryResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<BlockQueryResponse*>(&to_msg);
  auto& from = static_cast<const BlockQueryResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:iroha.protocol.BlockQueryResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.response_case()) {
    case kBlockResponse: {
      _this->_internal_mutable_block_response()->::iroha::protocol::BlockResponse::MergeFrom(
          from._internal_block_response());
      break;
    }
    case kBlockErrorResponse: {
      _this->_internal_mutable_block_error_response()->::iroha::protocol::BlockErrorResponse::MergeFrom(
          from._internal_block_error_response());
      break;
    }
    case RESPONSE_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void BlockQueryResponse::CopyFrom(const BlockQueryResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:iroha.protocol.BlockQueryResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BlockQueryResponse::IsInitialized() const {
  return true;
}

void BlockQueryResponse::InternalSwap(BlockQueryResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.response_, other->_impl_.response_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata BlockQueryResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_qry_5fresponses_2eproto_getter, &descriptor_table_qry_5fresponses_2eproto_once,
      file_level_metadata_qry_5fresponses_2eproto[21]);
}

// ===================================================================

class HealthcheckData::_Internal {
 public:
};

HealthcheckData::HealthcheckData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:iroha.protocol.HealthcheckData)
}
HealthcheckData::HealthcheckData(const HealthcheckData& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  HealthcheckData* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.opt_memory_consumption_){}
    , decltype(_impl_.opt_is_healthy_){}
    , decltype(_impl_.opt_is_syncing_){}
    , decltype(_impl_.opt_last_block_height_){}
    , decltype(_impl_.opt_last_block_reject_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  clear_has_opt_memory_consumption();
  switch (from.opt_memory_consumption_case()) {
    case kMemoryConsumption: {
      _this->_internal_set_memory_consumption(from._internal_memory_consumption());
      break;
    }
    case OPT_MEMORY_CONSUMPTION_NOT_SET: {
      break;
    }
  }
  clear_has_opt_is_healthy();
  switch (from.opt_is_healthy_case()) {
    case kIsHealthy: {
      _this->_internal_set_is_healthy(from._internal_is_healthy());
      break;
    }
    case OPT_IS_HEALTHY_NOT_SET: {
      break;
    }
  }
  clear_has_opt_is_syncing();
  switch (from.opt_is_syncing_case()) {
    case kIsSyncing: {
      _this->_internal_set_is_syncing(from._internal_is_syncing());
      break;
    }
    case OPT_IS_SYNCING_NOT_SET: {
      break;
    }
  }
  clear_has_opt_last_block_height();
  switch (from.opt_last_block_height_case()) {
    case kLastBlockHeight: {
      _this->_internal_set_last_block_height(from._internal_last_block_height());
      break;
    }
    case OPT_LAST_BLOCK_HEIGHT_NOT_SET: {
      break;
    }
  }
  clear_has_opt_last_block_reject();
  switch (from.opt_last_block_reject_case()) {
    case kLastBlockReject: {
      _this->_internal_set_last_block_reject(from._internal_last_block_reject());
      break;
    }
    case OPT_LAST_BLOCK_REJECT_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:iroha.protocol.HealthcheckData)
}

inline void HealthcheckData::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.opt_memory_consumption_){}
    , decltype(_impl_.opt_is_healthy_){}
    , decltype(_impl_.opt_is_syncing_){}
    , decltype(_impl_.opt_last_block_height_){}
    , decltype(_impl_.opt_last_block_reject_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_opt_memory_consumption();
  clear_has_opt_is_healthy();
  clear_has_opt_is_syncing();
  clear_has_opt_last_block_height();
  clear_has_opt_last_block_reject();
}

HealthcheckData::~HealthcheckData() {
  // @@protoc_insertion_point(destructor:iroha.protocol.HealthcheckData)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void HealthcheckData::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_opt_memory_consumption()) {
    clear_opt_memory_consumption();
  }
  if (has_opt_is_healthy()) {
    clear_opt_is_healthy();
  }
  if (has_opt_is_syncing()) {
    clear_opt_is_syncing();
  }
  if (has_opt_last_block_height()) {
    clear_opt_last_block_height();
  }
  if (has_opt_last_block_reject()) {
    clear_opt_last_block_reject();
  }
}

void HealthcheckData::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void HealthcheckData::clear_opt_memory_consumption() {
// @@protoc_insertion_point(one_of_clear_start:iroha.protocol.HealthcheckData)
  switch (opt_memory_consumption_case()) {
    case kMemoryConsumption: {
      // No need to clear
      break;
    }
    case OPT_MEMORY_CONSUMPTION_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = OPT_MEMORY_CONSUMPTION_NOT_SET;
}

void HealthcheckData::clear_opt_is_healthy() {
// @@protoc_insertion_point(one_of_clear_start:iroha.protocol.HealthcheckData)
  switch (opt_is_healthy_case()) {
    case kIsHealthy: {
      // No need to clear
      break;
    }
    case OPT_IS_HEALTHY_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[1] = OPT_IS_HEALTHY_NOT_SET;
}

void HealthcheckData::clear_opt_is_syncing() {
// @@protoc_insertion_point(one_of_clear_start:iroha.protocol.HealthcheckData)
  switch (opt_is_syncing_case()) {
    case kIsSyncing: {
      // No need to clear
      break;
    }
    case OPT_IS_SYNCING_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[2] = OPT_IS_SYNCING_NOT_SET;
}

void HealthcheckData::clear_opt_last_block_height() {
// @@protoc_insertion_point(one_of_clear_start:iroha.protocol.HealthcheckData)
  switch (opt_last_block_height_case()) {
    case kLastBlockHeight: {
      // No need to clear
      break;
    }
    case OPT_LAST_BLOCK_HEIGHT_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[3] = OPT_LAST_BLOCK_HEIGHT_NOT_SET;
}

void HealthcheckData::clear_opt_last_block_reject() {
// @@protoc_insertion_point(one_of_clear_start:iroha.protocol.HealthcheckData)
  switch (opt_last_block_reject_case()) {
    case kLastBlockReject: {
      // No need to clear
      break;
    }
    case OPT_LAST_BLOCK_REJECT_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[4] = OPT_LAST_BLOCK_REJECT_NOT_SET;
}


void HealthcheckData::Clear() {
// @@protoc_insertion_point(message_clear_start:iroha.protocol.HealthcheckData)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_opt_memory_consumption();
  clear_opt_is_healthy();
  clear_opt_is_syncing();
  clear_opt_last_block_height();
  clear_opt_last_block_reject();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* HealthcheckData::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint64 memory_consumption = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _internal_set_memory_consumption(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool is_healthy = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _internal_set_is_healthy(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool is_syncing = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _internal_set_is_syncing(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 last_block_height = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _internal_set_last_block_height(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 last_block_reject = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _internal_set_last_block_reject(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* HealthcheckData::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:iroha.protocol.HealthcheckData)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint64 memory_consumption = 1;
  if (_internal_has_memory_consumption()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_memory_consumption(), target);
  }

  // bool is_healthy = 2;
  if (_internal_has_is_healthy()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_is_healthy(), target);
  }

  // bool is_syncing = 3;
  if (_internal_has_is_syncing()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_is_syncing(), target);
  }

  // uint64 last_block_height = 4;
  if (_internal_has_last_block_height()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(4, this->_internal_last_block_height(), target);
  }

  // uint64 last_block_reject = 5;
  if (_internal_has_last_block_reject()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(5, this->_internal_last_block_reject(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:iroha.protocol.HealthcheckData)
  return target;
}

size_t HealthcheckData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:iroha.protocol.HealthcheckData)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (opt_memory_consumption_case()) {
    // uint64 memory_consumption = 1;
    case kMemoryConsumption: {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_memory_consumption());
      break;
    }
    case OPT_MEMORY_CONSUMPTION_NOT_SET: {
      break;
    }
  }
  switch (opt_is_healthy_case()) {
    // bool is_healthy = 2;
    case kIsHealthy: {
      total_size += 1 + 1;
      break;
    }
    case OPT_IS_HEALTHY_NOT_SET: {
      break;
    }
  }
  switch (opt_is_syncing_case()) {
    // bool is_syncing = 3;
    case kIsSyncing: {
      total_size += 1 + 1;
      break;
    }
    case OPT_IS_SYNCING_NOT_SET: {
      break;
    }
  }
  switch (opt_last_block_height_case()) {
    // uint64 last_block_height = 4;
    case kLastBlockHeight: {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_last_block_height());
      break;
    }
    case OPT_LAST_BLOCK_HEIGHT_NOT_SET: {
      break;
    }
  }
  switch (opt_last_block_reject_case()) {
    // uint64 last_block_reject = 5;
    case kLastBlockReject: {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_last_block_reject());
      break;
    }
    case OPT_LAST_BLOCK_REJECT_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData HealthcheckData::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    HealthcheckData::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*HealthcheckData::GetClassData() const { return &_class_data_; }


void HealthcheckData::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<HealthcheckData*>(&to_msg);
  auto& from = static_cast<const HealthcheckData&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:iroha.protocol.HealthcheckData)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.opt_memory_consumption_case()) {
    case kMemoryConsumption: {
      _this->_internal_set_memory_consumption(from._internal_memory_consumption());
      break;
    }
    case OPT_MEMORY_CONSUMPTION_NOT_SET: {
      break;
    }
  }
  switch (from.opt_is_healthy_case()) {
    case kIsHealthy: {
      _this->_internal_set_is_healthy(from._internal_is_healthy());
      break;
    }
    case OPT_IS_HEALTHY_NOT_SET: {
      break;
    }
  }
  switch (from.opt_is_syncing_case()) {
    case kIsSyncing: {
      _this->_internal_set_is_syncing(from._internal_is_syncing());
      break;
    }
    case OPT_IS_SYNCING_NOT_SET: {
      break;
    }
  }
  switch (from.opt_last_block_height_case()) {
    case kLastBlockHeight: {
      _this->_internal_set_last_block_height(from._internal_last_block_height());
      break;
    }
    case OPT_LAST_BLOCK_HEIGHT_NOT_SET: {
      break;
    }
  }
  switch (from.opt_last_block_reject_case()) {
    case kLastBlockReject: {
      _this->_internal_set_last_block_reject(from._internal_last_block_reject());
      break;
    }
    case OPT_LAST_BLOCK_REJECT_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void HealthcheckData::CopyFrom(const HealthcheckData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:iroha.protocol.HealthcheckData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool HealthcheckData::IsInitialized() const {
  return true;
}

void HealthcheckData::InternalSwap(HealthcheckData* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.opt_memory_consumption_, other->_impl_.opt_memory_consumption_);
  swap(_impl_.opt_is_healthy_, other->_impl_.opt_is_healthy_);
  swap(_impl_.opt_is_syncing_, other->_impl_.opt_is_syncing_);
  swap(_impl_.opt_last_block_height_, other->_impl_.opt_last_block_height_);
  swap(_impl_.opt_last_block_reject_, other->_impl_.opt_last_block_reject_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
  swap(_impl_._oneof_case_[1], other->_impl_._oneof_case_[1]);
  swap(_impl_._oneof_case_[2], other->_impl_._oneof_case_[2]);
  swap(_impl_._oneof_case_[3], other->_impl_._oneof_case_[3]);
  swap(_impl_._oneof_case_[4], other->_impl_._oneof_case_[4]);
}

::PROTOBUF_NAMESPACE_ID::Metadata HealthcheckData::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_qry_5fresponses_2eproto_getter, &descriptor_table_qry_5fresponses_2eproto_once,
      file_level_metadata_qry_5fresponses_2eproto[22]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace protocol
}  // namespace iroha
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::iroha::protocol::Asset*
Arena::CreateMaybeMessage< ::iroha::protocol::Asset >(Arena* arena) {
  return Arena::CreateMessageInternal< ::iroha::protocol::Asset >(arena);
}
template<> PROTOBUF_NOINLINE ::iroha::protocol::Domain*
Arena::CreateMaybeMessage< ::iroha::protocol::Domain >(Arena* arena) {
  return Arena::CreateMessageInternal< ::iroha::protocol::Domain >(arena);
}
template<> PROTOBUF_NOINLINE ::iroha::protocol::Account*
Arena::CreateMaybeMessage< ::iroha::protocol::Account >(Arena* arena) {
  return Arena::CreateMessageInternal< ::iroha::protocol::Account >(arena);
}
template<> PROTOBUF_NOINLINE ::iroha::protocol::AccountAsset*
Arena::CreateMaybeMessage< ::iroha::protocol::AccountAsset >(Arena* arena) {
  return Arena::CreateMessageInternal< ::iroha::protocol::AccountAsset >(arena);
}
template<> PROTOBUF_NOINLINE ::iroha::protocol::AccountAssetResponse*
Arena::CreateMaybeMessage< ::iroha::protocol::AccountAssetResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::iroha::protocol::AccountAssetResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::iroha::protocol::AccountDetailResponse*
Arena::CreateMaybeMessage< ::iroha::protocol::AccountDetailResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::iroha::protocol::AccountDetailResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::iroha::protocol::AccountResponse*
Arena::CreateMaybeMessage< ::iroha::protocol::AccountResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::iroha::protocol::AccountResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::iroha::protocol::AssetResponse*
Arena::CreateMaybeMessage< ::iroha::protocol::AssetResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::iroha::protocol::AssetResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::iroha::protocol::RolesResponse*
Arena::CreateMaybeMessage< ::iroha::protocol::RolesResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::iroha::protocol::RolesResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::iroha::protocol::RolePermissionsResponse*
Arena::CreateMaybeMessage< ::iroha::protocol::RolePermissionsResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::iroha::protocol::RolePermissionsResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::iroha::protocol::ErrorResponse*
Arena::CreateMaybeMessage< ::iroha::protocol::ErrorResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::iroha::protocol::ErrorResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::iroha::protocol::SignatoriesResponse*
Arena::CreateMaybeMessage< ::iroha::protocol::SignatoriesResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::iroha::protocol::SignatoriesResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::iroha::protocol::TransactionsResponse*
Arena::CreateMaybeMessage< ::iroha::protocol::TransactionsResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::iroha::protocol::TransactionsResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::iroha::protocol::TransactionsPageResponse*
Arena::CreateMaybeMessage< ::iroha::protocol::TransactionsPageResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::iroha::protocol::TransactionsPageResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::iroha::protocol::PendingTransactionsPageResponse_BatchInfo*
Arena::CreateMaybeMessage< ::iroha::protocol::PendingTransactionsPageResponse_BatchInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::iroha::protocol::PendingTransactionsPageResponse_BatchInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::iroha::protocol::PendingTransactionsPageResponse*
Arena::CreateMaybeMessage< ::iroha::protocol::PendingTransactionsPageResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::iroha::protocol::PendingTransactionsPageResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::iroha::protocol::PeersResponse*
Arena::CreateMaybeMessage< ::iroha::protocol::PeersResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::iroha::protocol::PeersResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::iroha::protocol::EngineReceiptsResponse*
Arena::CreateMaybeMessage< ::iroha::protocol::EngineReceiptsResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::iroha::protocol::EngineReceiptsResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::iroha::protocol::QueryResponse*
Arena::CreateMaybeMessage< ::iroha::protocol::QueryResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::iroha::protocol::QueryResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::iroha::protocol::BlockResponse*
Arena::CreateMaybeMessage< ::iroha::protocol::BlockResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::iroha::protocol::BlockResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::iroha::protocol::BlockErrorResponse*
Arena::CreateMaybeMessage< ::iroha::protocol::BlockErrorResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::iroha::protocol::BlockErrorResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::iroha::protocol::BlockQueryResponse*
Arena::CreateMaybeMessage< ::iroha::protocol::BlockQueryResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::iroha::protocol::BlockQueryResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::iroha::protocol::HealthcheckData*
Arena::CreateMaybeMessage< ::iroha::protocol::HealthcheckData >(Arena* arena) {
  return Arena::CreateMessageInternal< ::iroha::protocol::HealthcheckData >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
