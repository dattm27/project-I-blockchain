// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: commands.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_commands_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_commands_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "primitive.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_commands_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_commands_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_commands_2eproto;
namespace iroha {
namespace protocol {
class AddAssetQuantity;
struct AddAssetQuantityDefaultTypeInternal;
extern AddAssetQuantityDefaultTypeInternal _AddAssetQuantity_default_instance_;
class AddPeer;
struct AddPeerDefaultTypeInternal;
extern AddPeerDefaultTypeInternal _AddPeer_default_instance_;
class AddSignatory;
struct AddSignatoryDefaultTypeInternal;
extern AddSignatoryDefaultTypeInternal _AddSignatory_default_instance_;
class AppendRole;
struct AppendRoleDefaultTypeInternal;
extern AppendRoleDefaultTypeInternal _AppendRole_default_instance_;
class CallEngine;
struct CallEngineDefaultTypeInternal;
extern CallEngineDefaultTypeInternal _CallEngine_default_instance_;
class Command;
struct CommandDefaultTypeInternal;
extern CommandDefaultTypeInternal _Command_default_instance_;
class CompareAndSetAccountDetail;
struct CompareAndSetAccountDetailDefaultTypeInternal;
extern CompareAndSetAccountDetailDefaultTypeInternal _CompareAndSetAccountDetail_default_instance_;
class CreateAccount;
struct CreateAccountDefaultTypeInternal;
extern CreateAccountDefaultTypeInternal _CreateAccount_default_instance_;
class CreateAsset;
struct CreateAssetDefaultTypeInternal;
extern CreateAssetDefaultTypeInternal _CreateAsset_default_instance_;
class CreateDomain;
struct CreateDomainDefaultTypeInternal;
extern CreateDomainDefaultTypeInternal _CreateDomain_default_instance_;
class CreateRole;
struct CreateRoleDefaultTypeInternal;
extern CreateRoleDefaultTypeInternal _CreateRole_default_instance_;
class DetachRole;
struct DetachRoleDefaultTypeInternal;
extern DetachRoleDefaultTypeInternal _DetachRole_default_instance_;
class GrantPermission;
struct GrantPermissionDefaultTypeInternal;
extern GrantPermissionDefaultTypeInternal _GrantPermission_default_instance_;
class RemovePeer;
struct RemovePeerDefaultTypeInternal;
extern RemovePeerDefaultTypeInternal _RemovePeer_default_instance_;
class RemoveSignatory;
struct RemoveSignatoryDefaultTypeInternal;
extern RemoveSignatoryDefaultTypeInternal _RemoveSignatory_default_instance_;
class RevokePermission;
struct RevokePermissionDefaultTypeInternal;
extern RevokePermissionDefaultTypeInternal _RevokePermission_default_instance_;
class SetAccountDetail;
struct SetAccountDetailDefaultTypeInternal;
extern SetAccountDetailDefaultTypeInternal _SetAccountDetail_default_instance_;
class SetAccountQuorum;
struct SetAccountQuorumDefaultTypeInternal;
extern SetAccountQuorumDefaultTypeInternal _SetAccountQuorum_default_instance_;
class SetSettingValue;
struct SetSettingValueDefaultTypeInternal;
extern SetSettingValueDefaultTypeInternal _SetSettingValue_default_instance_;
class SubtractAssetQuantity;
struct SubtractAssetQuantityDefaultTypeInternal;
extern SubtractAssetQuantityDefaultTypeInternal _SubtractAssetQuantity_default_instance_;
class TransferAsset;
struct TransferAssetDefaultTypeInternal;
extern TransferAssetDefaultTypeInternal _TransferAsset_default_instance_;
}  // namespace protocol
}  // namespace iroha
PROTOBUF_NAMESPACE_OPEN
template<> ::iroha::protocol::AddAssetQuantity* Arena::CreateMaybeMessage<::iroha::protocol::AddAssetQuantity>(Arena*);
template<> ::iroha::protocol::AddPeer* Arena::CreateMaybeMessage<::iroha::protocol::AddPeer>(Arena*);
template<> ::iroha::protocol::AddSignatory* Arena::CreateMaybeMessage<::iroha::protocol::AddSignatory>(Arena*);
template<> ::iroha::protocol::AppendRole* Arena::CreateMaybeMessage<::iroha::protocol::AppendRole>(Arena*);
template<> ::iroha::protocol::CallEngine* Arena::CreateMaybeMessage<::iroha::protocol::CallEngine>(Arena*);
template<> ::iroha::protocol::Command* Arena::CreateMaybeMessage<::iroha::protocol::Command>(Arena*);
template<> ::iroha::protocol::CompareAndSetAccountDetail* Arena::CreateMaybeMessage<::iroha::protocol::CompareAndSetAccountDetail>(Arena*);
template<> ::iroha::protocol::CreateAccount* Arena::CreateMaybeMessage<::iroha::protocol::CreateAccount>(Arena*);
template<> ::iroha::protocol::CreateAsset* Arena::CreateMaybeMessage<::iroha::protocol::CreateAsset>(Arena*);
template<> ::iroha::protocol::CreateDomain* Arena::CreateMaybeMessage<::iroha::protocol::CreateDomain>(Arena*);
template<> ::iroha::protocol::CreateRole* Arena::CreateMaybeMessage<::iroha::protocol::CreateRole>(Arena*);
template<> ::iroha::protocol::DetachRole* Arena::CreateMaybeMessage<::iroha::protocol::DetachRole>(Arena*);
template<> ::iroha::protocol::GrantPermission* Arena::CreateMaybeMessage<::iroha::protocol::GrantPermission>(Arena*);
template<> ::iroha::protocol::RemovePeer* Arena::CreateMaybeMessage<::iroha::protocol::RemovePeer>(Arena*);
template<> ::iroha::protocol::RemoveSignatory* Arena::CreateMaybeMessage<::iroha::protocol::RemoveSignatory>(Arena*);
template<> ::iroha::protocol::RevokePermission* Arena::CreateMaybeMessage<::iroha::protocol::RevokePermission>(Arena*);
template<> ::iroha::protocol::SetAccountDetail* Arena::CreateMaybeMessage<::iroha::protocol::SetAccountDetail>(Arena*);
template<> ::iroha::protocol::SetAccountQuorum* Arena::CreateMaybeMessage<::iroha::protocol::SetAccountQuorum>(Arena*);
template<> ::iroha::protocol::SetSettingValue* Arena::CreateMaybeMessage<::iroha::protocol::SetSettingValue>(Arena*);
template<> ::iroha::protocol::SubtractAssetQuantity* Arena::CreateMaybeMessage<::iroha::protocol::SubtractAssetQuantity>(Arena*);
template<> ::iroha::protocol::TransferAsset* Arena::CreateMaybeMessage<::iroha::protocol::TransferAsset>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace iroha {
namespace protocol {

enum CallEngine_EngineType : int {
  CallEngine_EngineType_kSolidity = 0,
  CallEngine_EngineType_CallEngine_EngineType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  CallEngine_EngineType_CallEngine_EngineType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool CallEngine_EngineType_IsValid(int value);
constexpr CallEngine_EngineType CallEngine_EngineType_EngineType_MIN = CallEngine_EngineType_kSolidity;
constexpr CallEngine_EngineType CallEngine_EngineType_EngineType_MAX = CallEngine_EngineType_kSolidity;
constexpr int CallEngine_EngineType_EngineType_ARRAYSIZE = CallEngine_EngineType_EngineType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CallEngine_EngineType_descriptor();
template<typename T>
inline const std::string& CallEngine_EngineType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CallEngine_EngineType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CallEngine_EngineType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CallEngine_EngineType_descriptor(), enum_t_value);
}
inline bool CallEngine_EngineType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CallEngine_EngineType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CallEngine_EngineType>(
    CallEngine_EngineType_descriptor(), name, value);
}
// ===================================================================

class AddAssetQuantity final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:iroha.protocol.AddAssetQuantity) */ {
 public:
  inline AddAssetQuantity() : AddAssetQuantity(nullptr) {}
  ~AddAssetQuantity() override;
  explicit PROTOBUF_CONSTEXPR AddAssetQuantity(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AddAssetQuantity(const AddAssetQuantity& from);
  AddAssetQuantity(AddAssetQuantity&& from) noexcept
    : AddAssetQuantity() {
    *this = ::std::move(from);
  }

  inline AddAssetQuantity& operator=(const AddAssetQuantity& from) {
    CopyFrom(from);
    return *this;
  }
  inline AddAssetQuantity& operator=(AddAssetQuantity&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AddAssetQuantity& default_instance() {
    return *internal_default_instance();
  }
  static inline const AddAssetQuantity* internal_default_instance() {
    return reinterpret_cast<const AddAssetQuantity*>(
               &_AddAssetQuantity_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(AddAssetQuantity& a, AddAssetQuantity& b) {
    a.Swap(&b);
  }
  inline void Swap(AddAssetQuantity* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AddAssetQuantity* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AddAssetQuantity* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AddAssetQuantity>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AddAssetQuantity& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AddAssetQuantity& from) {
    AddAssetQuantity::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AddAssetQuantity* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "iroha.protocol.AddAssetQuantity";
  }
  protected:
  explicit AddAssetQuantity(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAssetIdFieldNumber = 1,
    kAmountFieldNumber = 2,
  };
  // string asset_id = 1;
  void clear_asset_id();
  const std::string& asset_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_asset_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_asset_id();
  PROTOBUF_NODISCARD std::string* release_asset_id();
  void set_allocated_asset_id(std::string* asset_id);
  private:
  const std::string& _internal_asset_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_asset_id(const std::string& value);
  std::string* _internal_mutable_asset_id();
  public:

  // string amount = 2;
  void clear_amount();
  const std::string& amount() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_amount(ArgT0&& arg0, ArgT... args);
  std::string* mutable_amount();
  PROTOBUF_NODISCARD std::string* release_amount();
  void set_allocated_amount(std::string* amount);
  private:
  const std::string& _internal_amount() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_amount(const std::string& value);
  std::string* _internal_mutable_amount();
  public:

  // @@protoc_insertion_point(class_scope:iroha.protocol.AddAssetQuantity)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr asset_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr amount_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_commands_2eproto;
};
// -------------------------------------------------------------------

class AddPeer final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:iroha.protocol.AddPeer) */ {
 public:
  inline AddPeer() : AddPeer(nullptr) {}
  ~AddPeer() override;
  explicit PROTOBUF_CONSTEXPR AddPeer(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AddPeer(const AddPeer& from);
  AddPeer(AddPeer&& from) noexcept
    : AddPeer() {
    *this = ::std::move(from);
  }

  inline AddPeer& operator=(const AddPeer& from) {
    CopyFrom(from);
    return *this;
  }
  inline AddPeer& operator=(AddPeer&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AddPeer& default_instance() {
    return *internal_default_instance();
  }
  static inline const AddPeer* internal_default_instance() {
    return reinterpret_cast<const AddPeer*>(
               &_AddPeer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(AddPeer& a, AddPeer& b) {
    a.Swap(&b);
  }
  inline void Swap(AddPeer* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AddPeer* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AddPeer* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AddPeer>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AddPeer& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AddPeer& from) {
    AddPeer::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AddPeer* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "iroha.protocol.AddPeer";
  }
  protected:
  explicit AddPeer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPeerFieldNumber = 1,
  };
  // .iroha.protocol.Peer peer = 1;
  bool has_peer() const;
  private:
  bool _internal_has_peer() const;
  public:
  void clear_peer();
  const ::iroha::protocol::Peer& peer() const;
  PROTOBUF_NODISCARD ::iroha::protocol::Peer* release_peer();
  ::iroha::protocol::Peer* mutable_peer();
  void set_allocated_peer(::iroha::protocol::Peer* peer);
  private:
  const ::iroha::protocol::Peer& _internal_peer() const;
  ::iroha::protocol::Peer* _internal_mutable_peer();
  public:
  void unsafe_arena_set_allocated_peer(
      ::iroha::protocol::Peer* peer);
  ::iroha::protocol::Peer* unsafe_arena_release_peer();

  // @@protoc_insertion_point(class_scope:iroha.protocol.AddPeer)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::iroha::protocol::Peer* peer_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_commands_2eproto;
};
// -------------------------------------------------------------------

class RemovePeer final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:iroha.protocol.RemovePeer) */ {
 public:
  inline RemovePeer() : RemovePeer(nullptr) {}
  ~RemovePeer() override;
  explicit PROTOBUF_CONSTEXPR RemovePeer(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RemovePeer(const RemovePeer& from);
  RemovePeer(RemovePeer&& from) noexcept
    : RemovePeer() {
    *this = ::std::move(from);
  }

  inline RemovePeer& operator=(const RemovePeer& from) {
    CopyFrom(from);
    return *this;
  }
  inline RemovePeer& operator=(RemovePeer&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RemovePeer& default_instance() {
    return *internal_default_instance();
  }
  static inline const RemovePeer* internal_default_instance() {
    return reinterpret_cast<const RemovePeer*>(
               &_RemovePeer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(RemovePeer& a, RemovePeer& b) {
    a.Swap(&b);
  }
  inline void Swap(RemovePeer* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RemovePeer* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RemovePeer* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RemovePeer>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RemovePeer& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RemovePeer& from) {
    RemovePeer::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RemovePeer* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "iroha.protocol.RemovePeer";
  }
  protected:
  explicit RemovePeer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPublicKeyFieldNumber = 1,
  };
  // string public_key = 1;
  void clear_public_key();
  const std::string& public_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_public_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_public_key();
  PROTOBUF_NODISCARD std::string* release_public_key();
  void set_allocated_public_key(std::string* public_key);
  private:
  const std::string& _internal_public_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_public_key(const std::string& value);
  std::string* _internal_mutable_public_key();
  public:

  // @@protoc_insertion_point(class_scope:iroha.protocol.RemovePeer)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr public_key_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_commands_2eproto;
};
// -------------------------------------------------------------------

class AddSignatory final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:iroha.protocol.AddSignatory) */ {
 public:
  inline AddSignatory() : AddSignatory(nullptr) {}
  ~AddSignatory() override;
  explicit PROTOBUF_CONSTEXPR AddSignatory(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AddSignatory(const AddSignatory& from);
  AddSignatory(AddSignatory&& from) noexcept
    : AddSignatory() {
    *this = ::std::move(from);
  }

  inline AddSignatory& operator=(const AddSignatory& from) {
    CopyFrom(from);
    return *this;
  }
  inline AddSignatory& operator=(AddSignatory&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AddSignatory& default_instance() {
    return *internal_default_instance();
  }
  static inline const AddSignatory* internal_default_instance() {
    return reinterpret_cast<const AddSignatory*>(
               &_AddSignatory_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(AddSignatory& a, AddSignatory& b) {
    a.Swap(&b);
  }
  inline void Swap(AddSignatory* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AddSignatory* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AddSignatory* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AddSignatory>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AddSignatory& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AddSignatory& from) {
    AddSignatory::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AddSignatory* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "iroha.protocol.AddSignatory";
  }
  protected:
  explicit AddSignatory(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAccountIdFieldNumber = 1,
    kPublicKeyFieldNumber = 2,
  };
  // string account_id = 1;
  void clear_account_id();
  const std::string& account_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_account_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_account_id();
  PROTOBUF_NODISCARD std::string* release_account_id();
  void set_allocated_account_id(std::string* account_id);
  private:
  const std::string& _internal_account_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_account_id(const std::string& value);
  std::string* _internal_mutable_account_id();
  public:

  // string public_key = 2;
  void clear_public_key();
  const std::string& public_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_public_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_public_key();
  PROTOBUF_NODISCARD std::string* release_public_key();
  void set_allocated_public_key(std::string* public_key);
  private:
  const std::string& _internal_public_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_public_key(const std::string& value);
  std::string* _internal_mutable_public_key();
  public:

  // @@protoc_insertion_point(class_scope:iroha.protocol.AddSignatory)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr account_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr public_key_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_commands_2eproto;
};
// -------------------------------------------------------------------

class CreateAsset final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:iroha.protocol.CreateAsset) */ {
 public:
  inline CreateAsset() : CreateAsset(nullptr) {}
  ~CreateAsset() override;
  explicit PROTOBUF_CONSTEXPR CreateAsset(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateAsset(const CreateAsset& from);
  CreateAsset(CreateAsset&& from) noexcept
    : CreateAsset() {
    *this = ::std::move(from);
  }

  inline CreateAsset& operator=(const CreateAsset& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateAsset& operator=(CreateAsset&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateAsset& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateAsset* internal_default_instance() {
    return reinterpret_cast<const CreateAsset*>(
               &_CreateAsset_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(CreateAsset& a, CreateAsset& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateAsset* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateAsset* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateAsset* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateAsset>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateAsset& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CreateAsset& from) {
    CreateAsset::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateAsset* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "iroha.protocol.CreateAsset";
  }
  protected:
  explicit CreateAsset(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAssetNameFieldNumber = 1,
    kDomainIdFieldNumber = 2,
    kPrecisionFieldNumber = 3,
  };
  // string asset_name = 1;
  void clear_asset_name();
  const std::string& asset_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_asset_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_asset_name();
  PROTOBUF_NODISCARD std::string* release_asset_name();
  void set_allocated_asset_name(std::string* asset_name);
  private:
  const std::string& _internal_asset_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_asset_name(const std::string& value);
  std::string* _internal_mutable_asset_name();
  public:

  // string domain_id = 2;
  void clear_domain_id();
  const std::string& domain_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_domain_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_domain_id();
  PROTOBUF_NODISCARD std::string* release_domain_id();
  void set_allocated_domain_id(std::string* domain_id);
  private:
  const std::string& _internal_domain_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_domain_id(const std::string& value);
  std::string* _internal_mutable_domain_id();
  public:

  // uint32 precision = 3;
  void clear_precision();
  uint32_t precision() const;
  void set_precision(uint32_t value);
  private:
  uint32_t _internal_precision() const;
  void _internal_set_precision(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:iroha.protocol.CreateAsset)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr asset_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr domain_id_;
    uint32_t precision_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_commands_2eproto;
};
// -------------------------------------------------------------------

class CreateAccount final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:iroha.protocol.CreateAccount) */ {
 public:
  inline CreateAccount() : CreateAccount(nullptr) {}
  ~CreateAccount() override;
  explicit PROTOBUF_CONSTEXPR CreateAccount(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateAccount(const CreateAccount& from);
  CreateAccount(CreateAccount&& from) noexcept
    : CreateAccount() {
    *this = ::std::move(from);
  }

  inline CreateAccount& operator=(const CreateAccount& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateAccount& operator=(CreateAccount&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateAccount& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateAccount* internal_default_instance() {
    return reinterpret_cast<const CreateAccount*>(
               &_CreateAccount_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(CreateAccount& a, CreateAccount& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateAccount* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateAccount* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateAccount* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateAccount>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateAccount& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CreateAccount& from) {
    CreateAccount::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateAccount* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "iroha.protocol.CreateAccount";
  }
  protected:
  explicit CreateAccount(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAccountNameFieldNumber = 1,
    kDomainIdFieldNumber = 2,
    kPublicKeyFieldNumber = 3,
  };
  // string account_name = 1;
  void clear_account_name();
  const std::string& account_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_account_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_account_name();
  PROTOBUF_NODISCARD std::string* release_account_name();
  void set_allocated_account_name(std::string* account_name);
  private:
  const std::string& _internal_account_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_account_name(const std::string& value);
  std::string* _internal_mutable_account_name();
  public:

  // string domain_id = 2;
  void clear_domain_id();
  const std::string& domain_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_domain_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_domain_id();
  PROTOBUF_NODISCARD std::string* release_domain_id();
  void set_allocated_domain_id(std::string* domain_id);
  private:
  const std::string& _internal_domain_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_domain_id(const std::string& value);
  std::string* _internal_mutable_domain_id();
  public:

  // string public_key = 3;
  void clear_public_key();
  const std::string& public_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_public_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_public_key();
  PROTOBUF_NODISCARD std::string* release_public_key();
  void set_allocated_public_key(std::string* public_key);
  private:
  const std::string& _internal_public_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_public_key(const std::string& value);
  std::string* _internal_mutable_public_key();
  public:

  // @@protoc_insertion_point(class_scope:iroha.protocol.CreateAccount)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr account_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr domain_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr public_key_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_commands_2eproto;
};
// -------------------------------------------------------------------

class SetAccountDetail final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:iroha.protocol.SetAccountDetail) */ {
 public:
  inline SetAccountDetail() : SetAccountDetail(nullptr) {}
  ~SetAccountDetail() override;
  explicit PROTOBUF_CONSTEXPR SetAccountDetail(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetAccountDetail(const SetAccountDetail& from);
  SetAccountDetail(SetAccountDetail&& from) noexcept
    : SetAccountDetail() {
    *this = ::std::move(from);
  }

  inline SetAccountDetail& operator=(const SetAccountDetail& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetAccountDetail& operator=(SetAccountDetail&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetAccountDetail& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetAccountDetail* internal_default_instance() {
    return reinterpret_cast<const SetAccountDetail*>(
               &_SetAccountDetail_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(SetAccountDetail& a, SetAccountDetail& b) {
    a.Swap(&b);
  }
  inline void Swap(SetAccountDetail* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetAccountDetail* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetAccountDetail* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetAccountDetail>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetAccountDetail& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SetAccountDetail& from) {
    SetAccountDetail::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetAccountDetail* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "iroha.protocol.SetAccountDetail";
  }
  protected:
  explicit SetAccountDetail(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAccountIdFieldNumber = 1,
    kKeyFieldNumber = 2,
    kValueFieldNumber = 3,
  };
  // string account_id = 1;
  void clear_account_id();
  const std::string& account_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_account_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_account_id();
  PROTOBUF_NODISCARD std::string* release_account_id();
  void set_allocated_account_id(std::string* account_id);
  private:
  const std::string& _internal_account_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_account_id(const std::string& value);
  std::string* _internal_mutable_account_id();
  public:

  // string key = 2;
  void clear_key();
  const std::string& key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // string value = 3;
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // @@protoc_insertion_point(class_scope:iroha.protocol.SetAccountDetail)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr account_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_commands_2eproto;
};
// -------------------------------------------------------------------

class CreateDomain final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:iroha.protocol.CreateDomain) */ {
 public:
  inline CreateDomain() : CreateDomain(nullptr) {}
  ~CreateDomain() override;
  explicit PROTOBUF_CONSTEXPR CreateDomain(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateDomain(const CreateDomain& from);
  CreateDomain(CreateDomain&& from) noexcept
    : CreateDomain() {
    *this = ::std::move(from);
  }

  inline CreateDomain& operator=(const CreateDomain& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateDomain& operator=(CreateDomain&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateDomain& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateDomain* internal_default_instance() {
    return reinterpret_cast<const CreateDomain*>(
               &_CreateDomain_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(CreateDomain& a, CreateDomain& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateDomain* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateDomain* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateDomain* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateDomain>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateDomain& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CreateDomain& from) {
    CreateDomain::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateDomain* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "iroha.protocol.CreateDomain";
  }
  protected:
  explicit CreateDomain(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDomainIdFieldNumber = 1,
    kDefaultRoleFieldNumber = 2,
  };
  // string domain_id = 1;
  void clear_domain_id();
  const std::string& domain_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_domain_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_domain_id();
  PROTOBUF_NODISCARD std::string* release_domain_id();
  void set_allocated_domain_id(std::string* domain_id);
  private:
  const std::string& _internal_domain_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_domain_id(const std::string& value);
  std::string* _internal_mutable_domain_id();
  public:

  // string default_role = 2;
  void clear_default_role();
  const std::string& default_role() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_default_role(ArgT0&& arg0, ArgT... args);
  std::string* mutable_default_role();
  PROTOBUF_NODISCARD std::string* release_default_role();
  void set_allocated_default_role(std::string* default_role);
  private:
  const std::string& _internal_default_role() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_default_role(const std::string& value);
  std::string* _internal_mutable_default_role();
  public:

  // @@protoc_insertion_point(class_scope:iroha.protocol.CreateDomain)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr domain_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr default_role_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_commands_2eproto;
};
// -------------------------------------------------------------------

class RemoveSignatory final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:iroha.protocol.RemoveSignatory) */ {
 public:
  inline RemoveSignatory() : RemoveSignatory(nullptr) {}
  ~RemoveSignatory() override;
  explicit PROTOBUF_CONSTEXPR RemoveSignatory(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RemoveSignatory(const RemoveSignatory& from);
  RemoveSignatory(RemoveSignatory&& from) noexcept
    : RemoveSignatory() {
    *this = ::std::move(from);
  }

  inline RemoveSignatory& operator=(const RemoveSignatory& from) {
    CopyFrom(from);
    return *this;
  }
  inline RemoveSignatory& operator=(RemoveSignatory&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RemoveSignatory& default_instance() {
    return *internal_default_instance();
  }
  static inline const RemoveSignatory* internal_default_instance() {
    return reinterpret_cast<const RemoveSignatory*>(
               &_RemoveSignatory_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(RemoveSignatory& a, RemoveSignatory& b) {
    a.Swap(&b);
  }
  inline void Swap(RemoveSignatory* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RemoveSignatory* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RemoveSignatory* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RemoveSignatory>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RemoveSignatory& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RemoveSignatory& from) {
    RemoveSignatory::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RemoveSignatory* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "iroha.protocol.RemoveSignatory";
  }
  protected:
  explicit RemoveSignatory(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAccountIdFieldNumber = 1,
    kPublicKeyFieldNumber = 2,
  };
  // string account_id = 1;
  void clear_account_id();
  const std::string& account_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_account_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_account_id();
  PROTOBUF_NODISCARD std::string* release_account_id();
  void set_allocated_account_id(std::string* account_id);
  private:
  const std::string& _internal_account_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_account_id(const std::string& value);
  std::string* _internal_mutable_account_id();
  public:

  // string public_key = 2;
  void clear_public_key();
  const std::string& public_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_public_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_public_key();
  PROTOBUF_NODISCARD std::string* release_public_key();
  void set_allocated_public_key(std::string* public_key);
  private:
  const std::string& _internal_public_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_public_key(const std::string& value);
  std::string* _internal_mutable_public_key();
  public:

  // @@protoc_insertion_point(class_scope:iroha.protocol.RemoveSignatory)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr account_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr public_key_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_commands_2eproto;
};
// -------------------------------------------------------------------

class SetAccountQuorum final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:iroha.protocol.SetAccountQuorum) */ {
 public:
  inline SetAccountQuorum() : SetAccountQuorum(nullptr) {}
  ~SetAccountQuorum() override;
  explicit PROTOBUF_CONSTEXPR SetAccountQuorum(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetAccountQuorum(const SetAccountQuorum& from);
  SetAccountQuorum(SetAccountQuorum&& from) noexcept
    : SetAccountQuorum() {
    *this = ::std::move(from);
  }

  inline SetAccountQuorum& operator=(const SetAccountQuorum& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetAccountQuorum& operator=(SetAccountQuorum&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetAccountQuorum& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetAccountQuorum* internal_default_instance() {
    return reinterpret_cast<const SetAccountQuorum*>(
               &_SetAccountQuorum_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(SetAccountQuorum& a, SetAccountQuorum& b) {
    a.Swap(&b);
  }
  inline void Swap(SetAccountQuorum* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetAccountQuorum* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetAccountQuorum* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetAccountQuorum>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetAccountQuorum& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SetAccountQuorum& from) {
    SetAccountQuorum::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetAccountQuorum* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "iroha.protocol.SetAccountQuorum";
  }
  protected:
  explicit SetAccountQuorum(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAccountIdFieldNumber = 1,
    kQuorumFieldNumber = 2,
  };
  // string account_id = 1;
  void clear_account_id();
  const std::string& account_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_account_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_account_id();
  PROTOBUF_NODISCARD std::string* release_account_id();
  void set_allocated_account_id(std::string* account_id);
  private:
  const std::string& _internal_account_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_account_id(const std::string& value);
  std::string* _internal_mutable_account_id();
  public:

  // uint32 quorum = 2;
  void clear_quorum();
  uint32_t quorum() const;
  void set_quorum(uint32_t value);
  private:
  uint32_t _internal_quorum() const;
  void _internal_set_quorum(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:iroha.protocol.SetAccountQuorum)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr account_id_;
    uint32_t quorum_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_commands_2eproto;
};
// -------------------------------------------------------------------

class TransferAsset final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:iroha.protocol.TransferAsset) */ {
 public:
  inline TransferAsset() : TransferAsset(nullptr) {}
  ~TransferAsset() override;
  explicit PROTOBUF_CONSTEXPR TransferAsset(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TransferAsset(const TransferAsset& from);
  TransferAsset(TransferAsset&& from) noexcept
    : TransferAsset() {
    *this = ::std::move(from);
  }

  inline TransferAsset& operator=(const TransferAsset& from) {
    CopyFrom(from);
    return *this;
  }
  inline TransferAsset& operator=(TransferAsset&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TransferAsset& default_instance() {
    return *internal_default_instance();
  }
  static inline const TransferAsset* internal_default_instance() {
    return reinterpret_cast<const TransferAsset*>(
               &_TransferAsset_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(TransferAsset& a, TransferAsset& b) {
    a.Swap(&b);
  }
  inline void Swap(TransferAsset* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TransferAsset* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TransferAsset* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TransferAsset>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TransferAsset& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TransferAsset& from) {
    TransferAsset::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TransferAsset* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "iroha.protocol.TransferAsset";
  }
  protected:
  explicit TransferAsset(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSrcAccountIdFieldNumber = 1,
    kDestAccountIdFieldNumber = 2,
    kAssetIdFieldNumber = 3,
    kDescriptionFieldNumber = 4,
    kAmountFieldNumber = 5,
  };
  // string src_account_id = 1;
  void clear_src_account_id();
  const std::string& src_account_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_src_account_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_src_account_id();
  PROTOBUF_NODISCARD std::string* release_src_account_id();
  void set_allocated_src_account_id(std::string* src_account_id);
  private:
  const std::string& _internal_src_account_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_src_account_id(const std::string& value);
  std::string* _internal_mutable_src_account_id();
  public:

  // string dest_account_id = 2;
  void clear_dest_account_id();
  const std::string& dest_account_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_dest_account_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_dest_account_id();
  PROTOBUF_NODISCARD std::string* release_dest_account_id();
  void set_allocated_dest_account_id(std::string* dest_account_id);
  private:
  const std::string& _internal_dest_account_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_dest_account_id(const std::string& value);
  std::string* _internal_mutable_dest_account_id();
  public:

  // string asset_id = 3;
  void clear_asset_id();
  const std::string& asset_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_asset_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_asset_id();
  PROTOBUF_NODISCARD std::string* release_asset_id();
  void set_allocated_asset_id(std::string* asset_id);
  private:
  const std::string& _internal_asset_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_asset_id(const std::string& value);
  std::string* _internal_mutable_asset_id();
  public:

  // string description = 4;
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // string amount = 5;
  void clear_amount();
  const std::string& amount() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_amount(ArgT0&& arg0, ArgT... args);
  std::string* mutable_amount();
  PROTOBUF_NODISCARD std::string* release_amount();
  void set_allocated_amount(std::string* amount);
  private:
  const std::string& _internal_amount() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_amount(const std::string& value);
  std::string* _internal_mutable_amount();
  public:

  // @@protoc_insertion_point(class_scope:iroha.protocol.TransferAsset)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr src_account_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr dest_account_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr asset_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr amount_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_commands_2eproto;
};
// -------------------------------------------------------------------

class AppendRole final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:iroha.protocol.AppendRole) */ {
 public:
  inline AppendRole() : AppendRole(nullptr) {}
  ~AppendRole() override;
  explicit PROTOBUF_CONSTEXPR AppendRole(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AppendRole(const AppendRole& from);
  AppendRole(AppendRole&& from) noexcept
    : AppendRole() {
    *this = ::std::move(from);
  }

  inline AppendRole& operator=(const AppendRole& from) {
    CopyFrom(from);
    return *this;
  }
  inline AppendRole& operator=(AppendRole&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AppendRole& default_instance() {
    return *internal_default_instance();
  }
  static inline const AppendRole* internal_default_instance() {
    return reinterpret_cast<const AppendRole*>(
               &_AppendRole_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(AppendRole& a, AppendRole& b) {
    a.Swap(&b);
  }
  inline void Swap(AppendRole* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AppendRole* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AppendRole* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AppendRole>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AppendRole& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AppendRole& from) {
    AppendRole::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AppendRole* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "iroha.protocol.AppendRole";
  }
  protected:
  explicit AppendRole(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAccountIdFieldNumber = 1,
    kRoleNameFieldNumber = 2,
  };
  // string account_id = 1;
  void clear_account_id();
  const std::string& account_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_account_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_account_id();
  PROTOBUF_NODISCARD std::string* release_account_id();
  void set_allocated_account_id(std::string* account_id);
  private:
  const std::string& _internal_account_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_account_id(const std::string& value);
  std::string* _internal_mutable_account_id();
  public:

  // string role_name = 2;
  void clear_role_name();
  const std::string& role_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_role_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_role_name();
  PROTOBUF_NODISCARD std::string* release_role_name();
  void set_allocated_role_name(std::string* role_name);
  private:
  const std::string& _internal_role_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_role_name(const std::string& value);
  std::string* _internal_mutable_role_name();
  public:

  // @@protoc_insertion_point(class_scope:iroha.protocol.AppendRole)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr account_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr role_name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_commands_2eproto;
};
// -------------------------------------------------------------------

class DetachRole final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:iroha.protocol.DetachRole) */ {
 public:
  inline DetachRole() : DetachRole(nullptr) {}
  ~DetachRole() override;
  explicit PROTOBUF_CONSTEXPR DetachRole(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DetachRole(const DetachRole& from);
  DetachRole(DetachRole&& from) noexcept
    : DetachRole() {
    *this = ::std::move(from);
  }

  inline DetachRole& operator=(const DetachRole& from) {
    CopyFrom(from);
    return *this;
  }
  inline DetachRole& operator=(DetachRole&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DetachRole& default_instance() {
    return *internal_default_instance();
  }
  static inline const DetachRole* internal_default_instance() {
    return reinterpret_cast<const DetachRole*>(
               &_DetachRole_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(DetachRole& a, DetachRole& b) {
    a.Swap(&b);
  }
  inline void Swap(DetachRole* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DetachRole* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DetachRole* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DetachRole>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DetachRole& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DetachRole& from) {
    DetachRole::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DetachRole* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "iroha.protocol.DetachRole";
  }
  protected:
  explicit DetachRole(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAccountIdFieldNumber = 1,
    kRoleNameFieldNumber = 2,
  };
  // string account_id = 1;
  void clear_account_id();
  const std::string& account_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_account_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_account_id();
  PROTOBUF_NODISCARD std::string* release_account_id();
  void set_allocated_account_id(std::string* account_id);
  private:
  const std::string& _internal_account_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_account_id(const std::string& value);
  std::string* _internal_mutable_account_id();
  public:

  // string role_name = 2;
  void clear_role_name();
  const std::string& role_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_role_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_role_name();
  PROTOBUF_NODISCARD std::string* release_role_name();
  void set_allocated_role_name(std::string* role_name);
  private:
  const std::string& _internal_role_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_role_name(const std::string& value);
  std::string* _internal_mutable_role_name();
  public:

  // @@protoc_insertion_point(class_scope:iroha.protocol.DetachRole)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr account_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr role_name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_commands_2eproto;
};
// -------------------------------------------------------------------

class CreateRole final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:iroha.protocol.CreateRole) */ {
 public:
  inline CreateRole() : CreateRole(nullptr) {}
  ~CreateRole() override;
  explicit PROTOBUF_CONSTEXPR CreateRole(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateRole(const CreateRole& from);
  CreateRole(CreateRole&& from) noexcept
    : CreateRole() {
    *this = ::std::move(from);
  }

  inline CreateRole& operator=(const CreateRole& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateRole& operator=(CreateRole&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateRole& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateRole* internal_default_instance() {
    return reinterpret_cast<const CreateRole*>(
               &_CreateRole_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(CreateRole& a, CreateRole& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateRole* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateRole* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateRole* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateRole>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateRole& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CreateRole& from) {
    CreateRole::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateRole* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "iroha.protocol.CreateRole";
  }
  protected:
  explicit CreateRole(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPermissionsFieldNumber = 2,
    kRoleNameFieldNumber = 1,
  };
  // repeated .iroha.protocol.RolePermission permissions = 2;
  int permissions_size() const;
  private:
  int _internal_permissions_size() const;
  public:
  void clear_permissions();
  private:
  ::iroha::protocol::RolePermission _internal_permissions(int index) const;
  void _internal_add_permissions(::iroha::protocol::RolePermission value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_permissions();
  public:
  ::iroha::protocol::RolePermission permissions(int index) const;
  void set_permissions(int index, ::iroha::protocol::RolePermission value);
  void add_permissions(::iroha::protocol::RolePermission value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& permissions() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_permissions();

  // string role_name = 1;
  void clear_role_name();
  const std::string& role_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_role_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_role_name();
  PROTOBUF_NODISCARD std::string* release_role_name();
  void set_allocated_role_name(std::string* role_name);
  private:
  const std::string& _internal_role_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_role_name(const std::string& value);
  std::string* _internal_mutable_role_name();
  public:

  // @@protoc_insertion_point(class_scope:iroha.protocol.CreateRole)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> permissions_;
    mutable std::atomic<int> _permissions_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr role_name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_commands_2eproto;
};
// -------------------------------------------------------------------

class GrantPermission final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:iroha.protocol.GrantPermission) */ {
 public:
  inline GrantPermission() : GrantPermission(nullptr) {}
  ~GrantPermission() override;
  explicit PROTOBUF_CONSTEXPR GrantPermission(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GrantPermission(const GrantPermission& from);
  GrantPermission(GrantPermission&& from) noexcept
    : GrantPermission() {
    *this = ::std::move(from);
  }

  inline GrantPermission& operator=(const GrantPermission& from) {
    CopyFrom(from);
    return *this;
  }
  inline GrantPermission& operator=(GrantPermission&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GrantPermission& default_instance() {
    return *internal_default_instance();
  }
  static inline const GrantPermission* internal_default_instance() {
    return reinterpret_cast<const GrantPermission*>(
               &_GrantPermission_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(GrantPermission& a, GrantPermission& b) {
    a.Swap(&b);
  }
  inline void Swap(GrantPermission* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GrantPermission* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GrantPermission* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GrantPermission>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GrantPermission& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GrantPermission& from) {
    GrantPermission::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GrantPermission* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "iroha.protocol.GrantPermission";
  }
  protected:
  explicit GrantPermission(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAccountIdFieldNumber = 1,
    kPermissionFieldNumber = 2,
  };
  // string account_id = 1;
  void clear_account_id();
  const std::string& account_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_account_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_account_id();
  PROTOBUF_NODISCARD std::string* release_account_id();
  void set_allocated_account_id(std::string* account_id);
  private:
  const std::string& _internal_account_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_account_id(const std::string& value);
  std::string* _internal_mutable_account_id();
  public:

  // .iroha.protocol.GrantablePermission permission = 2;
  void clear_permission();
  ::iroha::protocol::GrantablePermission permission() const;
  void set_permission(::iroha::protocol::GrantablePermission value);
  private:
  ::iroha::protocol::GrantablePermission _internal_permission() const;
  void _internal_set_permission(::iroha::protocol::GrantablePermission value);
  public:

  // @@protoc_insertion_point(class_scope:iroha.protocol.GrantPermission)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr account_id_;
    int permission_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_commands_2eproto;
};
// -------------------------------------------------------------------

class RevokePermission final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:iroha.protocol.RevokePermission) */ {
 public:
  inline RevokePermission() : RevokePermission(nullptr) {}
  ~RevokePermission() override;
  explicit PROTOBUF_CONSTEXPR RevokePermission(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RevokePermission(const RevokePermission& from);
  RevokePermission(RevokePermission&& from) noexcept
    : RevokePermission() {
    *this = ::std::move(from);
  }

  inline RevokePermission& operator=(const RevokePermission& from) {
    CopyFrom(from);
    return *this;
  }
  inline RevokePermission& operator=(RevokePermission&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RevokePermission& default_instance() {
    return *internal_default_instance();
  }
  static inline const RevokePermission* internal_default_instance() {
    return reinterpret_cast<const RevokePermission*>(
               &_RevokePermission_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(RevokePermission& a, RevokePermission& b) {
    a.Swap(&b);
  }
  inline void Swap(RevokePermission* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RevokePermission* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RevokePermission* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RevokePermission>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RevokePermission& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RevokePermission& from) {
    RevokePermission::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RevokePermission* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "iroha.protocol.RevokePermission";
  }
  protected:
  explicit RevokePermission(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAccountIdFieldNumber = 1,
    kPermissionFieldNumber = 2,
  };
  // string account_id = 1;
  void clear_account_id();
  const std::string& account_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_account_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_account_id();
  PROTOBUF_NODISCARD std::string* release_account_id();
  void set_allocated_account_id(std::string* account_id);
  private:
  const std::string& _internal_account_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_account_id(const std::string& value);
  std::string* _internal_mutable_account_id();
  public:

  // .iroha.protocol.GrantablePermission permission = 2;
  void clear_permission();
  ::iroha::protocol::GrantablePermission permission() const;
  void set_permission(::iroha::protocol::GrantablePermission value);
  private:
  ::iroha::protocol::GrantablePermission _internal_permission() const;
  void _internal_set_permission(::iroha::protocol::GrantablePermission value);
  public:

  // @@protoc_insertion_point(class_scope:iroha.protocol.RevokePermission)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr account_id_;
    int permission_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_commands_2eproto;
};
// -------------------------------------------------------------------

class SubtractAssetQuantity final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:iroha.protocol.SubtractAssetQuantity) */ {
 public:
  inline SubtractAssetQuantity() : SubtractAssetQuantity(nullptr) {}
  ~SubtractAssetQuantity() override;
  explicit PROTOBUF_CONSTEXPR SubtractAssetQuantity(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SubtractAssetQuantity(const SubtractAssetQuantity& from);
  SubtractAssetQuantity(SubtractAssetQuantity&& from) noexcept
    : SubtractAssetQuantity() {
    *this = ::std::move(from);
  }

  inline SubtractAssetQuantity& operator=(const SubtractAssetQuantity& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubtractAssetQuantity& operator=(SubtractAssetQuantity&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubtractAssetQuantity& default_instance() {
    return *internal_default_instance();
  }
  static inline const SubtractAssetQuantity* internal_default_instance() {
    return reinterpret_cast<const SubtractAssetQuantity*>(
               &_SubtractAssetQuantity_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(SubtractAssetQuantity& a, SubtractAssetQuantity& b) {
    a.Swap(&b);
  }
  inline void Swap(SubtractAssetQuantity* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubtractAssetQuantity* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SubtractAssetQuantity* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SubtractAssetQuantity>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SubtractAssetQuantity& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SubtractAssetQuantity& from) {
    SubtractAssetQuantity::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SubtractAssetQuantity* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "iroha.protocol.SubtractAssetQuantity";
  }
  protected:
  explicit SubtractAssetQuantity(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAssetIdFieldNumber = 1,
    kAmountFieldNumber = 2,
  };
  // string asset_id = 1;
  void clear_asset_id();
  const std::string& asset_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_asset_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_asset_id();
  PROTOBUF_NODISCARD std::string* release_asset_id();
  void set_allocated_asset_id(std::string* asset_id);
  private:
  const std::string& _internal_asset_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_asset_id(const std::string& value);
  std::string* _internal_mutable_asset_id();
  public:

  // string amount = 2;
  void clear_amount();
  const std::string& amount() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_amount(ArgT0&& arg0, ArgT... args);
  std::string* mutable_amount();
  PROTOBUF_NODISCARD std::string* release_amount();
  void set_allocated_amount(std::string* amount);
  private:
  const std::string& _internal_amount() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_amount(const std::string& value);
  std::string* _internal_mutable_amount();
  public:

  // @@protoc_insertion_point(class_scope:iroha.protocol.SubtractAssetQuantity)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr asset_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr amount_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_commands_2eproto;
};
// -------------------------------------------------------------------

class CompareAndSetAccountDetail final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:iroha.protocol.CompareAndSetAccountDetail) */ {
 public:
  inline CompareAndSetAccountDetail() : CompareAndSetAccountDetail(nullptr) {}
  ~CompareAndSetAccountDetail() override;
  explicit PROTOBUF_CONSTEXPR CompareAndSetAccountDetail(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CompareAndSetAccountDetail(const CompareAndSetAccountDetail& from);
  CompareAndSetAccountDetail(CompareAndSetAccountDetail&& from) noexcept
    : CompareAndSetAccountDetail() {
    *this = ::std::move(from);
  }

  inline CompareAndSetAccountDetail& operator=(const CompareAndSetAccountDetail& from) {
    CopyFrom(from);
    return *this;
  }
  inline CompareAndSetAccountDetail& operator=(CompareAndSetAccountDetail&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CompareAndSetAccountDetail& default_instance() {
    return *internal_default_instance();
  }
  enum OptOldValueCase {
    kOldValue = 4,
    OPT_OLD_VALUE_NOT_SET = 0,
  };

  static inline const CompareAndSetAccountDetail* internal_default_instance() {
    return reinterpret_cast<const CompareAndSetAccountDetail*>(
               &_CompareAndSetAccountDetail_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(CompareAndSetAccountDetail& a, CompareAndSetAccountDetail& b) {
    a.Swap(&b);
  }
  inline void Swap(CompareAndSetAccountDetail* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CompareAndSetAccountDetail* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CompareAndSetAccountDetail* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CompareAndSetAccountDetail>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CompareAndSetAccountDetail& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CompareAndSetAccountDetail& from) {
    CompareAndSetAccountDetail::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CompareAndSetAccountDetail* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "iroha.protocol.CompareAndSetAccountDetail";
  }
  protected:
  explicit CompareAndSetAccountDetail(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAccountIdFieldNumber = 1,
    kKeyFieldNumber = 2,
    kValueFieldNumber = 3,
    kCheckEmptyFieldNumber = 5,
    kOldValueFieldNumber = 4,
  };
  // string account_id = 1;
  void clear_account_id();
  const std::string& account_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_account_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_account_id();
  PROTOBUF_NODISCARD std::string* release_account_id();
  void set_allocated_account_id(std::string* account_id);
  private:
  const std::string& _internal_account_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_account_id(const std::string& value);
  std::string* _internal_mutable_account_id();
  public:

  // string key = 2;
  void clear_key();
  const std::string& key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // string value = 3;
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // bool check_empty = 5;
  void clear_check_empty();
  bool check_empty() const;
  void set_check_empty(bool value);
  private:
  bool _internal_check_empty() const;
  void _internal_set_check_empty(bool value);
  public:

  // string old_value = 4;
  bool has_old_value() const;
  private:
  bool _internal_has_old_value() const;
  public:
  void clear_old_value();
  const std::string& old_value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_old_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_old_value();
  PROTOBUF_NODISCARD std::string* release_old_value();
  void set_allocated_old_value(std::string* old_value);
  private:
  const std::string& _internal_old_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_old_value(const std::string& value);
  std::string* _internal_mutable_old_value();
  public:

  void clear_opt_old_value();
  OptOldValueCase opt_old_value_case() const;
  // @@protoc_insertion_point(class_scope:iroha.protocol.CompareAndSetAccountDetail)
 private:
  class _Internal;
  void set_has_old_value();

  inline bool has_opt_old_value() const;
  inline void clear_has_opt_old_value();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr account_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
    bool check_empty_;
    union OptOldValueUnion {
      constexpr OptOldValueUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr old_value_;
    } opt_old_value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_commands_2eproto;
};
// -------------------------------------------------------------------

class SetSettingValue final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:iroha.protocol.SetSettingValue) */ {
 public:
  inline SetSettingValue() : SetSettingValue(nullptr) {}
  ~SetSettingValue() override;
  explicit PROTOBUF_CONSTEXPR SetSettingValue(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetSettingValue(const SetSettingValue& from);
  SetSettingValue(SetSettingValue&& from) noexcept
    : SetSettingValue() {
    *this = ::std::move(from);
  }

  inline SetSettingValue& operator=(const SetSettingValue& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetSettingValue& operator=(SetSettingValue&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetSettingValue& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetSettingValue* internal_default_instance() {
    return reinterpret_cast<const SetSettingValue*>(
               &_SetSettingValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(SetSettingValue& a, SetSettingValue& b) {
    a.Swap(&b);
  }
  inline void Swap(SetSettingValue* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetSettingValue* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetSettingValue* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetSettingValue>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetSettingValue& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SetSettingValue& from) {
    SetSettingValue::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetSettingValue* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "iroha.protocol.SetSettingValue";
  }
  protected:
  explicit SetSettingValue(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // string key = 1;
  void clear_key();
  const std::string& key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // string value = 2;
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // @@protoc_insertion_point(class_scope:iroha.protocol.SetSettingValue)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_commands_2eproto;
};
// -------------------------------------------------------------------

class CallEngine final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:iroha.protocol.CallEngine) */ {
 public:
  inline CallEngine() : CallEngine(nullptr) {}
  ~CallEngine() override;
  explicit PROTOBUF_CONSTEXPR CallEngine(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CallEngine(const CallEngine& from);
  CallEngine(CallEngine&& from) noexcept
    : CallEngine() {
    *this = ::std::move(from);
  }

  inline CallEngine& operator=(const CallEngine& from) {
    CopyFrom(from);
    return *this;
  }
  inline CallEngine& operator=(CallEngine&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CallEngine& default_instance() {
    return *internal_default_instance();
  }
  enum OptCalleeCase {
    kCallee = 3,
    OPT_CALLEE_NOT_SET = 0,
  };

  static inline const CallEngine* internal_default_instance() {
    return reinterpret_cast<const CallEngine*>(
               &_CallEngine_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(CallEngine& a, CallEngine& b) {
    a.Swap(&b);
  }
  inline void Swap(CallEngine* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CallEngine* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CallEngine* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CallEngine>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CallEngine& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CallEngine& from) {
    CallEngine::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CallEngine* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "iroha.protocol.CallEngine";
  }
  protected:
  explicit CallEngine(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef CallEngine_EngineType EngineType;
  static constexpr EngineType kSolidity =
    CallEngine_EngineType_kSolidity;
  static inline bool EngineType_IsValid(int value) {
    return CallEngine_EngineType_IsValid(value);
  }
  static constexpr EngineType EngineType_MIN =
    CallEngine_EngineType_EngineType_MIN;
  static constexpr EngineType EngineType_MAX =
    CallEngine_EngineType_EngineType_MAX;
  static constexpr int EngineType_ARRAYSIZE =
    CallEngine_EngineType_EngineType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  EngineType_descriptor() {
    return CallEngine_EngineType_descriptor();
  }
  template<typename T>
  static inline const std::string& EngineType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, EngineType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function EngineType_Name.");
    return CallEngine_EngineType_Name(enum_t_value);
  }
  static inline bool EngineType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      EngineType* value) {
    return CallEngine_EngineType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kCallerFieldNumber = 2,
    kInputFieldNumber = 4,
    kTypeFieldNumber = 1,
    kCalleeFieldNumber = 3,
  };
  // string caller = 2;
  void clear_caller();
  const std::string& caller() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_caller(ArgT0&& arg0, ArgT... args);
  std::string* mutable_caller();
  PROTOBUF_NODISCARD std::string* release_caller();
  void set_allocated_caller(std::string* caller);
  private:
  const std::string& _internal_caller() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_caller(const std::string& value);
  std::string* _internal_mutable_caller();
  public:

  // string input = 4;
  void clear_input();
  const std::string& input() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_input(ArgT0&& arg0, ArgT... args);
  std::string* mutable_input();
  PROTOBUF_NODISCARD std::string* release_input();
  void set_allocated_input(std::string* input);
  private:
  const std::string& _internal_input() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_input(const std::string& value);
  std::string* _internal_mutable_input();
  public:

  // .iroha.protocol.CallEngine.EngineType type = 1;
  void clear_type();
  ::iroha::protocol::CallEngine_EngineType type() const;
  void set_type(::iroha::protocol::CallEngine_EngineType value);
  private:
  ::iroha::protocol::CallEngine_EngineType _internal_type() const;
  void _internal_set_type(::iroha::protocol::CallEngine_EngineType value);
  public:

  // string callee = 3;
  bool has_callee() const;
  private:
  bool _internal_has_callee() const;
  public:
  void clear_callee();
  const std::string& callee() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_callee(ArgT0&& arg0, ArgT... args);
  std::string* mutable_callee();
  PROTOBUF_NODISCARD std::string* release_callee();
  void set_allocated_callee(std::string* callee);
  private:
  const std::string& _internal_callee() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_callee(const std::string& value);
  std::string* _internal_mutable_callee();
  public:

  void clear_opt_callee();
  OptCalleeCase opt_callee_case() const;
  // @@protoc_insertion_point(class_scope:iroha.protocol.CallEngine)
 private:
  class _Internal;
  void set_has_callee();

  inline bool has_opt_callee() const;
  inline void clear_has_opt_callee();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr caller_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr input_;
    int type_;
    union OptCalleeUnion {
      constexpr OptCalleeUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr callee_;
    } opt_callee_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_commands_2eproto;
};
// -------------------------------------------------------------------

class Command final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:iroha.protocol.Command) */ {
 public:
  inline Command() : Command(nullptr) {}
  ~Command() override;
  explicit PROTOBUF_CONSTEXPR Command(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Command(const Command& from);
  Command(Command&& from) noexcept
    : Command() {
    *this = ::std::move(from);
  }

  inline Command& operator=(const Command& from) {
    CopyFrom(from);
    return *this;
  }
  inline Command& operator=(Command&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Command& default_instance() {
    return *internal_default_instance();
  }
  enum CommandCase {
    kAddAssetQuantity = 1,
    kAddPeer = 2,
    kAddSignatory = 3,
    kAppendRole = 4,
    kCreateAccount = 5,
    kCreateAsset = 6,
    kCreateDomain = 7,
    kCreateRole = 8,
    kDetachRole = 9,
    kGrantPermission = 10,
    kRemoveSignatory = 11,
    kRevokePermission = 12,
    kSetAccountDetail = 13,
    kSetAccountQuorum = 14,
    kSubtractAssetQuantity = 15,
    kTransferAsset = 16,
    kRemovePeer = 17,
    kCompareAndSetAccountDetail = 18,
    kSetSettingValue = 19,
    kCallEngine = 20,
    COMMAND_NOT_SET = 0,
  };

  static inline const Command* internal_default_instance() {
    return reinterpret_cast<const Command*>(
               &_Command_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(Command& a, Command& b) {
    a.Swap(&b);
  }
  inline void Swap(Command* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Command* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Command* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Command>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Command& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Command& from) {
    Command::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Command* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "iroha.protocol.Command";
  }
  protected:
  explicit Command(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAddAssetQuantityFieldNumber = 1,
    kAddPeerFieldNumber = 2,
    kAddSignatoryFieldNumber = 3,
    kAppendRoleFieldNumber = 4,
    kCreateAccountFieldNumber = 5,
    kCreateAssetFieldNumber = 6,
    kCreateDomainFieldNumber = 7,
    kCreateRoleFieldNumber = 8,
    kDetachRoleFieldNumber = 9,
    kGrantPermissionFieldNumber = 10,
    kRemoveSignatoryFieldNumber = 11,
    kRevokePermissionFieldNumber = 12,
    kSetAccountDetailFieldNumber = 13,
    kSetAccountQuorumFieldNumber = 14,
    kSubtractAssetQuantityFieldNumber = 15,
    kTransferAssetFieldNumber = 16,
    kRemovePeerFieldNumber = 17,
    kCompareAndSetAccountDetailFieldNumber = 18,
    kSetSettingValueFieldNumber = 19,
    kCallEngineFieldNumber = 20,
  };
  // .iroha.protocol.AddAssetQuantity add_asset_quantity = 1;
  bool has_add_asset_quantity() const;
  private:
  bool _internal_has_add_asset_quantity() const;
  public:
  void clear_add_asset_quantity();
  const ::iroha::protocol::AddAssetQuantity& add_asset_quantity() const;
  PROTOBUF_NODISCARD ::iroha::protocol::AddAssetQuantity* release_add_asset_quantity();
  ::iroha::protocol::AddAssetQuantity* mutable_add_asset_quantity();
  void set_allocated_add_asset_quantity(::iroha::protocol::AddAssetQuantity* add_asset_quantity);
  private:
  const ::iroha::protocol::AddAssetQuantity& _internal_add_asset_quantity() const;
  ::iroha::protocol::AddAssetQuantity* _internal_mutable_add_asset_quantity();
  public:
  void unsafe_arena_set_allocated_add_asset_quantity(
      ::iroha::protocol::AddAssetQuantity* add_asset_quantity);
  ::iroha::protocol::AddAssetQuantity* unsafe_arena_release_add_asset_quantity();

  // .iroha.protocol.AddPeer add_peer = 2;
  bool has_add_peer() const;
  private:
  bool _internal_has_add_peer() const;
  public:
  void clear_add_peer();
  const ::iroha::protocol::AddPeer& add_peer() const;
  PROTOBUF_NODISCARD ::iroha::protocol::AddPeer* release_add_peer();
  ::iroha::protocol::AddPeer* mutable_add_peer();
  void set_allocated_add_peer(::iroha::protocol::AddPeer* add_peer);
  private:
  const ::iroha::protocol::AddPeer& _internal_add_peer() const;
  ::iroha::protocol::AddPeer* _internal_mutable_add_peer();
  public:
  void unsafe_arena_set_allocated_add_peer(
      ::iroha::protocol::AddPeer* add_peer);
  ::iroha::protocol::AddPeer* unsafe_arena_release_add_peer();

  // .iroha.protocol.AddSignatory add_signatory = 3;
  bool has_add_signatory() const;
  private:
  bool _internal_has_add_signatory() const;
  public:
  void clear_add_signatory();
  const ::iroha::protocol::AddSignatory& add_signatory() const;
  PROTOBUF_NODISCARD ::iroha::protocol::AddSignatory* release_add_signatory();
  ::iroha::protocol::AddSignatory* mutable_add_signatory();
  void set_allocated_add_signatory(::iroha::protocol::AddSignatory* add_signatory);
  private:
  const ::iroha::protocol::AddSignatory& _internal_add_signatory() const;
  ::iroha::protocol::AddSignatory* _internal_mutable_add_signatory();
  public:
  void unsafe_arena_set_allocated_add_signatory(
      ::iroha::protocol::AddSignatory* add_signatory);
  ::iroha::protocol::AddSignatory* unsafe_arena_release_add_signatory();

  // .iroha.protocol.AppendRole append_role = 4;
  bool has_append_role() const;
  private:
  bool _internal_has_append_role() const;
  public:
  void clear_append_role();
  const ::iroha::protocol::AppendRole& append_role() const;
  PROTOBUF_NODISCARD ::iroha::protocol::AppendRole* release_append_role();
  ::iroha::protocol::AppendRole* mutable_append_role();
  void set_allocated_append_role(::iroha::protocol::AppendRole* append_role);
  private:
  const ::iroha::protocol::AppendRole& _internal_append_role() const;
  ::iroha::protocol::AppendRole* _internal_mutable_append_role();
  public:
  void unsafe_arena_set_allocated_append_role(
      ::iroha::protocol::AppendRole* append_role);
  ::iroha::protocol::AppendRole* unsafe_arena_release_append_role();

  // .iroha.protocol.CreateAccount create_account = 5;
  bool has_create_account() const;
  private:
  bool _internal_has_create_account() const;
  public:
  void clear_create_account();
  const ::iroha::protocol::CreateAccount& create_account() const;
  PROTOBUF_NODISCARD ::iroha::protocol::CreateAccount* release_create_account();
  ::iroha::protocol::CreateAccount* mutable_create_account();
  void set_allocated_create_account(::iroha::protocol::CreateAccount* create_account);
  private:
  const ::iroha::protocol::CreateAccount& _internal_create_account() const;
  ::iroha::protocol::CreateAccount* _internal_mutable_create_account();
  public:
  void unsafe_arena_set_allocated_create_account(
      ::iroha::protocol::CreateAccount* create_account);
  ::iroha::protocol::CreateAccount* unsafe_arena_release_create_account();

  // .iroha.protocol.CreateAsset create_asset = 6;
  bool has_create_asset() const;
  private:
  bool _internal_has_create_asset() const;
  public:
  void clear_create_asset();
  const ::iroha::protocol::CreateAsset& create_asset() const;
  PROTOBUF_NODISCARD ::iroha::protocol::CreateAsset* release_create_asset();
  ::iroha::protocol::CreateAsset* mutable_create_asset();
  void set_allocated_create_asset(::iroha::protocol::CreateAsset* create_asset);
  private:
  const ::iroha::protocol::CreateAsset& _internal_create_asset() const;
  ::iroha::protocol::CreateAsset* _internal_mutable_create_asset();
  public:
  void unsafe_arena_set_allocated_create_asset(
      ::iroha::protocol::CreateAsset* create_asset);
  ::iroha::protocol::CreateAsset* unsafe_arena_release_create_asset();

  // .iroha.protocol.CreateDomain create_domain = 7;
  bool has_create_domain() const;
  private:
  bool _internal_has_create_domain() const;
  public:
  void clear_create_domain();
  const ::iroha::protocol::CreateDomain& create_domain() const;
  PROTOBUF_NODISCARD ::iroha::protocol::CreateDomain* release_create_domain();
  ::iroha::protocol::CreateDomain* mutable_create_domain();
  void set_allocated_create_domain(::iroha::protocol::CreateDomain* create_domain);
  private:
  const ::iroha::protocol::CreateDomain& _internal_create_domain() const;
  ::iroha::protocol::CreateDomain* _internal_mutable_create_domain();
  public:
  void unsafe_arena_set_allocated_create_domain(
      ::iroha::protocol::CreateDomain* create_domain);
  ::iroha::protocol::CreateDomain* unsafe_arena_release_create_domain();

  // .iroha.protocol.CreateRole create_role = 8;
  bool has_create_role() const;
  private:
  bool _internal_has_create_role() const;
  public:
  void clear_create_role();
  const ::iroha::protocol::CreateRole& create_role() const;
  PROTOBUF_NODISCARD ::iroha::protocol::CreateRole* release_create_role();
  ::iroha::protocol::CreateRole* mutable_create_role();
  void set_allocated_create_role(::iroha::protocol::CreateRole* create_role);
  private:
  const ::iroha::protocol::CreateRole& _internal_create_role() const;
  ::iroha::protocol::CreateRole* _internal_mutable_create_role();
  public:
  void unsafe_arena_set_allocated_create_role(
      ::iroha::protocol::CreateRole* create_role);
  ::iroha::protocol::CreateRole* unsafe_arena_release_create_role();

  // .iroha.protocol.DetachRole detach_role = 9;
  bool has_detach_role() const;
  private:
  bool _internal_has_detach_role() const;
  public:
  void clear_detach_role();
  const ::iroha::protocol::DetachRole& detach_role() const;
  PROTOBUF_NODISCARD ::iroha::protocol::DetachRole* release_detach_role();
  ::iroha::protocol::DetachRole* mutable_detach_role();
  void set_allocated_detach_role(::iroha::protocol::DetachRole* detach_role);
  private:
  const ::iroha::protocol::DetachRole& _internal_detach_role() const;
  ::iroha::protocol::DetachRole* _internal_mutable_detach_role();
  public:
  void unsafe_arena_set_allocated_detach_role(
      ::iroha::protocol::DetachRole* detach_role);
  ::iroha::protocol::DetachRole* unsafe_arena_release_detach_role();

  // .iroha.protocol.GrantPermission grant_permission = 10;
  bool has_grant_permission() const;
  private:
  bool _internal_has_grant_permission() const;
  public:
  void clear_grant_permission();
  const ::iroha::protocol::GrantPermission& grant_permission() const;
  PROTOBUF_NODISCARD ::iroha::protocol::GrantPermission* release_grant_permission();
  ::iroha::protocol::GrantPermission* mutable_grant_permission();
  void set_allocated_grant_permission(::iroha::protocol::GrantPermission* grant_permission);
  private:
  const ::iroha::protocol::GrantPermission& _internal_grant_permission() const;
  ::iroha::protocol::GrantPermission* _internal_mutable_grant_permission();
  public:
  void unsafe_arena_set_allocated_grant_permission(
      ::iroha::protocol::GrantPermission* grant_permission);
  ::iroha::protocol::GrantPermission* unsafe_arena_release_grant_permission();

  // .iroha.protocol.RemoveSignatory remove_signatory = 11;
  bool has_remove_signatory() const;
  private:
  bool _internal_has_remove_signatory() const;
  public:
  void clear_remove_signatory();
  const ::iroha::protocol::RemoveSignatory& remove_signatory() const;
  PROTOBUF_NODISCARD ::iroha::protocol::RemoveSignatory* release_remove_signatory();
  ::iroha::protocol::RemoveSignatory* mutable_remove_signatory();
  void set_allocated_remove_signatory(::iroha::protocol::RemoveSignatory* remove_signatory);
  private:
  const ::iroha::protocol::RemoveSignatory& _internal_remove_signatory() const;
  ::iroha::protocol::RemoveSignatory* _internal_mutable_remove_signatory();
  public:
  void unsafe_arena_set_allocated_remove_signatory(
      ::iroha::protocol::RemoveSignatory* remove_signatory);
  ::iroha::protocol::RemoveSignatory* unsafe_arena_release_remove_signatory();

  // .iroha.protocol.RevokePermission revoke_permission = 12;
  bool has_revoke_permission() const;
  private:
  bool _internal_has_revoke_permission() const;
  public:
  void clear_revoke_permission();
  const ::iroha::protocol::RevokePermission& revoke_permission() const;
  PROTOBUF_NODISCARD ::iroha::protocol::RevokePermission* release_revoke_permission();
  ::iroha::protocol::RevokePermission* mutable_revoke_permission();
  void set_allocated_revoke_permission(::iroha::protocol::RevokePermission* revoke_permission);
  private:
  const ::iroha::protocol::RevokePermission& _internal_revoke_permission() const;
  ::iroha::protocol::RevokePermission* _internal_mutable_revoke_permission();
  public:
  void unsafe_arena_set_allocated_revoke_permission(
      ::iroha::protocol::RevokePermission* revoke_permission);
  ::iroha::protocol::RevokePermission* unsafe_arena_release_revoke_permission();

  // .iroha.protocol.SetAccountDetail set_account_detail = 13;
  bool has_set_account_detail() const;
  private:
  bool _internal_has_set_account_detail() const;
  public:
  void clear_set_account_detail();
  const ::iroha::protocol::SetAccountDetail& set_account_detail() const;
  PROTOBUF_NODISCARD ::iroha::protocol::SetAccountDetail* release_set_account_detail();
  ::iroha::protocol::SetAccountDetail* mutable_set_account_detail();
  void set_allocated_set_account_detail(::iroha::protocol::SetAccountDetail* set_account_detail);
  private:
  const ::iroha::protocol::SetAccountDetail& _internal_set_account_detail() const;
  ::iroha::protocol::SetAccountDetail* _internal_mutable_set_account_detail();
  public:
  void unsafe_arena_set_allocated_set_account_detail(
      ::iroha::protocol::SetAccountDetail* set_account_detail);
  ::iroha::protocol::SetAccountDetail* unsafe_arena_release_set_account_detail();

  // .iroha.protocol.SetAccountQuorum set_account_quorum = 14;
  bool has_set_account_quorum() const;
  private:
  bool _internal_has_set_account_quorum() const;
  public:
  void clear_set_account_quorum();
  const ::iroha::protocol::SetAccountQuorum& set_account_quorum() const;
  PROTOBUF_NODISCARD ::iroha::protocol::SetAccountQuorum* release_set_account_quorum();
  ::iroha::protocol::SetAccountQuorum* mutable_set_account_quorum();
  void set_allocated_set_account_quorum(::iroha::protocol::SetAccountQuorum* set_account_quorum);
  private:
  const ::iroha::protocol::SetAccountQuorum& _internal_set_account_quorum() const;
  ::iroha::protocol::SetAccountQuorum* _internal_mutable_set_account_quorum();
  public:
  void unsafe_arena_set_allocated_set_account_quorum(
      ::iroha::protocol::SetAccountQuorum* set_account_quorum);
  ::iroha::protocol::SetAccountQuorum* unsafe_arena_release_set_account_quorum();

  // .iroha.protocol.SubtractAssetQuantity subtract_asset_quantity = 15;
  bool has_subtract_asset_quantity() const;
  private:
  bool _internal_has_subtract_asset_quantity() const;
  public:
  void clear_subtract_asset_quantity();
  const ::iroha::protocol::SubtractAssetQuantity& subtract_asset_quantity() const;
  PROTOBUF_NODISCARD ::iroha::protocol::SubtractAssetQuantity* release_subtract_asset_quantity();
  ::iroha::protocol::SubtractAssetQuantity* mutable_subtract_asset_quantity();
  void set_allocated_subtract_asset_quantity(::iroha::protocol::SubtractAssetQuantity* subtract_asset_quantity);
  private:
  const ::iroha::protocol::SubtractAssetQuantity& _internal_subtract_asset_quantity() const;
  ::iroha::protocol::SubtractAssetQuantity* _internal_mutable_subtract_asset_quantity();
  public:
  void unsafe_arena_set_allocated_subtract_asset_quantity(
      ::iroha::protocol::SubtractAssetQuantity* subtract_asset_quantity);
  ::iroha::protocol::SubtractAssetQuantity* unsafe_arena_release_subtract_asset_quantity();

  // .iroha.protocol.TransferAsset transfer_asset = 16;
  bool has_transfer_asset() const;
  private:
  bool _internal_has_transfer_asset() const;
  public:
  void clear_transfer_asset();
  const ::iroha::protocol::TransferAsset& transfer_asset() const;
  PROTOBUF_NODISCARD ::iroha::protocol::TransferAsset* release_transfer_asset();
  ::iroha::protocol::TransferAsset* mutable_transfer_asset();
  void set_allocated_transfer_asset(::iroha::protocol::TransferAsset* transfer_asset);
  private:
  const ::iroha::protocol::TransferAsset& _internal_transfer_asset() const;
  ::iroha::protocol::TransferAsset* _internal_mutable_transfer_asset();
  public:
  void unsafe_arena_set_allocated_transfer_asset(
      ::iroha::protocol::TransferAsset* transfer_asset);
  ::iroha::protocol::TransferAsset* unsafe_arena_release_transfer_asset();

  // .iroha.protocol.RemovePeer remove_peer = 17;
  bool has_remove_peer() const;
  private:
  bool _internal_has_remove_peer() const;
  public:
  void clear_remove_peer();
  const ::iroha::protocol::RemovePeer& remove_peer() const;
  PROTOBUF_NODISCARD ::iroha::protocol::RemovePeer* release_remove_peer();
  ::iroha::protocol::RemovePeer* mutable_remove_peer();
  void set_allocated_remove_peer(::iroha::protocol::RemovePeer* remove_peer);
  private:
  const ::iroha::protocol::RemovePeer& _internal_remove_peer() const;
  ::iroha::protocol::RemovePeer* _internal_mutable_remove_peer();
  public:
  void unsafe_arena_set_allocated_remove_peer(
      ::iroha::protocol::RemovePeer* remove_peer);
  ::iroha::protocol::RemovePeer* unsafe_arena_release_remove_peer();

  // .iroha.protocol.CompareAndSetAccountDetail compare_and_set_account_detail = 18;
  bool has_compare_and_set_account_detail() const;
  private:
  bool _internal_has_compare_and_set_account_detail() const;
  public:
  void clear_compare_and_set_account_detail();
  const ::iroha::protocol::CompareAndSetAccountDetail& compare_and_set_account_detail() const;
  PROTOBUF_NODISCARD ::iroha::protocol::CompareAndSetAccountDetail* release_compare_and_set_account_detail();
  ::iroha::protocol::CompareAndSetAccountDetail* mutable_compare_and_set_account_detail();
  void set_allocated_compare_and_set_account_detail(::iroha::protocol::CompareAndSetAccountDetail* compare_and_set_account_detail);
  private:
  const ::iroha::protocol::CompareAndSetAccountDetail& _internal_compare_and_set_account_detail() const;
  ::iroha::protocol::CompareAndSetAccountDetail* _internal_mutable_compare_and_set_account_detail();
  public:
  void unsafe_arena_set_allocated_compare_and_set_account_detail(
      ::iroha::protocol::CompareAndSetAccountDetail* compare_and_set_account_detail);
  ::iroha::protocol::CompareAndSetAccountDetail* unsafe_arena_release_compare_and_set_account_detail();

  // .iroha.protocol.SetSettingValue set_setting_value = 19;
  bool has_set_setting_value() const;
  private:
  bool _internal_has_set_setting_value() const;
  public:
  void clear_set_setting_value();
  const ::iroha::protocol::SetSettingValue& set_setting_value() const;
  PROTOBUF_NODISCARD ::iroha::protocol::SetSettingValue* release_set_setting_value();
  ::iroha::protocol::SetSettingValue* mutable_set_setting_value();
  void set_allocated_set_setting_value(::iroha::protocol::SetSettingValue* set_setting_value);
  private:
  const ::iroha::protocol::SetSettingValue& _internal_set_setting_value() const;
  ::iroha::protocol::SetSettingValue* _internal_mutable_set_setting_value();
  public:
  void unsafe_arena_set_allocated_set_setting_value(
      ::iroha::protocol::SetSettingValue* set_setting_value);
  ::iroha::protocol::SetSettingValue* unsafe_arena_release_set_setting_value();

  // .iroha.protocol.CallEngine call_engine = 20;
  bool has_call_engine() const;
  private:
  bool _internal_has_call_engine() const;
  public:
  void clear_call_engine();
  const ::iroha::protocol::CallEngine& call_engine() const;
  PROTOBUF_NODISCARD ::iroha::protocol::CallEngine* release_call_engine();
  ::iroha::protocol::CallEngine* mutable_call_engine();
  void set_allocated_call_engine(::iroha::protocol::CallEngine* call_engine);
  private:
  const ::iroha::protocol::CallEngine& _internal_call_engine() const;
  ::iroha::protocol::CallEngine* _internal_mutable_call_engine();
  public:
  void unsafe_arena_set_allocated_call_engine(
      ::iroha::protocol::CallEngine* call_engine);
  ::iroha::protocol::CallEngine* unsafe_arena_release_call_engine();

  void clear_command();
  CommandCase command_case() const;
  // @@protoc_insertion_point(class_scope:iroha.protocol.Command)
 private:
  class _Internal;
  void set_has_add_asset_quantity();
  void set_has_add_peer();
  void set_has_add_signatory();
  void set_has_append_role();
  void set_has_create_account();
  void set_has_create_asset();
  void set_has_create_domain();
  void set_has_create_role();
  void set_has_detach_role();
  void set_has_grant_permission();
  void set_has_remove_signatory();
  void set_has_revoke_permission();
  void set_has_set_account_detail();
  void set_has_set_account_quorum();
  void set_has_subtract_asset_quantity();
  void set_has_transfer_asset();
  void set_has_remove_peer();
  void set_has_compare_and_set_account_detail();
  void set_has_set_setting_value();
  void set_has_call_engine();

  inline bool has_command() const;
  inline void clear_has_command();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union CommandUnion {
      constexpr CommandUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::iroha::protocol::AddAssetQuantity* add_asset_quantity_;
      ::iroha::protocol::AddPeer* add_peer_;
      ::iroha::protocol::AddSignatory* add_signatory_;
      ::iroha::protocol::AppendRole* append_role_;
      ::iroha::protocol::CreateAccount* create_account_;
      ::iroha::protocol::CreateAsset* create_asset_;
      ::iroha::protocol::CreateDomain* create_domain_;
      ::iroha::protocol::CreateRole* create_role_;
      ::iroha::protocol::DetachRole* detach_role_;
      ::iroha::protocol::GrantPermission* grant_permission_;
      ::iroha::protocol::RemoveSignatory* remove_signatory_;
      ::iroha::protocol::RevokePermission* revoke_permission_;
      ::iroha::protocol::SetAccountDetail* set_account_detail_;
      ::iroha::protocol::SetAccountQuorum* set_account_quorum_;
      ::iroha::protocol::SubtractAssetQuantity* subtract_asset_quantity_;
      ::iroha::protocol::TransferAsset* transfer_asset_;
      ::iroha::protocol::RemovePeer* remove_peer_;
      ::iroha::protocol::CompareAndSetAccountDetail* compare_and_set_account_detail_;
      ::iroha::protocol::SetSettingValue* set_setting_value_;
      ::iroha::protocol::CallEngine* call_engine_;
    } command_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_commands_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// AddAssetQuantity

// string asset_id = 1;
inline void AddAssetQuantity::clear_asset_id() {
  _impl_.asset_id_.ClearToEmpty();
}
inline const std::string& AddAssetQuantity::asset_id() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.AddAssetQuantity.asset_id)
  return _internal_asset_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AddAssetQuantity::set_asset_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.asset_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:iroha.protocol.AddAssetQuantity.asset_id)
}
inline std::string* AddAssetQuantity::mutable_asset_id() {
  std::string* _s = _internal_mutable_asset_id();
  // @@protoc_insertion_point(field_mutable:iroha.protocol.AddAssetQuantity.asset_id)
  return _s;
}
inline const std::string& AddAssetQuantity::_internal_asset_id() const {
  return _impl_.asset_id_.Get();
}
inline void AddAssetQuantity::_internal_set_asset_id(const std::string& value) {
  
  _impl_.asset_id_.Set(value, GetArenaForAllocation());
}
inline std::string* AddAssetQuantity::_internal_mutable_asset_id() {
  
  return _impl_.asset_id_.Mutable(GetArenaForAllocation());
}
inline std::string* AddAssetQuantity::release_asset_id() {
  // @@protoc_insertion_point(field_release:iroha.protocol.AddAssetQuantity.asset_id)
  return _impl_.asset_id_.Release();
}
inline void AddAssetQuantity::set_allocated_asset_id(std::string* asset_id) {
  if (asset_id != nullptr) {
    
  } else {
    
  }
  _impl_.asset_id_.SetAllocated(asset_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.asset_id_.IsDefault()) {
    _impl_.asset_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:iroha.protocol.AddAssetQuantity.asset_id)
}

// string amount = 2;
inline void AddAssetQuantity::clear_amount() {
  _impl_.amount_.ClearToEmpty();
}
inline const std::string& AddAssetQuantity::amount() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.AddAssetQuantity.amount)
  return _internal_amount();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AddAssetQuantity::set_amount(ArgT0&& arg0, ArgT... args) {
 
 _impl_.amount_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:iroha.protocol.AddAssetQuantity.amount)
}
inline std::string* AddAssetQuantity::mutable_amount() {
  std::string* _s = _internal_mutable_amount();
  // @@protoc_insertion_point(field_mutable:iroha.protocol.AddAssetQuantity.amount)
  return _s;
}
inline const std::string& AddAssetQuantity::_internal_amount() const {
  return _impl_.amount_.Get();
}
inline void AddAssetQuantity::_internal_set_amount(const std::string& value) {
  
  _impl_.amount_.Set(value, GetArenaForAllocation());
}
inline std::string* AddAssetQuantity::_internal_mutable_amount() {
  
  return _impl_.amount_.Mutable(GetArenaForAllocation());
}
inline std::string* AddAssetQuantity::release_amount() {
  // @@protoc_insertion_point(field_release:iroha.protocol.AddAssetQuantity.amount)
  return _impl_.amount_.Release();
}
inline void AddAssetQuantity::set_allocated_amount(std::string* amount) {
  if (amount != nullptr) {
    
  } else {
    
  }
  _impl_.amount_.SetAllocated(amount, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.amount_.IsDefault()) {
    _impl_.amount_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:iroha.protocol.AddAssetQuantity.amount)
}

// -------------------------------------------------------------------

// AddPeer

// .iroha.protocol.Peer peer = 1;
inline bool AddPeer::_internal_has_peer() const {
  return this != internal_default_instance() && _impl_.peer_ != nullptr;
}
inline bool AddPeer::has_peer() const {
  return _internal_has_peer();
}
inline const ::iroha::protocol::Peer& AddPeer::_internal_peer() const {
  const ::iroha::protocol::Peer* p = _impl_.peer_;
  return p != nullptr ? *p : reinterpret_cast<const ::iroha::protocol::Peer&>(
      ::iroha::protocol::_Peer_default_instance_);
}
inline const ::iroha::protocol::Peer& AddPeer::peer() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.AddPeer.peer)
  return _internal_peer();
}
inline void AddPeer::unsafe_arena_set_allocated_peer(
    ::iroha::protocol::Peer* peer) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.peer_);
  }
  _impl_.peer_ = peer;
  if (peer) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:iroha.protocol.AddPeer.peer)
}
inline ::iroha::protocol::Peer* AddPeer::release_peer() {
  
  ::iroha::protocol::Peer* temp = _impl_.peer_;
  _impl_.peer_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::iroha::protocol::Peer* AddPeer::unsafe_arena_release_peer() {
  // @@protoc_insertion_point(field_release:iroha.protocol.AddPeer.peer)
  
  ::iroha::protocol::Peer* temp = _impl_.peer_;
  _impl_.peer_ = nullptr;
  return temp;
}
inline ::iroha::protocol::Peer* AddPeer::_internal_mutable_peer() {
  
  if (_impl_.peer_ == nullptr) {
    auto* p = CreateMaybeMessage<::iroha::protocol::Peer>(GetArenaForAllocation());
    _impl_.peer_ = p;
  }
  return _impl_.peer_;
}
inline ::iroha::protocol::Peer* AddPeer::mutable_peer() {
  ::iroha::protocol::Peer* _msg = _internal_mutable_peer();
  // @@protoc_insertion_point(field_mutable:iroha.protocol.AddPeer.peer)
  return _msg;
}
inline void AddPeer::set_allocated_peer(::iroha::protocol::Peer* peer) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.peer_);
  }
  if (peer) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(peer));
    if (message_arena != submessage_arena) {
      peer = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, peer, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.peer_ = peer;
  // @@protoc_insertion_point(field_set_allocated:iroha.protocol.AddPeer.peer)
}

// -------------------------------------------------------------------

// RemovePeer

// string public_key = 1;
inline void RemovePeer::clear_public_key() {
  _impl_.public_key_.ClearToEmpty();
}
inline const std::string& RemovePeer::public_key() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.RemovePeer.public_key)
  return _internal_public_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RemovePeer::set_public_key(ArgT0&& arg0, ArgT... args) {
 
 _impl_.public_key_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:iroha.protocol.RemovePeer.public_key)
}
inline std::string* RemovePeer::mutable_public_key() {
  std::string* _s = _internal_mutable_public_key();
  // @@protoc_insertion_point(field_mutable:iroha.protocol.RemovePeer.public_key)
  return _s;
}
inline const std::string& RemovePeer::_internal_public_key() const {
  return _impl_.public_key_.Get();
}
inline void RemovePeer::_internal_set_public_key(const std::string& value) {
  
  _impl_.public_key_.Set(value, GetArenaForAllocation());
}
inline std::string* RemovePeer::_internal_mutable_public_key() {
  
  return _impl_.public_key_.Mutable(GetArenaForAllocation());
}
inline std::string* RemovePeer::release_public_key() {
  // @@protoc_insertion_point(field_release:iroha.protocol.RemovePeer.public_key)
  return _impl_.public_key_.Release();
}
inline void RemovePeer::set_allocated_public_key(std::string* public_key) {
  if (public_key != nullptr) {
    
  } else {
    
  }
  _impl_.public_key_.SetAllocated(public_key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.public_key_.IsDefault()) {
    _impl_.public_key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:iroha.protocol.RemovePeer.public_key)
}

// -------------------------------------------------------------------

// AddSignatory

// string account_id = 1;
inline void AddSignatory::clear_account_id() {
  _impl_.account_id_.ClearToEmpty();
}
inline const std::string& AddSignatory::account_id() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.AddSignatory.account_id)
  return _internal_account_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AddSignatory::set_account_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.account_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:iroha.protocol.AddSignatory.account_id)
}
inline std::string* AddSignatory::mutable_account_id() {
  std::string* _s = _internal_mutable_account_id();
  // @@protoc_insertion_point(field_mutable:iroha.protocol.AddSignatory.account_id)
  return _s;
}
inline const std::string& AddSignatory::_internal_account_id() const {
  return _impl_.account_id_.Get();
}
inline void AddSignatory::_internal_set_account_id(const std::string& value) {
  
  _impl_.account_id_.Set(value, GetArenaForAllocation());
}
inline std::string* AddSignatory::_internal_mutable_account_id() {
  
  return _impl_.account_id_.Mutable(GetArenaForAllocation());
}
inline std::string* AddSignatory::release_account_id() {
  // @@protoc_insertion_point(field_release:iroha.protocol.AddSignatory.account_id)
  return _impl_.account_id_.Release();
}
inline void AddSignatory::set_allocated_account_id(std::string* account_id) {
  if (account_id != nullptr) {
    
  } else {
    
  }
  _impl_.account_id_.SetAllocated(account_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.account_id_.IsDefault()) {
    _impl_.account_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:iroha.protocol.AddSignatory.account_id)
}

// string public_key = 2;
inline void AddSignatory::clear_public_key() {
  _impl_.public_key_.ClearToEmpty();
}
inline const std::string& AddSignatory::public_key() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.AddSignatory.public_key)
  return _internal_public_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AddSignatory::set_public_key(ArgT0&& arg0, ArgT... args) {
 
 _impl_.public_key_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:iroha.protocol.AddSignatory.public_key)
}
inline std::string* AddSignatory::mutable_public_key() {
  std::string* _s = _internal_mutable_public_key();
  // @@protoc_insertion_point(field_mutable:iroha.protocol.AddSignatory.public_key)
  return _s;
}
inline const std::string& AddSignatory::_internal_public_key() const {
  return _impl_.public_key_.Get();
}
inline void AddSignatory::_internal_set_public_key(const std::string& value) {
  
  _impl_.public_key_.Set(value, GetArenaForAllocation());
}
inline std::string* AddSignatory::_internal_mutable_public_key() {
  
  return _impl_.public_key_.Mutable(GetArenaForAllocation());
}
inline std::string* AddSignatory::release_public_key() {
  // @@protoc_insertion_point(field_release:iroha.protocol.AddSignatory.public_key)
  return _impl_.public_key_.Release();
}
inline void AddSignatory::set_allocated_public_key(std::string* public_key) {
  if (public_key != nullptr) {
    
  } else {
    
  }
  _impl_.public_key_.SetAllocated(public_key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.public_key_.IsDefault()) {
    _impl_.public_key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:iroha.protocol.AddSignatory.public_key)
}

// -------------------------------------------------------------------

// CreateAsset

// string asset_name = 1;
inline void CreateAsset::clear_asset_name() {
  _impl_.asset_name_.ClearToEmpty();
}
inline const std::string& CreateAsset::asset_name() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.CreateAsset.asset_name)
  return _internal_asset_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateAsset::set_asset_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.asset_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:iroha.protocol.CreateAsset.asset_name)
}
inline std::string* CreateAsset::mutable_asset_name() {
  std::string* _s = _internal_mutable_asset_name();
  // @@protoc_insertion_point(field_mutable:iroha.protocol.CreateAsset.asset_name)
  return _s;
}
inline const std::string& CreateAsset::_internal_asset_name() const {
  return _impl_.asset_name_.Get();
}
inline void CreateAsset::_internal_set_asset_name(const std::string& value) {
  
  _impl_.asset_name_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateAsset::_internal_mutable_asset_name() {
  
  return _impl_.asset_name_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateAsset::release_asset_name() {
  // @@protoc_insertion_point(field_release:iroha.protocol.CreateAsset.asset_name)
  return _impl_.asset_name_.Release();
}
inline void CreateAsset::set_allocated_asset_name(std::string* asset_name) {
  if (asset_name != nullptr) {
    
  } else {
    
  }
  _impl_.asset_name_.SetAllocated(asset_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.asset_name_.IsDefault()) {
    _impl_.asset_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:iroha.protocol.CreateAsset.asset_name)
}

// string domain_id = 2;
inline void CreateAsset::clear_domain_id() {
  _impl_.domain_id_.ClearToEmpty();
}
inline const std::string& CreateAsset::domain_id() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.CreateAsset.domain_id)
  return _internal_domain_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateAsset::set_domain_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.domain_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:iroha.protocol.CreateAsset.domain_id)
}
inline std::string* CreateAsset::mutable_domain_id() {
  std::string* _s = _internal_mutable_domain_id();
  // @@protoc_insertion_point(field_mutable:iroha.protocol.CreateAsset.domain_id)
  return _s;
}
inline const std::string& CreateAsset::_internal_domain_id() const {
  return _impl_.domain_id_.Get();
}
inline void CreateAsset::_internal_set_domain_id(const std::string& value) {
  
  _impl_.domain_id_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateAsset::_internal_mutable_domain_id() {
  
  return _impl_.domain_id_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateAsset::release_domain_id() {
  // @@protoc_insertion_point(field_release:iroha.protocol.CreateAsset.domain_id)
  return _impl_.domain_id_.Release();
}
inline void CreateAsset::set_allocated_domain_id(std::string* domain_id) {
  if (domain_id != nullptr) {
    
  } else {
    
  }
  _impl_.domain_id_.SetAllocated(domain_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.domain_id_.IsDefault()) {
    _impl_.domain_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:iroha.protocol.CreateAsset.domain_id)
}

// uint32 precision = 3;
inline void CreateAsset::clear_precision() {
  _impl_.precision_ = 0u;
}
inline uint32_t CreateAsset::_internal_precision() const {
  return _impl_.precision_;
}
inline uint32_t CreateAsset::precision() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.CreateAsset.precision)
  return _internal_precision();
}
inline void CreateAsset::_internal_set_precision(uint32_t value) {
  
  _impl_.precision_ = value;
}
inline void CreateAsset::set_precision(uint32_t value) {
  _internal_set_precision(value);
  // @@protoc_insertion_point(field_set:iroha.protocol.CreateAsset.precision)
}

// -------------------------------------------------------------------

// CreateAccount

// string account_name = 1;
inline void CreateAccount::clear_account_name() {
  _impl_.account_name_.ClearToEmpty();
}
inline const std::string& CreateAccount::account_name() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.CreateAccount.account_name)
  return _internal_account_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateAccount::set_account_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.account_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:iroha.protocol.CreateAccount.account_name)
}
inline std::string* CreateAccount::mutable_account_name() {
  std::string* _s = _internal_mutable_account_name();
  // @@protoc_insertion_point(field_mutable:iroha.protocol.CreateAccount.account_name)
  return _s;
}
inline const std::string& CreateAccount::_internal_account_name() const {
  return _impl_.account_name_.Get();
}
inline void CreateAccount::_internal_set_account_name(const std::string& value) {
  
  _impl_.account_name_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateAccount::_internal_mutable_account_name() {
  
  return _impl_.account_name_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateAccount::release_account_name() {
  // @@protoc_insertion_point(field_release:iroha.protocol.CreateAccount.account_name)
  return _impl_.account_name_.Release();
}
inline void CreateAccount::set_allocated_account_name(std::string* account_name) {
  if (account_name != nullptr) {
    
  } else {
    
  }
  _impl_.account_name_.SetAllocated(account_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.account_name_.IsDefault()) {
    _impl_.account_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:iroha.protocol.CreateAccount.account_name)
}

// string domain_id = 2;
inline void CreateAccount::clear_domain_id() {
  _impl_.domain_id_.ClearToEmpty();
}
inline const std::string& CreateAccount::domain_id() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.CreateAccount.domain_id)
  return _internal_domain_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateAccount::set_domain_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.domain_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:iroha.protocol.CreateAccount.domain_id)
}
inline std::string* CreateAccount::mutable_domain_id() {
  std::string* _s = _internal_mutable_domain_id();
  // @@protoc_insertion_point(field_mutable:iroha.protocol.CreateAccount.domain_id)
  return _s;
}
inline const std::string& CreateAccount::_internal_domain_id() const {
  return _impl_.domain_id_.Get();
}
inline void CreateAccount::_internal_set_domain_id(const std::string& value) {
  
  _impl_.domain_id_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateAccount::_internal_mutable_domain_id() {
  
  return _impl_.domain_id_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateAccount::release_domain_id() {
  // @@protoc_insertion_point(field_release:iroha.protocol.CreateAccount.domain_id)
  return _impl_.domain_id_.Release();
}
inline void CreateAccount::set_allocated_domain_id(std::string* domain_id) {
  if (domain_id != nullptr) {
    
  } else {
    
  }
  _impl_.domain_id_.SetAllocated(domain_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.domain_id_.IsDefault()) {
    _impl_.domain_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:iroha.protocol.CreateAccount.domain_id)
}

// string public_key = 3;
inline void CreateAccount::clear_public_key() {
  _impl_.public_key_.ClearToEmpty();
}
inline const std::string& CreateAccount::public_key() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.CreateAccount.public_key)
  return _internal_public_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateAccount::set_public_key(ArgT0&& arg0, ArgT... args) {
 
 _impl_.public_key_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:iroha.protocol.CreateAccount.public_key)
}
inline std::string* CreateAccount::mutable_public_key() {
  std::string* _s = _internal_mutable_public_key();
  // @@protoc_insertion_point(field_mutable:iroha.protocol.CreateAccount.public_key)
  return _s;
}
inline const std::string& CreateAccount::_internal_public_key() const {
  return _impl_.public_key_.Get();
}
inline void CreateAccount::_internal_set_public_key(const std::string& value) {
  
  _impl_.public_key_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateAccount::_internal_mutable_public_key() {
  
  return _impl_.public_key_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateAccount::release_public_key() {
  // @@protoc_insertion_point(field_release:iroha.protocol.CreateAccount.public_key)
  return _impl_.public_key_.Release();
}
inline void CreateAccount::set_allocated_public_key(std::string* public_key) {
  if (public_key != nullptr) {
    
  } else {
    
  }
  _impl_.public_key_.SetAllocated(public_key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.public_key_.IsDefault()) {
    _impl_.public_key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:iroha.protocol.CreateAccount.public_key)
}

// -------------------------------------------------------------------

// SetAccountDetail

// string account_id = 1;
inline void SetAccountDetail::clear_account_id() {
  _impl_.account_id_.ClearToEmpty();
}
inline const std::string& SetAccountDetail::account_id() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.SetAccountDetail.account_id)
  return _internal_account_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SetAccountDetail::set_account_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.account_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:iroha.protocol.SetAccountDetail.account_id)
}
inline std::string* SetAccountDetail::mutable_account_id() {
  std::string* _s = _internal_mutable_account_id();
  // @@protoc_insertion_point(field_mutable:iroha.protocol.SetAccountDetail.account_id)
  return _s;
}
inline const std::string& SetAccountDetail::_internal_account_id() const {
  return _impl_.account_id_.Get();
}
inline void SetAccountDetail::_internal_set_account_id(const std::string& value) {
  
  _impl_.account_id_.Set(value, GetArenaForAllocation());
}
inline std::string* SetAccountDetail::_internal_mutable_account_id() {
  
  return _impl_.account_id_.Mutable(GetArenaForAllocation());
}
inline std::string* SetAccountDetail::release_account_id() {
  // @@protoc_insertion_point(field_release:iroha.protocol.SetAccountDetail.account_id)
  return _impl_.account_id_.Release();
}
inline void SetAccountDetail::set_allocated_account_id(std::string* account_id) {
  if (account_id != nullptr) {
    
  } else {
    
  }
  _impl_.account_id_.SetAllocated(account_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.account_id_.IsDefault()) {
    _impl_.account_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:iroha.protocol.SetAccountDetail.account_id)
}

// string key = 2;
inline void SetAccountDetail::clear_key() {
  _impl_.key_.ClearToEmpty();
}
inline const std::string& SetAccountDetail::key() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.SetAccountDetail.key)
  return _internal_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SetAccountDetail::set_key(ArgT0&& arg0, ArgT... args) {
 
 _impl_.key_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:iroha.protocol.SetAccountDetail.key)
}
inline std::string* SetAccountDetail::mutable_key() {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:iroha.protocol.SetAccountDetail.key)
  return _s;
}
inline const std::string& SetAccountDetail::_internal_key() const {
  return _impl_.key_.Get();
}
inline void SetAccountDetail::_internal_set_key(const std::string& value) {
  
  _impl_.key_.Set(value, GetArenaForAllocation());
}
inline std::string* SetAccountDetail::_internal_mutable_key() {
  
  return _impl_.key_.Mutable(GetArenaForAllocation());
}
inline std::string* SetAccountDetail::release_key() {
  // @@protoc_insertion_point(field_release:iroha.protocol.SetAccountDetail.key)
  return _impl_.key_.Release();
}
inline void SetAccountDetail::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    
  } else {
    
  }
  _impl_.key_.SetAllocated(key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.key_.IsDefault()) {
    _impl_.key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:iroha.protocol.SetAccountDetail.key)
}

// string value = 3;
inline void SetAccountDetail::clear_value() {
  _impl_.value_.ClearToEmpty();
}
inline const std::string& SetAccountDetail::value() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.SetAccountDetail.value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SetAccountDetail::set_value(ArgT0&& arg0, ArgT... args) {
 
 _impl_.value_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:iroha.protocol.SetAccountDetail.value)
}
inline std::string* SetAccountDetail::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:iroha.protocol.SetAccountDetail.value)
  return _s;
}
inline const std::string& SetAccountDetail::_internal_value() const {
  return _impl_.value_.Get();
}
inline void SetAccountDetail::_internal_set_value(const std::string& value) {
  
  _impl_.value_.Set(value, GetArenaForAllocation());
}
inline std::string* SetAccountDetail::_internal_mutable_value() {
  
  return _impl_.value_.Mutable(GetArenaForAllocation());
}
inline std::string* SetAccountDetail::release_value() {
  // @@protoc_insertion_point(field_release:iroha.protocol.SetAccountDetail.value)
  return _impl_.value_.Release();
}
inline void SetAccountDetail::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  _impl_.value_.SetAllocated(value, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.value_.IsDefault()) {
    _impl_.value_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:iroha.protocol.SetAccountDetail.value)
}

// -------------------------------------------------------------------

// CreateDomain

// string domain_id = 1;
inline void CreateDomain::clear_domain_id() {
  _impl_.domain_id_.ClearToEmpty();
}
inline const std::string& CreateDomain::domain_id() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.CreateDomain.domain_id)
  return _internal_domain_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateDomain::set_domain_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.domain_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:iroha.protocol.CreateDomain.domain_id)
}
inline std::string* CreateDomain::mutable_domain_id() {
  std::string* _s = _internal_mutable_domain_id();
  // @@protoc_insertion_point(field_mutable:iroha.protocol.CreateDomain.domain_id)
  return _s;
}
inline const std::string& CreateDomain::_internal_domain_id() const {
  return _impl_.domain_id_.Get();
}
inline void CreateDomain::_internal_set_domain_id(const std::string& value) {
  
  _impl_.domain_id_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateDomain::_internal_mutable_domain_id() {
  
  return _impl_.domain_id_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateDomain::release_domain_id() {
  // @@protoc_insertion_point(field_release:iroha.protocol.CreateDomain.domain_id)
  return _impl_.domain_id_.Release();
}
inline void CreateDomain::set_allocated_domain_id(std::string* domain_id) {
  if (domain_id != nullptr) {
    
  } else {
    
  }
  _impl_.domain_id_.SetAllocated(domain_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.domain_id_.IsDefault()) {
    _impl_.domain_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:iroha.protocol.CreateDomain.domain_id)
}

// string default_role = 2;
inline void CreateDomain::clear_default_role() {
  _impl_.default_role_.ClearToEmpty();
}
inline const std::string& CreateDomain::default_role() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.CreateDomain.default_role)
  return _internal_default_role();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateDomain::set_default_role(ArgT0&& arg0, ArgT... args) {
 
 _impl_.default_role_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:iroha.protocol.CreateDomain.default_role)
}
inline std::string* CreateDomain::mutable_default_role() {
  std::string* _s = _internal_mutable_default_role();
  // @@protoc_insertion_point(field_mutable:iroha.protocol.CreateDomain.default_role)
  return _s;
}
inline const std::string& CreateDomain::_internal_default_role() const {
  return _impl_.default_role_.Get();
}
inline void CreateDomain::_internal_set_default_role(const std::string& value) {
  
  _impl_.default_role_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateDomain::_internal_mutable_default_role() {
  
  return _impl_.default_role_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateDomain::release_default_role() {
  // @@protoc_insertion_point(field_release:iroha.protocol.CreateDomain.default_role)
  return _impl_.default_role_.Release();
}
inline void CreateDomain::set_allocated_default_role(std::string* default_role) {
  if (default_role != nullptr) {
    
  } else {
    
  }
  _impl_.default_role_.SetAllocated(default_role, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.default_role_.IsDefault()) {
    _impl_.default_role_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:iroha.protocol.CreateDomain.default_role)
}

// -------------------------------------------------------------------

// RemoveSignatory

// string account_id = 1;
inline void RemoveSignatory::clear_account_id() {
  _impl_.account_id_.ClearToEmpty();
}
inline const std::string& RemoveSignatory::account_id() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.RemoveSignatory.account_id)
  return _internal_account_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RemoveSignatory::set_account_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.account_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:iroha.protocol.RemoveSignatory.account_id)
}
inline std::string* RemoveSignatory::mutable_account_id() {
  std::string* _s = _internal_mutable_account_id();
  // @@protoc_insertion_point(field_mutable:iroha.protocol.RemoveSignatory.account_id)
  return _s;
}
inline const std::string& RemoveSignatory::_internal_account_id() const {
  return _impl_.account_id_.Get();
}
inline void RemoveSignatory::_internal_set_account_id(const std::string& value) {
  
  _impl_.account_id_.Set(value, GetArenaForAllocation());
}
inline std::string* RemoveSignatory::_internal_mutable_account_id() {
  
  return _impl_.account_id_.Mutable(GetArenaForAllocation());
}
inline std::string* RemoveSignatory::release_account_id() {
  // @@protoc_insertion_point(field_release:iroha.protocol.RemoveSignatory.account_id)
  return _impl_.account_id_.Release();
}
inline void RemoveSignatory::set_allocated_account_id(std::string* account_id) {
  if (account_id != nullptr) {
    
  } else {
    
  }
  _impl_.account_id_.SetAllocated(account_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.account_id_.IsDefault()) {
    _impl_.account_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:iroha.protocol.RemoveSignatory.account_id)
}

// string public_key = 2;
inline void RemoveSignatory::clear_public_key() {
  _impl_.public_key_.ClearToEmpty();
}
inline const std::string& RemoveSignatory::public_key() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.RemoveSignatory.public_key)
  return _internal_public_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RemoveSignatory::set_public_key(ArgT0&& arg0, ArgT... args) {
 
 _impl_.public_key_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:iroha.protocol.RemoveSignatory.public_key)
}
inline std::string* RemoveSignatory::mutable_public_key() {
  std::string* _s = _internal_mutable_public_key();
  // @@protoc_insertion_point(field_mutable:iroha.protocol.RemoveSignatory.public_key)
  return _s;
}
inline const std::string& RemoveSignatory::_internal_public_key() const {
  return _impl_.public_key_.Get();
}
inline void RemoveSignatory::_internal_set_public_key(const std::string& value) {
  
  _impl_.public_key_.Set(value, GetArenaForAllocation());
}
inline std::string* RemoveSignatory::_internal_mutable_public_key() {
  
  return _impl_.public_key_.Mutable(GetArenaForAllocation());
}
inline std::string* RemoveSignatory::release_public_key() {
  // @@protoc_insertion_point(field_release:iroha.protocol.RemoveSignatory.public_key)
  return _impl_.public_key_.Release();
}
inline void RemoveSignatory::set_allocated_public_key(std::string* public_key) {
  if (public_key != nullptr) {
    
  } else {
    
  }
  _impl_.public_key_.SetAllocated(public_key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.public_key_.IsDefault()) {
    _impl_.public_key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:iroha.protocol.RemoveSignatory.public_key)
}

// -------------------------------------------------------------------

// SetAccountQuorum

// string account_id = 1;
inline void SetAccountQuorum::clear_account_id() {
  _impl_.account_id_.ClearToEmpty();
}
inline const std::string& SetAccountQuorum::account_id() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.SetAccountQuorum.account_id)
  return _internal_account_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SetAccountQuorum::set_account_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.account_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:iroha.protocol.SetAccountQuorum.account_id)
}
inline std::string* SetAccountQuorum::mutable_account_id() {
  std::string* _s = _internal_mutable_account_id();
  // @@protoc_insertion_point(field_mutable:iroha.protocol.SetAccountQuorum.account_id)
  return _s;
}
inline const std::string& SetAccountQuorum::_internal_account_id() const {
  return _impl_.account_id_.Get();
}
inline void SetAccountQuorum::_internal_set_account_id(const std::string& value) {
  
  _impl_.account_id_.Set(value, GetArenaForAllocation());
}
inline std::string* SetAccountQuorum::_internal_mutable_account_id() {
  
  return _impl_.account_id_.Mutable(GetArenaForAllocation());
}
inline std::string* SetAccountQuorum::release_account_id() {
  // @@protoc_insertion_point(field_release:iroha.protocol.SetAccountQuorum.account_id)
  return _impl_.account_id_.Release();
}
inline void SetAccountQuorum::set_allocated_account_id(std::string* account_id) {
  if (account_id != nullptr) {
    
  } else {
    
  }
  _impl_.account_id_.SetAllocated(account_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.account_id_.IsDefault()) {
    _impl_.account_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:iroha.protocol.SetAccountQuorum.account_id)
}

// uint32 quorum = 2;
inline void SetAccountQuorum::clear_quorum() {
  _impl_.quorum_ = 0u;
}
inline uint32_t SetAccountQuorum::_internal_quorum() const {
  return _impl_.quorum_;
}
inline uint32_t SetAccountQuorum::quorum() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.SetAccountQuorum.quorum)
  return _internal_quorum();
}
inline void SetAccountQuorum::_internal_set_quorum(uint32_t value) {
  
  _impl_.quorum_ = value;
}
inline void SetAccountQuorum::set_quorum(uint32_t value) {
  _internal_set_quorum(value);
  // @@protoc_insertion_point(field_set:iroha.protocol.SetAccountQuorum.quorum)
}

// -------------------------------------------------------------------

// TransferAsset

// string src_account_id = 1;
inline void TransferAsset::clear_src_account_id() {
  _impl_.src_account_id_.ClearToEmpty();
}
inline const std::string& TransferAsset::src_account_id() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.TransferAsset.src_account_id)
  return _internal_src_account_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TransferAsset::set_src_account_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.src_account_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:iroha.protocol.TransferAsset.src_account_id)
}
inline std::string* TransferAsset::mutable_src_account_id() {
  std::string* _s = _internal_mutable_src_account_id();
  // @@protoc_insertion_point(field_mutable:iroha.protocol.TransferAsset.src_account_id)
  return _s;
}
inline const std::string& TransferAsset::_internal_src_account_id() const {
  return _impl_.src_account_id_.Get();
}
inline void TransferAsset::_internal_set_src_account_id(const std::string& value) {
  
  _impl_.src_account_id_.Set(value, GetArenaForAllocation());
}
inline std::string* TransferAsset::_internal_mutable_src_account_id() {
  
  return _impl_.src_account_id_.Mutable(GetArenaForAllocation());
}
inline std::string* TransferAsset::release_src_account_id() {
  // @@protoc_insertion_point(field_release:iroha.protocol.TransferAsset.src_account_id)
  return _impl_.src_account_id_.Release();
}
inline void TransferAsset::set_allocated_src_account_id(std::string* src_account_id) {
  if (src_account_id != nullptr) {
    
  } else {
    
  }
  _impl_.src_account_id_.SetAllocated(src_account_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.src_account_id_.IsDefault()) {
    _impl_.src_account_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:iroha.protocol.TransferAsset.src_account_id)
}

// string dest_account_id = 2;
inline void TransferAsset::clear_dest_account_id() {
  _impl_.dest_account_id_.ClearToEmpty();
}
inline const std::string& TransferAsset::dest_account_id() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.TransferAsset.dest_account_id)
  return _internal_dest_account_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TransferAsset::set_dest_account_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.dest_account_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:iroha.protocol.TransferAsset.dest_account_id)
}
inline std::string* TransferAsset::mutable_dest_account_id() {
  std::string* _s = _internal_mutable_dest_account_id();
  // @@protoc_insertion_point(field_mutable:iroha.protocol.TransferAsset.dest_account_id)
  return _s;
}
inline const std::string& TransferAsset::_internal_dest_account_id() const {
  return _impl_.dest_account_id_.Get();
}
inline void TransferAsset::_internal_set_dest_account_id(const std::string& value) {
  
  _impl_.dest_account_id_.Set(value, GetArenaForAllocation());
}
inline std::string* TransferAsset::_internal_mutable_dest_account_id() {
  
  return _impl_.dest_account_id_.Mutable(GetArenaForAllocation());
}
inline std::string* TransferAsset::release_dest_account_id() {
  // @@protoc_insertion_point(field_release:iroha.protocol.TransferAsset.dest_account_id)
  return _impl_.dest_account_id_.Release();
}
inline void TransferAsset::set_allocated_dest_account_id(std::string* dest_account_id) {
  if (dest_account_id != nullptr) {
    
  } else {
    
  }
  _impl_.dest_account_id_.SetAllocated(dest_account_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.dest_account_id_.IsDefault()) {
    _impl_.dest_account_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:iroha.protocol.TransferAsset.dest_account_id)
}

// string asset_id = 3;
inline void TransferAsset::clear_asset_id() {
  _impl_.asset_id_.ClearToEmpty();
}
inline const std::string& TransferAsset::asset_id() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.TransferAsset.asset_id)
  return _internal_asset_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TransferAsset::set_asset_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.asset_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:iroha.protocol.TransferAsset.asset_id)
}
inline std::string* TransferAsset::mutable_asset_id() {
  std::string* _s = _internal_mutable_asset_id();
  // @@protoc_insertion_point(field_mutable:iroha.protocol.TransferAsset.asset_id)
  return _s;
}
inline const std::string& TransferAsset::_internal_asset_id() const {
  return _impl_.asset_id_.Get();
}
inline void TransferAsset::_internal_set_asset_id(const std::string& value) {
  
  _impl_.asset_id_.Set(value, GetArenaForAllocation());
}
inline std::string* TransferAsset::_internal_mutable_asset_id() {
  
  return _impl_.asset_id_.Mutable(GetArenaForAllocation());
}
inline std::string* TransferAsset::release_asset_id() {
  // @@protoc_insertion_point(field_release:iroha.protocol.TransferAsset.asset_id)
  return _impl_.asset_id_.Release();
}
inline void TransferAsset::set_allocated_asset_id(std::string* asset_id) {
  if (asset_id != nullptr) {
    
  } else {
    
  }
  _impl_.asset_id_.SetAllocated(asset_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.asset_id_.IsDefault()) {
    _impl_.asset_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:iroha.protocol.TransferAsset.asset_id)
}

// string description = 4;
inline void TransferAsset::clear_description() {
  _impl_.description_.ClearToEmpty();
}
inline const std::string& TransferAsset::description() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.TransferAsset.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TransferAsset::set_description(ArgT0&& arg0, ArgT... args) {
 
 _impl_.description_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:iroha.protocol.TransferAsset.description)
}
inline std::string* TransferAsset::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:iroha.protocol.TransferAsset.description)
  return _s;
}
inline const std::string& TransferAsset::_internal_description() const {
  return _impl_.description_.Get();
}
inline void TransferAsset::_internal_set_description(const std::string& value) {
  
  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* TransferAsset::_internal_mutable_description() {
  
  return _impl_.description_.Mutable(GetArenaForAllocation());
}
inline std::string* TransferAsset::release_description() {
  // @@protoc_insertion_point(field_release:iroha.protocol.TransferAsset.description)
  return _impl_.description_.Release();
}
inline void TransferAsset::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  _impl_.description_.SetAllocated(description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:iroha.protocol.TransferAsset.description)
}

// string amount = 5;
inline void TransferAsset::clear_amount() {
  _impl_.amount_.ClearToEmpty();
}
inline const std::string& TransferAsset::amount() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.TransferAsset.amount)
  return _internal_amount();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TransferAsset::set_amount(ArgT0&& arg0, ArgT... args) {
 
 _impl_.amount_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:iroha.protocol.TransferAsset.amount)
}
inline std::string* TransferAsset::mutable_amount() {
  std::string* _s = _internal_mutable_amount();
  // @@protoc_insertion_point(field_mutable:iroha.protocol.TransferAsset.amount)
  return _s;
}
inline const std::string& TransferAsset::_internal_amount() const {
  return _impl_.amount_.Get();
}
inline void TransferAsset::_internal_set_amount(const std::string& value) {
  
  _impl_.amount_.Set(value, GetArenaForAllocation());
}
inline std::string* TransferAsset::_internal_mutable_amount() {
  
  return _impl_.amount_.Mutable(GetArenaForAllocation());
}
inline std::string* TransferAsset::release_amount() {
  // @@protoc_insertion_point(field_release:iroha.protocol.TransferAsset.amount)
  return _impl_.amount_.Release();
}
inline void TransferAsset::set_allocated_amount(std::string* amount) {
  if (amount != nullptr) {
    
  } else {
    
  }
  _impl_.amount_.SetAllocated(amount, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.amount_.IsDefault()) {
    _impl_.amount_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:iroha.protocol.TransferAsset.amount)
}

// -------------------------------------------------------------------

// AppendRole

// string account_id = 1;
inline void AppendRole::clear_account_id() {
  _impl_.account_id_.ClearToEmpty();
}
inline const std::string& AppendRole::account_id() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.AppendRole.account_id)
  return _internal_account_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AppendRole::set_account_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.account_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:iroha.protocol.AppendRole.account_id)
}
inline std::string* AppendRole::mutable_account_id() {
  std::string* _s = _internal_mutable_account_id();
  // @@protoc_insertion_point(field_mutable:iroha.protocol.AppendRole.account_id)
  return _s;
}
inline const std::string& AppendRole::_internal_account_id() const {
  return _impl_.account_id_.Get();
}
inline void AppendRole::_internal_set_account_id(const std::string& value) {
  
  _impl_.account_id_.Set(value, GetArenaForAllocation());
}
inline std::string* AppendRole::_internal_mutable_account_id() {
  
  return _impl_.account_id_.Mutable(GetArenaForAllocation());
}
inline std::string* AppendRole::release_account_id() {
  // @@protoc_insertion_point(field_release:iroha.protocol.AppendRole.account_id)
  return _impl_.account_id_.Release();
}
inline void AppendRole::set_allocated_account_id(std::string* account_id) {
  if (account_id != nullptr) {
    
  } else {
    
  }
  _impl_.account_id_.SetAllocated(account_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.account_id_.IsDefault()) {
    _impl_.account_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:iroha.protocol.AppendRole.account_id)
}

// string role_name = 2;
inline void AppendRole::clear_role_name() {
  _impl_.role_name_.ClearToEmpty();
}
inline const std::string& AppendRole::role_name() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.AppendRole.role_name)
  return _internal_role_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AppendRole::set_role_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.role_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:iroha.protocol.AppendRole.role_name)
}
inline std::string* AppendRole::mutable_role_name() {
  std::string* _s = _internal_mutable_role_name();
  // @@protoc_insertion_point(field_mutable:iroha.protocol.AppendRole.role_name)
  return _s;
}
inline const std::string& AppendRole::_internal_role_name() const {
  return _impl_.role_name_.Get();
}
inline void AppendRole::_internal_set_role_name(const std::string& value) {
  
  _impl_.role_name_.Set(value, GetArenaForAllocation());
}
inline std::string* AppendRole::_internal_mutable_role_name() {
  
  return _impl_.role_name_.Mutable(GetArenaForAllocation());
}
inline std::string* AppendRole::release_role_name() {
  // @@protoc_insertion_point(field_release:iroha.protocol.AppendRole.role_name)
  return _impl_.role_name_.Release();
}
inline void AppendRole::set_allocated_role_name(std::string* role_name) {
  if (role_name != nullptr) {
    
  } else {
    
  }
  _impl_.role_name_.SetAllocated(role_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.role_name_.IsDefault()) {
    _impl_.role_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:iroha.protocol.AppendRole.role_name)
}

// -------------------------------------------------------------------

// DetachRole

// string account_id = 1;
inline void DetachRole::clear_account_id() {
  _impl_.account_id_.ClearToEmpty();
}
inline const std::string& DetachRole::account_id() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.DetachRole.account_id)
  return _internal_account_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DetachRole::set_account_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.account_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:iroha.protocol.DetachRole.account_id)
}
inline std::string* DetachRole::mutable_account_id() {
  std::string* _s = _internal_mutable_account_id();
  // @@protoc_insertion_point(field_mutable:iroha.protocol.DetachRole.account_id)
  return _s;
}
inline const std::string& DetachRole::_internal_account_id() const {
  return _impl_.account_id_.Get();
}
inline void DetachRole::_internal_set_account_id(const std::string& value) {
  
  _impl_.account_id_.Set(value, GetArenaForAllocation());
}
inline std::string* DetachRole::_internal_mutable_account_id() {
  
  return _impl_.account_id_.Mutable(GetArenaForAllocation());
}
inline std::string* DetachRole::release_account_id() {
  // @@protoc_insertion_point(field_release:iroha.protocol.DetachRole.account_id)
  return _impl_.account_id_.Release();
}
inline void DetachRole::set_allocated_account_id(std::string* account_id) {
  if (account_id != nullptr) {
    
  } else {
    
  }
  _impl_.account_id_.SetAllocated(account_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.account_id_.IsDefault()) {
    _impl_.account_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:iroha.protocol.DetachRole.account_id)
}

// string role_name = 2;
inline void DetachRole::clear_role_name() {
  _impl_.role_name_.ClearToEmpty();
}
inline const std::string& DetachRole::role_name() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.DetachRole.role_name)
  return _internal_role_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DetachRole::set_role_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.role_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:iroha.protocol.DetachRole.role_name)
}
inline std::string* DetachRole::mutable_role_name() {
  std::string* _s = _internal_mutable_role_name();
  // @@protoc_insertion_point(field_mutable:iroha.protocol.DetachRole.role_name)
  return _s;
}
inline const std::string& DetachRole::_internal_role_name() const {
  return _impl_.role_name_.Get();
}
inline void DetachRole::_internal_set_role_name(const std::string& value) {
  
  _impl_.role_name_.Set(value, GetArenaForAllocation());
}
inline std::string* DetachRole::_internal_mutable_role_name() {
  
  return _impl_.role_name_.Mutable(GetArenaForAllocation());
}
inline std::string* DetachRole::release_role_name() {
  // @@protoc_insertion_point(field_release:iroha.protocol.DetachRole.role_name)
  return _impl_.role_name_.Release();
}
inline void DetachRole::set_allocated_role_name(std::string* role_name) {
  if (role_name != nullptr) {
    
  } else {
    
  }
  _impl_.role_name_.SetAllocated(role_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.role_name_.IsDefault()) {
    _impl_.role_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:iroha.protocol.DetachRole.role_name)
}

// -------------------------------------------------------------------

// CreateRole

// string role_name = 1;
inline void CreateRole::clear_role_name() {
  _impl_.role_name_.ClearToEmpty();
}
inline const std::string& CreateRole::role_name() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.CreateRole.role_name)
  return _internal_role_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateRole::set_role_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.role_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:iroha.protocol.CreateRole.role_name)
}
inline std::string* CreateRole::mutable_role_name() {
  std::string* _s = _internal_mutable_role_name();
  // @@protoc_insertion_point(field_mutable:iroha.protocol.CreateRole.role_name)
  return _s;
}
inline const std::string& CreateRole::_internal_role_name() const {
  return _impl_.role_name_.Get();
}
inline void CreateRole::_internal_set_role_name(const std::string& value) {
  
  _impl_.role_name_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateRole::_internal_mutable_role_name() {
  
  return _impl_.role_name_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateRole::release_role_name() {
  // @@protoc_insertion_point(field_release:iroha.protocol.CreateRole.role_name)
  return _impl_.role_name_.Release();
}
inline void CreateRole::set_allocated_role_name(std::string* role_name) {
  if (role_name != nullptr) {
    
  } else {
    
  }
  _impl_.role_name_.SetAllocated(role_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.role_name_.IsDefault()) {
    _impl_.role_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:iroha.protocol.CreateRole.role_name)
}

// repeated .iroha.protocol.RolePermission permissions = 2;
inline int CreateRole::_internal_permissions_size() const {
  return _impl_.permissions_.size();
}
inline int CreateRole::permissions_size() const {
  return _internal_permissions_size();
}
inline void CreateRole::clear_permissions() {
  _impl_.permissions_.Clear();
}
inline ::iroha::protocol::RolePermission CreateRole::_internal_permissions(int index) const {
  return static_cast< ::iroha::protocol::RolePermission >(_impl_.permissions_.Get(index));
}
inline ::iroha::protocol::RolePermission CreateRole::permissions(int index) const {
  // @@protoc_insertion_point(field_get:iroha.protocol.CreateRole.permissions)
  return _internal_permissions(index);
}
inline void CreateRole::set_permissions(int index, ::iroha::protocol::RolePermission value) {
  _impl_.permissions_.Set(index, value);
  // @@protoc_insertion_point(field_set:iroha.protocol.CreateRole.permissions)
}
inline void CreateRole::_internal_add_permissions(::iroha::protocol::RolePermission value) {
  _impl_.permissions_.Add(value);
}
inline void CreateRole::add_permissions(::iroha::protocol::RolePermission value) {
  _internal_add_permissions(value);
  // @@protoc_insertion_point(field_add:iroha.protocol.CreateRole.permissions)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>&
CreateRole::permissions() const {
  // @@protoc_insertion_point(field_list:iroha.protocol.CreateRole.permissions)
  return _impl_.permissions_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
CreateRole::_internal_mutable_permissions() {
  return &_impl_.permissions_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
CreateRole::mutable_permissions() {
  // @@protoc_insertion_point(field_mutable_list:iroha.protocol.CreateRole.permissions)
  return _internal_mutable_permissions();
}

// -------------------------------------------------------------------

// GrantPermission

// string account_id = 1;
inline void GrantPermission::clear_account_id() {
  _impl_.account_id_.ClearToEmpty();
}
inline const std::string& GrantPermission::account_id() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.GrantPermission.account_id)
  return _internal_account_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GrantPermission::set_account_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.account_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:iroha.protocol.GrantPermission.account_id)
}
inline std::string* GrantPermission::mutable_account_id() {
  std::string* _s = _internal_mutable_account_id();
  // @@protoc_insertion_point(field_mutable:iroha.protocol.GrantPermission.account_id)
  return _s;
}
inline const std::string& GrantPermission::_internal_account_id() const {
  return _impl_.account_id_.Get();
}
inline void GrantPermission::_internal_set_account_id(const std::string& value) {
  
  _impl_.account_id_.Set(value, GetArenaForAllocation());
}
inline std::string* GrantPermission::_internal_mutable_account_id() {
  
  return _impl_.account_id_.Mutable(GetArenaForAllocation());
}
inline std::string* GrantPermission::release_account_id() {
  // @@protoc_insertion_point(field_release:iroha.protocol.GrantPermission.account_id)
  return _impl_.account_id_.Release();
}
inline void GrantPermission::set_allocated_account_id(std::string* account_id) {
  if (account_id != nullptr) {
    
  } else {
    
  }
  _impl_.account_id_.SetAllocated(account_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.account_id_.IsDefault()) {
    _impl_.account_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:iroha.protocol.GrantPermission.account_id)
}

// .iroha.protocol.GrantablePermission permission = 2;
inline void GrantPermission::clear_permission() {
  _impl_.permission_ = 0;
}
inline ::iroha::protocol::GrantablePermission GrantPermission::_internal_permission() const {
  return static_cast< ::iroha::protocol::GrantablePermission >(_impl_.permission_);
}
inline ::iroha::protocol::GrantablePermission GrantPermission::permission() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.GrantPermission.permission)
  return _internal_permission();
}
inline void GrantPermission::_internal_set_permission(::iroha::protocol::GrantablePermission value) {
  
  _impl_.permission_ = value;
}
inline void GrantPermission::set_permission(::iroha::protocol::GrantablePermission value) {
  _internal_set_permission(value);
  // @@protoc_insertion_point(field_set:iroha.protocol.GrantPermission.permission)
}

// -------------------------------------------------------------------

// RevokePermission

// string account_id = 1;
inline void RevokePermission::clear_account_id() {
  _impl_.account_id_.ClearToEmpty();
}
inline const std::string& RevokePermission::account_id() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.RevokePermission.account_id)
  return _internal_account_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RevokePermission::set_account_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.account_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:iroha.protocol.RevokePermission.account_id)
}
inline std::string* RevokePermission::mutable_account_id() {
  std::string* _s = _internal_mutable_account_id();
  // @@protoc_insertion_point(field_mutable:iroha.protocol.RevokePermission.account_id)
  return _s;
}
inline const std::string& RevokePermission::_internal_account_id() const {
  return _impl_.account_id_.Get();
}
inline void RevokePermission::_internal_set_account_id(const std::string& value) {
  
  _impl_.account_id_.Set(value, GetArenaForAllocation());
}
inline std::string* RevokePermission::_internal_mutable_account_id() {
  
  return _impl_.account_id_.Mutable(GetArenaForAllocation());
}
inline std::string* RevokePermission::release_account_id() {
  // @@protoc_insertion_point(field_release:iroha.protocol.RevokePermission.account_id)
  return _impl_.account_id_.Release();
}
inline void RevokePermission::set_allocated_account_id(std::string* account_id) {
  if (account_id != nullptr) {
    
  } else {
    
  }
  _impl_.account_id_.SetAllocated(account_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.account_id_.IsDefault()) {
    _impl_.account_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:iroha.protocol.RevokePermission.account_id)
}

// .iroha.protocol.GrantablePermission permission = 2;
inline void RevokePermission::clear_permission() {
  _impl_.permission_ = 0;
}
inline ::iroha::protocol::GrantablePermission RevokePermission::_internal_permission() const {
  return static_cast< ::iroha::protocol::GrantablePermission >(_impl_.permission_);
}
inline ::iroha::protocol::GrantablePermission RevokePermission::permission() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.RevokePermission.permission)
  return _internal_permission();
}
inline void RevokePermission::_internal_set_permission(::iroha::protocol::GrantablePermission value) {
  
  _impl_.permission_ = value;
}
inline void RevokePermission::set_permission(::iroha::protocol::GrantablePermission value) {
  _internal_set_permission(value);
  // @@protoc_insertion_point(field_set:iroha.protocol.RevokePermission.permission)
}

// -------------------------------------------------------------------

// SubtractAssetQuantity

// string asset_id = 1;
inline void SubtractAssetQuantity::clear_asset_id() {
  _impl_.asset_id_.ClearToEmpty();
}
inline const std::string& SubtractAssetQuantity::asset_id() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.SubtractAssetQuantity.asset_id)
  return _internal_asset_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SubtractAssetQuantity::set_asset_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.asset_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:iroha.protocol.SubtractAssetQuantity.asset_id)
}
inline std::string* SubtractAssetQuantity::mutable_asset_id() {
  std::string* _s = _internal_mutable_asset_id();
  // @@protoc_insertion_point(field_mutable:iroha.protocol.SubtractAssetQuantity.asset_id)
  return _s;
}
inline const std::string& SubtractAssetQuantity::_internal_asset_id() const {
  return _impl_.asset_id_.Get();
}
inline void SubtractAssetQuantity::_internal_set_asset_id(const std::string& value) {
  
  _impl_.asset_id_.Set(value, GetArenaForAllocation());
}
inline std::string* SubtractAssetQuantity::_internal_mutable_asset_id() {
  
  return _impl_.asset_id_.Mutable(GetArenaForAllocation());
}
inline std::string* SubtractAssetQuantity::release_asset_id() {
  // @@protoc_insertion_point(field_release:iroha.protocol.SubtractAssetQuantity.asset_id)
  return _impl_.asset_id_.Release();
}
inline void SubtractAssetQuantity::set_allocated_asset_id(std::string* asset_id) {
  if (asset_id != nullptr) {
    
  } else {
    
  }
  _impl_.asset_id_.SetAllocated(asset_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.asset_id_.IsDefault()) {
    _impl_.asset_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:iroha.protocol.SubtractAssetQuantity.asset_id)
}

// string amount = 2;
inline void SubtractAssetQuantity::clear_amount() {
  _impl_.amount_.ClearToEmpty();
}
inline const std::string& SubtractAssetQuantity::amount() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.SubtractAssetQuantity.amount)
  return _internal_amount();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SubtractAssetQuantity::set_amount(ArgT0&& arg0, ArgT... args) {
 
 _impl_.amount_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:iroha.protocol.SubtractAssetQuantity.amount)
}
inline std::string* SubtractAssetQuantity::mutable_amount() {
  std::string* _s = _internal_mutable_amount();
  // @@protoc_insertion_point(field_mutable:iroha.protocol.SubtractAssetQuantity.amount)
  return _s;
}
inline const std::string& SubtractAssetQuantity::_internal_amount() const {
  return _impl_.amount_.Get();
}
inline void SubtractAssetQuantity::_internal_set_amount(const std::string& value) {
  
  _impl_.amount_.Set(value, GetArenaForAllocation());
}
inline std::string* SubtractAssetQuantity::_internal_mutable_amount() {
  
  return _impl_.amount_.Mutable(GetArenaForAllocation());
}
inline std::string* SubtractAssetQuantity::release_amount() {
  // @@protoc_insertion_point(field_release:iroha.protocol.SubtractAssetQuantity.amount)
  return _impl_.amount_.Release();
}
inline void SubtractAssetQuantity::set_allocated_amount(std::string* amount) {
  if (amount != nullptr) {
    
  } else {
    
  }
  _impl_.amount_.SetAllocated(amount, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.amount_.IsDefault()) {
    _impl_.amount_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:iroha.protocol.SubtractAssetQuantity.amount)
}

// -------------------------------------------------------------------

// CompareAndSetAccountDetail

// string account_id = 1;
inline void CompareAndSetAccountDetail::clear_account_id() {
  _impl_.account_id_.ClearToEmpty();
}
inline const std::string& CompareAndSetAccountDetail::account_id() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.CompareAndSetAccountDetail.account_id)
  return _internal_account_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CompareAndSetAccountDetail::set_account_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.account_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:iroha.protocol.CompareAndSetAccountDetail.account_id)
}
inline std::string* CompareAndSetAccountDetail::mutable_account_id() {
  std::string* _s = _internal_mutable_account_id();
  // @@protoc_insertion_point(field_mutable:iroha.protocol.CompareAndSetAccountDetail.account_id)
  return _s;
}
inline const std::string& CompareAndSetAccountDetail::_internal_account_id() const {
  return _impl_.account_id_.Get();
}
inline void CompareAndSetAccountDetail::_internal_set_account_id(const std::string& value) {
  
  _impl_.account_id_.Set(value, GetArenaForAllocation());
}
inline std::string* CompareAndSetAccountDetail::_internal_mutable_account_id() {
  
  return _impl_.account_id_.Mutable(GetArenaForAllocation());
}
inline std::string* CompareAndSetAccountDetail::release_account_id() {
  // @@protoc_insertion_point(field_release:iroha.protocol.CompareAndSetAccountDetail.account_id)
  return _impl_.account_id_.Release();
}
inline void CompareAndSetAccountDetail::set_allocated_account_id(std::string* account_id) {
  if (account_id != nullptr) {
    
  } else {
    
  }
  _impl_.account_id_.SetAllocated(account_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.account_id_.IsDefault()) {
    _impl_.account_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:iroha.protocol.CompareAndSetAccountDetail.account_id)
}

// string key = 2;
inline void CompareAndSetAccountDetail::clear_key() {
  _impl_.key_.ClearToEmpty();
}
inline const std::string& CompareAndSetAccountDetail::key() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.CompareAndSetAccountDetail.key)
  return _internal_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CompareAndSetAccountDetail::set_key(ArgT0&& arg0, ArgT... args) {
 
 _impl_.key_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:iroha.protocol.CompareAndSetAccountDetail.key)
}
inline std::string* CompareAndSetAccountDetail::mutable_key() {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:iroha.protocol.CompareAndSetAccountDetail.key)
  return _s;
}
inline const std::string& CompareAndSetAccountDetail::_internal_key() const {
  return _impl_.key_.Get();
}
inline void CompareAndSetAccountDetail::_internal_set_key(const std::string& value) {
  
  _impl_.key_.Set(value, GetArenaForAllocation());
}
inline std::string* CompareAndSetAccountDetail::_internal_mutable_key() {
  
  return _impl_.key_.Mutable(GetArenaForAllocation());
}
inline std::string* CompareAndSetAccountDetail::release_key() {
  // @@protoc_insertion_point(field_release:iroha.protocol.CompareAndSetAccountDetail.key)
  return _impl_.key_.Release();
}
inline void CompareAndSetAccountDetail::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    
  } else {
    
  }
  _impl_.key_.SetAllocated(key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.key_.IsDefault()) {
    _impl_.key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:iroha.protocol.CompareAndSetAccountDetail.key)
}

// string value = 3;
inline void CompareAndSetAccountDetail::clear_value() {
  _impl_.value_.ClearToEmpty();
}
inline const std::string& CompareAndSetAccountDetail::value() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.CompareAndSetAccountDetail.value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CompareAndSetAccountDetail::set_value(ArgT0&& arg0, ArgT... args) {
 
 _impl_.value_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:iroha.protocol.CompareAndSetAccountDetail.value)
}
inline std::string* CompareAndSetAccountDetail::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:iroha.protocol.CompareAndSetAccountDetail.value)
  return _s;
}
inline const std::string& CompareAndSetAccountDetail::_internal_value() const {
  return _impl_.value_.Get();
}
inline void CompareAndSetAccountDetail::_internal_set_value(const std::string& value) {
  
  _impl_.value_.Set(value, GetArenaForAllocation());
}
inline std::string* CompareAndSetAccountDetail::_internal_mutable_value() {
  
  return _impl_.value_.Mutable(GetArenaForAllocation());
}
inline std::string* CompareAndSetAccountDetail::release_value() {
  // @@protoc_insertion_point(field_release:iroha.protocol.CompareAndSetAccountDetail.value)
  return _impl_.value_.Release();
}
inline void CompareAndSetAccountDetail::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  _impl_.value_.SetAllocated(value, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.value_.IsDefault()) {
    _impl_.value_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:iroha.protocol.CompareAndSetAccountDetail.value)
}

// string old_value = 4;
inline bool CompareAndSetAccountDetail::_internal_has_old_value() const {
  return opt_old_value_case() == kOldValue;
}
inline bool CompareAndSetAccountDetail::has_old_value() const {
  return _internal_has_old_value();
}
inline void CompareAndSetAccountDetail::set_has_old_value() {
  _impl_._oneof_case_[0] = kOldValue;
}
inline void CompareAndSetAccountDetail::clear_old_value() {
  if (_internal_has_old_value()) {
    _impl_.opt_old_value_.old_value_.Destroy();
    clear_has_opt_old_value();
  }
}
inline const std::string& CompareAndSetAccountDetail::old_value() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.CompareAndSetAccountDetail.old_value)
  return _internal_old_value();
}
template <typename ArgT0, typename... ArgT>
inline void CompareAndSetAccountDetail::set_old_value(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_old_value()) {
    clear_opt_old_value();
    set_has_old_value();
    _impl_.opt_old_value_.old_value_.InitDefault();
  }
  _impl_.opt_old_value_.old_value_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:iroha.protocol.CompareAndSetAccountDetail.old_value)
}
inline std::string* CompareAndSetAccountDetail::mutable_old_value() {
  std::string* _s = _internal_mutable_old_value();
  // @@protoc_insertion_point(field_mutable:iroha.protocol.CompareAndSetAccountDetail.old_value)
  return _s;
}
inline const std::string& CompareAndSetAccountDetail::_internal_old_value() const {
  if (_internal_has_old_value()) {
    return _impl_.opt_old_value_.old_value_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void CompareAndSetAccountDetail::_internal_set_old_value(const std::string& value) {
  if (!_internal_has_old_value()) {
    clear_opt_old_value();
    set_has_old_value();
    _impl_.opt_old_value_.old_value_.InitDefault();
  }
  _impl_.opt_old_value_.old_value_.Set(value, GetArenaForAllocation());
}
inline std::string* CompareAndSetAccountDetail::_internal_mutable_old_value() {
  if (!_internal_has_old_value()) {
    clear_opt_old_value();
    set_has_old_value();
    _impl_.opt_old_value_.old_value_.InitDefault();
  }
  return _impl_.opt_old_value_.old_value_.Mutable(      GetArenaForAllocation());
}
inline std::string* CompareAndSetAccountDetail::release_old_value() {
  // @@protoc_insertion_point(field_release:iroha.protocol.CompareAndSetAccountDetail.old_value)
  if (_internal_has_old_value()) {
    clear_has_opt_old_value();
    return _impl_.opt_old_value_.old_value_.Release();
  } else {
    return nullptr;
  }
}
inline void CompareAndSetAccountDetail::set_allocated_old_value(std::string* old_value) {
  if (has_opt_old_value()) {
    clear_opt_old_value();
  }
  if (old_value != nullptr) {
    set_has_old_value();
    _impl_.opt_old_value_.old_value_.InitAllocated(old_value, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:iroha.protocol.CompareAndSetAccountDetail.old_value)
}

// bool check_empty = 5;
inline void CompareAndSetAccountDetail::clear_check_empty() {
  _impl_.check_empty_ = false;
}
inline bool CompareAndSetAccountDetail::_internal_check_empty() const {
  return _impl_.check_empty_;
}
inline bool CompareAndSetAccountDetail::check_empty() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.CompareAndSetAccountDetail.check_empty)
  return _internal_check_empty();
}
inline void CompareAndSetAccountDetail::_internal_set_check_empty(bool value) {
  
  _impl_.check_empty_ = value;
}
inline void CompareAndSetAccountDetail::set_check_empty(bool value) {
  _internal_set_check_empty(value);
  // @@protoc_insertion_point(field_set:iroha.protocol.CompareAndSetAccountDetail.check_empty)
}

inline bool CompareAndSetAccountDetail::has_opt_old_value() const {
  return opt_old_value_case() != OPT_OLD_VALUE_NOT_SET;
}
inline void CompareAndSetAccountDetail::clear_has_opt_old_value() {
  _impl_._oneof_case_[0] = OPT_OLD_VALUE_NOT_SET;
}
inline CompareAndSetAccountDetail::OptOldValueCase CompareAndSetAccountDetail::opt_old_value_case() const {
  return CompareAndSetAccountDetail::OptOldValueCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// SetSettingValue

// string key = 1;
inline void SetSettingValue::clear_key() {
  _impl_.key_.ClearToEmpty();
}
inline const std::string& SetSettingValue::key() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.SetSettingValue.key)
  return _internal_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SetSettingValue::set_key(ArgT0&& arg0, ArgT... args) {
 
 _impl_.key_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:iroha.protocol.SetSettingValue.key)
}
inline std::string* SetSettingValue::mutable_key() {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:iroha.protocol.SetSettingValue.key)
  return _s;
}
inline const std::string& SetSettingValue::_internal_key() const {
  return _impl_.key_.Get();
}
inline void SetSettingValue::_internal_set_key(const std::string& value) {
  
  _impl_.key_.Set(value, GetArenaForAllocation());
}
inline std::string* SetSettingValue::_internal_mutable_key() {
  
  return _impl_.key_.Mutable(GetArenaForAllocation());
}
inline std::string* SetSettingValue::release_key() {
  // @@protoc_insertion_point(field_release:iroha.protocol.SetSettingValue.key)
  return _impl_.key_.Release();
}
inline void SetSettingValue::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    
  } else {
    
  }
  _impl_.key_.SetAllocated(key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.key_.IsDefault()) {
    _impl_.key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:iroha.protocol.SetSettingValue.key)
}

// string value = 2;
inline void SetSettingValue::clear_value() {
  _impl_.value_.ClearToEmpty();
}
inline const std::string& SetSettingValue::value() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.SetSettingValue.value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SetSettingValue::set_value(ArgT0&& arg0, ArgT... args) {
 
 _impl_.value_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:iroha.protocol.SetSettingValue.value)
}
inline std::string* SetSettingValue::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:iroha.protocol.SetSettingValue.value)
  return _s;
}
inline const std::string& SetSettingValue::_internal_value() const {
  return _impl_.value_.Get();
}
inline void SetSettingValue::_internal_set_value(const std::string& value) {
  
  _impl_.value_.Set(value, GetArenaForAllocation());
}
inline std::string* SetSettingValue::_internal_mutable_value() {
  
  return _impl_.value_.Mutable(GetArenaForAllocation());
}
inline std::string* SetSettingValue::release_value() {
  // @@protoc_insertion_point(field_release:iroha.protocol.SetSettingValue.value)
  return _impl_.value_.Release();
}
inline void SetSettingValue::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  _impl_.value_.SetAllocated(value, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.value_.IsDefault()) {
    _impl_.value_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:iroha.protocol.SetSettingValue.value)
}

// -------------------------------------------------------------------

// CallEngine

// .iroha.protocol.CallEngine.EngineType type = 1;
inline void CallEngine::clear_type() {
  _impl_.type_ = 0;
}
inline ::iroha::protocol::CallEngine_EngineType CallEngine::_internal_type() const {
  return static_cast< ::iroha::protocol::CallEngine_EngineType >(_impl_.type_);
}
inline ::iroha::protocol::CallEngine_EngineType CallEngine::type() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.CallEngine.type)
  return _internal_type();
}
inline void CallEngine::_internal_set_type(::iroha::protocol::CallEngine_EngineType value) {
  
  _impl_.type_ = value;
}
inline void CallEngine::set_type(::iroha::protocol::CallEngine_EngineType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:iroha.protocol.CallEngine.type)
}

// string caller = 2;
inline void CallEngine::clear_caller() {
  _impl_.caller_.ClearToEmpty();
}
inline const std::string& CallEngine::caller() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.CallEngine.caller)
  return _internal_caller();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CallEngine::set_caller(ArgT0&& arg0, ArgT... args) {
 
 _impl_.caller_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:iroha.protocol.CallEngine.caller)
}
inline std::string* CallEngine::mutable_caller() {
  std::string* _s = _internal_mutable_caller();
  // @@protoc_insertion_point(field_mutable:iroha.protocol.CallEngine.caller)
  return _s;
}
inline const std::string& CallEngine::_internal_caller() const {
  return _impl_.caller_.Get();
}
inline void CallEngine::_internal_set_caller(const std::string& value) {
  
  _impl_.caller_.Set(value, GetArenaForAllocation());
}
inline std::string* CallEngine::_internal_mutable_caller() {
  
  return _impl_.caller_.Mutable(GetArenaForAllocation());
}
inline std::string* CallEngine::release_caller() {
  // @@protoc_insertion_point(field_release:iroha.protocol.CallEngine.caller)
  return _impl_.caller_.Release();
}
inline void CallEngine::set_allocated_caller(std::string* caller) {
  if (caller != nullptr) {
    
  } else {
    
  }
  _impl_.caller_.SetAllocated(caller, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.caller_.IsDefault()) {
    _impl_.caller_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:iroha.protocol.CallEngine.caller)
}

// string callee = 3;
inline bool CallEngine::_internal_has_callee() const {
  return opt_callee_case() == kCallee;
}
inline bool CallEngine::has_callee() const {
  return _internal_has_callee();
}
inline void CallEngine::set_has_callee() {
  _impl_._oneof_case_[0] = kCallee;
}
inline void CallEngine::clear_callee() {
  if (_internal_has_callee()) {
    _impl_.opt_callee_.callee_.Destroy();
    clear_has_opt_callee();
  }
}
inline const std::string& CallEngine::callee() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.CallEngine.callee)
  return _internal_callee();
}
template <typename ArgT0, typename... ArgT>
inline void CallEngine::set_callee(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_callee()) {
    clear_opt_callee();
    set_has_callee();
    _impl_.opt_callee_.callee_.InitDefault();
  }
  _impl_.opt_callee_.callee_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:iroha.protocol.CallEngine.callee)
}
inline std::string* CallEngine::mutable_callee() {
  std::string* _s = _internal_mutable_callee();
  // @@protoc_insertion_point(field_mutable:iroha.protocol.CallEngine.callee)
  return _s;
}
inline const std::string& CallEngine::_internal_callee() const {
  if (_internal_has_callee()) {
    return _impl_.opt_callee_.callee_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void CallEngine::_internal_set_callee(const std::string& value) {
  if (!_internal_has_callee()) {
    clear_opt_callee();
    set_has_callee();
    _impl_.opt_callee_.callee_.InitDefault();
  }
  _impl_.opt_callee_.callee_.Set(value, GetArenaForAllocation());
}
inline std::string* CallEngine::_internal_mutable_callee() {
  if (!_internal_has_callee()) {
    clear_opt_callee();
    set_has_callee();
    _impl_.opt_callee_.callee_.InitDefault();
  }
  return _impl_.opt_callee_.callee_.Mutable(      GetArenaForAllocation());
}
inline std::string* CallEngine::release_callee() {
  // @@protoc_insertion_point(field_release:iroha.protocol.CallEngine.callee)
  if (_internal_has_callee()) {
    clear_has_opt_callee();
    return _impl_.opt_callee_.callee_.Release();
  } else {
    return nullptr;
  }
}
inline void CallEngine::set_allocated_callee(std::string* callee) {
  if (has_opt_callee()) {
    clear_opt_callee();
  }
  if (callee != nullptr) {
    set_has_callee();
    _impl_.opt_callee_.callee_.InitAllocated(callee, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:iroha.protocol.CallEngine.callee)
}

// string input = 4;
inline void CallEngine::clear_input() {
  _impl_.input_.ClearToEmpty();
}
inline const std::string& CallEngine::input() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.CallEngine.input)
  return _internal_input();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CallEngine::set_input(ArgT0&& arg0, ArgT... args) {
 
 _impl_.input_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:iroha.protocol.CallEngine.input)
}
inline std::string* CallEngine::mutable_input() {
  std::string* _s = _internal_mutable_input();
  // @@protoc_insertion_point(field_mutable:iroha.protocol.CallEngine.input)
  return _s;
}
inline const std::string& CallEngine::_internal_input() const {
  return _impl_.input_.Get();
}
inline void CallEngine::_internal_set_input(const std::string& value) {
  
  _impl_.input_.Set(value, GetArenaForAllocation());
}
inline std::string* CallEngine::_internal_mutable_input() {
  
  return _impl_.input_.Mutable(GetArenaForAllocation());
}
inline std::string* CallEngine::release_input() {
  // @@protoc_insertion_point(field_release:iroha.protocol.CallEngine.input)
  return _impl_.input_.Release();
}
inline void CallEngine::set_allocated_input(std::string* input) {
  if (input != nullptr) {
    
  } else {
    
  }
  _impl_.input_.SetAllocated(input, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.input_.IsDefault()) {
    _impl_.input_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:iroha.protocol.CallEngine.input)
}

inline bool CallEngine::has_opt_callee() const {
  return opt_callee_case() != OPT_CALLEE_NOT_SET;
}
inline void CallEngine::clear_has_opt_callee() {
  _impl_._oneof_case_[0] = OPT_CALLEE_NOT_SET;
}
inline CallEngine::OptCalleeCase CallEngine::opt_callee_case() const {
  return CallEngine::OptCalleeCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// Command

// .iroha.protocol.AddAssetQuantity add_asset_quantity = 1;
inline bool Command::_internal_has_add_asset_quantity() const {
  return command_case() == kAddAssetQuantity;
}
inline bool Command::has_add_asset_quantity() const {
  return _internal_has_add_asset_quantity();
}
inline void Command::set_has_add_asset_quantity() {
  _impl_._oneof_case_[0] = kAddAssetQuantity;
}
inline void Command::clear_add_asset_quantity() {
  if (_internal_has_add_asset_quantity()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.command_.add_asset_quantity_;
    }
    clear_has_command();
  }
}
inline ::iroha::protocol::AddAssetQuantity* Command::release_add_asset_quantity() {
  // @@protoc_insertion_point(field_release:iroha.protocol.Command.add_asset_quantity)
  if (_internal_has_add_asset_quantity()) {
    clear_has_command();
    ::iroha::protocol::AddAssetQuantity* temp = _impl_.command_.add_asset_quantity_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.command_.add_asset_quantity_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::iroha::protocol::AddAssetQuantity& Command::_internal_add_asset_quantity() const {
  return _internal_has_add_asset_quantity()
      ? *_impl_.command_.add_asset_quantity_
      : reinterpret_cast< ::iroha::protocol::AddAssetQuantity&>(::iroha::protocol::_AddAssetQuantity_default_instance_);
}
inline const ::iroha::protocol::AddAssetQuantity& Command::add_asset_quantity() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.Command.add_asset_quantity)
  return _internal_add_asset_quantity();
}
inline ::iroha::protocol::AddAssetQuantity* Command::unsafe_arena_release_add_asset_quantity() {
  // @@protoc_insertion_point(field_unsafe_arena_release:iroha.protocol.Command.add_asset_quantity)
  if (_internal_has_add_asset_quantity()) {
    clear_has_command();
    ::iroha::protocol::AddAssetQuantity* temp = _impl_.command_.add_asset_quantity_;
    _impl_.command_.add_asset_quantity_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Command::unsafe_arena_set_allocated_add_asset_quantity(::iroha::protocol::AddAssetQuantity* add_asset_quantity) {
  clear_command();
  if (add_asset_quantity) {
    set_has_add_asset_quantity();
    _impl_.command_.add_asset_quantity_ = add_asset_quantity;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:iroha.protocol.Command.add_asset_quantity)
}
inline ::iroha::protocol::AddAssetQuantity* Command::_internal_mutable_add_asset_quantity() {
  if (!_internal_has_add_asset_quantity()) {
    clear_command();
    set_has_add_asset_quantity();
    _impl_.command_.add_asset_quantity_ = CreateMaybeMessage< ::iroha::protocol::AddAssetQuantity >(GetArenaForAllocation());
  }
  return _impl_.command_.add_asset_quantity_;
}
inline ::iroha::protocol::AddAssetQuantity* Command::mutable_add_asset_quantity() {
  ::iroha::protocol::AddAssetQuantity* _msg = _internal_mutable_add_asset_quantity();
  // @@protoc_insertion_point(field_mutable:iroha.protocol.Command.add_asset_quantity)
  return _msg;
}

// .iroha.protocol.AddPeer add_peer = 2;
inline bool Command::_internal_has_add_peer() const {
  return command_case() == kAddPeer;
}
inline bool Command::has_add_peer() const {
  return _internal_has_add_peer();
}
inline void Command::set_has_add_peer() {
  _impl_._oneof_case_[0] = kAddPeer;
}
inline void Command::clear_add_peer() {
  if (_internal_has_add_peer()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.command_.add_peer_;
    }
    clear_has_command();
  }
}
inline ::iroha::protocol::AddPeer* Command::release_add_peer() {
  // @@protoc_insertion_point(field_release:iroha.protocol.Command.add_peer)
  if (_internal_has_add_peer()) {
    clear_has_command();
    ::iroha::protocol::AddPeer* temp = _impl_.command_.add_peer_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.command_.add_peer_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::iroha::protocol::AddPeer& Command::_internal_add_peer() const {
  return _internal_has_add_peer()
      ? *_impl_.command_.add_peer_
      : reinterpret_cast< ::iroha::protocol::AddPeer&>(::iroha::protocol::_AddPeer_default_instance_);
}
inline const ::iroha::protocol::AddPeer& Command::add_peer() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.Command.add_peer)
  return _internal_add_peer();
}
inline ::iroha::protocol::AddPeer* Command::unsafe_arena_release_add_peer() {
  // @@protoc_insertion_point(field_unsafe_arena_release:iroha.protocol.Command.add_peer)
  if (_internal_has_add_peer()) {
    clear_has_command();
    ::iroha::protocol::AddPeer* temp = _impl_.command_.add_peer_;
    _impl_.command_.add_peer_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Command::unsafe_arena_set_allocated_add_peer(::iroha::protocol::AddPeer* add_peer) {
  clear_command();
  if (add_peer) {
    set_has_add_peer();
    _impl_.command_.add_peer_ = add_peer;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:iroha.protocol.Command.add_peer)
}
inline ::iroha::protocol::AddPeer* Command::_internal_mutable_add_peer() {
  if (!_internal_has_add_peer()) {
    clear_command();
    set_has_add_peer();
    _impl_.command_.add_peer_ = CreateMaybeMessage< ::iroha::protocol::AddPeer >(GetArenaForAllocation());
  }
  return _impl_.command_.add_peer_;
}
inline ::iroha::protocol::AddPeer* Command::mutable_add_peer() {
  ::iroha::protocol::AddPeer* _msg = _internal_mutable_add_peer();
  // @@protoc_insertion_point(field_mutable:iroha.protocol.Command.add_peer)
  return _msg;
}

// .iroha.protocol.AddSignatory add_signatory = 3;
inline bool Command::_internal_has_add_signatory() const {
  return command_case() == kAddSignatory;
}
inline bool Command::has_add_signatory() const {
  return _internal_has_add_signatory();
}
inline void Command::set_has_add_signatory() {
  _impl_._oneof_case_[0] = kAddSignatory;
}
inline void Command::clear_add_signatory() {
  if (_internal_has_add_signatory()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.command_.add_signatory_;
    }
    clear_has_command();
  }
}
inline ::iroha::protocol::AddSignatory* Command::release_add_signatory() {
  // @@protoc_insertion_point(field_release:iroha.protocol.Command.add_signatory)
  if (_internal_has_add_signatory()) {
    clear_has_command();
    ::iroha::protocol::AddSignatory* temp = _impl_.command_.add_signatory_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.command_.add_signatory_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::iroha::protocol::AddSignatory& Command::_internal_add_signatory() const {
  return _internal_has_add_signatory()
      ? *_impl_.command_.add_signatory_
      : reinterpret_cast< ::iroha::protocol::AddSignatory&>(::iroha::protocol::_AddSignatory_default_instance_);
}
inline const ::iroha::protocol::AddSignatory& Command::add_signatory() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.Command.add_signatory)
  return _internal_add_signatory();
}
inline ::iroha::protocol::AddSignatory* Command::unsafe_arena_release_add_signatory() {
  // @@protoc_insertion_point(field_unsafe_arena_release:iroha.protocol.Command.add_signatory)
  if (_internal_has_add_signatory()) {
    clear_has_command();
    ::iroha::protocol::AddSignatory* temp = _impl_.command_.add_signatory_;
    _impl_.command_.add_signatory_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Command::unsafe_arena_set_allocated_add_signatory(::iroha::protocol::AddSignatory* add_signatory) {
  clear_command();
  if (add_signatory) {
    set_has_add_signatory();
    _impl_.command_.add_signatory_ = add_signatory;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:iroha.protocol.Command.add_signatory)
}
inline ::iroha::protocol::AddSignatory* Command::_internal_mutable_add_signatory() {
  if (!_internal_has_add_signatory()) {
    clear_command();
    set_has_add_signatory();
    _impl_.command_.add_signatory_ = CreateMaybeMessage< ::iroha::protocol::AddSignatory >(GetArenaForAllocation());
  }
  return _impl_.command_.add_signatory_;
}
inline ::iroha::protocol::AddSignatory* Command::mutable_add_signatory() {
  ::iroha::protocol::AddSignatory* _msg = _internal_mutable_add_signatory();
  // @@protoc_insertion_point(field_mutable:iroha.protocol.Command.add_signatory)
  return _msg;
}

// .iroha.protocol.AppendRole append_role = 4;
inline bool Command::_internal_has_append_role() const {
  return command_case() == kAppendRole;
}
inline bool Command::has_append_role() const {
  return _internal_has_append_role();
}
inline void Command::set_has_append_role() {
  _impl_._oneof_case_[0] = kAppendRole;
}
inline void Command::clear_append_role() {
  if (_internal_has_append_role()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.command_.append_role_;
    }
    clear_has_command();
  }
}
inline ::iroha::protocol::AppendRole* Command::release_append_role() {
  // @@protoc_insertion_point(field_release:iroha.protocol.Command.append_role)
  if (_internal_has_append_role()) {
    clear_has_command();
    ::iroha::protocol::AppendRole* temp = _impl_.command_.append_role_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.command_.append_role_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::iroha::protocol::AppendRole& Command::_internal_append_role() const {
  return _internal_has_append_role()
      ? *_impl_.command_.append_role_
      : reinterpret_cast< ::iroha::protocol::AppendRole&>(::iroha::protocol::_AppendRole_default_instance_);
}
inline const ::iroha::protocol::AppendRole& Command::append_role() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.Command.append_role)
  return _internal_append_role();
}
inline ::iroha::protocol::AppendRole* Command::unsafe_arena_release_append_role() {
  // @@protoc_insertion_point(field_unsafe_arena_release:iroha.protocol.Command.append_role)
  if (_internal_has_append_role()) {
    clear_has_command();
    ::iroha::protocol::AppendRole* temp = _impl_.command_.append_role_;
    _impl_.command_.append_role_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Command::unsafe_arena_set_allocated_append_role(::iroha::protocol::AppendRole* append_role) {
  clear_command();
  if (append_role) {
    set_has_append_role();
    _impl_.command_.append_role_ = append_role;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:iroha.protocol.Command.append_role)
}
inline ::iroha::protocol::AppendRole* Command::_internal_mutable_append_role() {
  if (!_internal_has_append_role()) {
    clear_command();
    set_has_append_role();
    _impl_.command_.append_role_ = CreateMaybeMessage< ::iroha::protocol::AppendRole >(GetArenaForAllocation());
  }
  return _impl_.command_.append_role_;
}
inline ::iroha::protocol::AppendRole* Command::mutable_append_role() {
  ::iroha::protocol::AppendRole* _msg = _internal_mutable_append_role();
  // @@protoc_insertion_point(field_mutable:iroha.protocol.Command.append_role)
  return _msg;
}

// .iroha.protocol.CreateAccount create_account = 5;
inline bool Command::_internal_has_create_account() const {
  return command_case() == kCreateAccount;
}
inline bool Command::has_create_account() const {
  return _internal_has_create_account();
}
inline void Command::set_has_create_account() {
  _impl_._oneof_case_[0] = kCreateAccount;
}
inline void Command::clear_create_account() {
  if (_internal_has_create_account()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.command_.create_account_;
    }
    clear_has_command();
  }
}
inline ::iroha::protocol::CreateAccount* Command::release_create_account() {
  // @@protoc_insertion_point(field_release:iroha.protocol.Command.create_account)
  if (_internal_has_create_account()) {
    clear_has_command();
    ::iroha::protocol::CreateAccount* temp = _impl_.command_.create_account_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.command_.create_account_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::iroha::protocol::CreateAccount& Command::_internal_create_account() const {
  return _internal_has_create_account()
      ? *_impl_.command_.create_account_
      : reinterpret_cast< ::iroha::protocol::CreateAccount&>(::iroha::protocol::_CreateAccount_default_instance_);
}
inline const ::iroha::protocol::CreateAccount& Command::create_account() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.Command.create_account)
  return _internal_create_account();
}
inline ::iroha::protocol::CreateAccount* Command::unsafe_arena_release_create_account() {
  // @@protoc_insertion_point(field_unsafe_arena_release:iroha.protocol.Command.create_account)
  if (_internal_has_create_account()) {
    clear_has_command();
    ::iroha::protocol::CreateAccount* temp = _impl_.command_.create_account_;
    _impl_.command_.create_account_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Command::unsafe_arena_set_allocated_create_account(::iroha::protocol::CreateAccount* create_account) {
  clear_command();
  if (create_account) {
    set_has_create_account();
    _impl_.command_.create_account_ = create_account;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:iroha.protocol.Command.create_account)
}
inline ::iroha::protocol::CreateAccount* Command::_internal_mutable_create_account() {
  if (!_internal_has_create_account()) {
    clear_command();
    set_has_create_account();
    _impl_.command_.create_account_ = CreateMaybeMessage< ::iroha::protocol::CreateAccount >(GetArenaForAllocation());
  }
  return _impl_.command_.create_account_;
}
inline ::iroha::protocol::CreateAccount* Command::mutable_create_account() {
  ::iroha::protocol::CreateAccount* _msg = _internal_mutable_create_account();
  // @@protoc_insertion_point(field_mutable:iroha.protocol.Command.create_account)
  return _msg;
}

// .iroha.protocol.CreateAsset create_asset = 6;
inline bool Command::_internal_has_create_asset() const {
  return command_case() == kCreateAsset;
}
inline bool Command::has_create_asset() const {
  return _internal_has_create_asset();
}
inline void Command::set_has_create_asset() {
  _impl_._oneof_case_[0] = kCreateAsset;
}
inline void Command::clear_create_asset() {
  if (_internal_has_create_asset()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.command_.create_asset_;
    }
    clear_has_command();
  }
}
inline ::iroha::protocol::CreateAsset* Command::release_create_asset() {
  // @@protoc_insertion_point(field_release:iroha.protocol.Command.create_asset)
  if (_internal_has_create_asset()) {
    clear_has_command();
    ::iroha::protocol::CreateAsset* temp = _impl_.command_.create_asset_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.command_.create_asset_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::iroha::protocol::CreateAsset& Command::_internal_create_asset() const {
  return _internal_has_create_asset()
      ? *_impl_.command_.create_asset_
      : reinterpret_cast< ::iroha::protocol::CreateAsset&>(::iroha::protocol::_CreateAsset_default_instance_);
}
inline const ::iroha::protocol::CreateAsset& Command::create_asset() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.Command.create_asset)
  return _internal_create_asset();
}
inline ::iroha::protocol::CreateAsset* Command::unsafe_arena_release_create_asset() {
  // @@protoc_insertion_point(field_unsafe_arena_release:iroha.protocol.Command.create_asset)
  if (_internal_has_create_asset()) {
    clear_has_command();
    ::iroha::protocol::CreateAsset* temp = _impl_.command_.create_asset_;
    _impl_.command_.create_asset_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Command::unsafe_arena_set_allocated_create_asset(::iroha::protocol::CreateAsset* create_asset) {
  clear_command();
  if (create_asset) {
    set_has_create_asset();
    _impl_.command_.create_asset_ = create_asset;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:iroha.protocol.Command.create_asset)
}
inline ::iroha::protocol::CreateAsset* Command::_internal_mutable_create_asset() {
  if (!_internal_has_create_asset()) {
    clear_command();
    set_has_create_asset();
    _impl_.command_.create_asset_ = CreateMaybeMessage< ::iroha::protocol::CreateAsset >(GetArenaForAllocation());
  }
  return _impl_.command_.create_asset_;
}
inline ::iroha::protocol::CreateAsset* Command::mutable_create_asset() {
  ::iroha::protocol::CreateAsset* _msg = _internal_mutable_create_asset();
  // @@protoc_insertion_point(field_mutable:iroha.protocol.Command.create_asset)
  return _msg;
}

// .iroha.protocol.CreateDomain create_domain = 7;
inline bool Command::_internal_has_create_domain() const {
  return command_case() == kCreateDomain;
}
inline bool Command::has_create_domain() const {
  return _internal_has_create_domain();
}
inline void Command::set_has_create_domain() {
  _impl_._oneof_case_[0] = kCreateDomain;
}
inline void Command::clear_create_domain() {
  if (_internal_has_create_domain()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.command_.create_domain_;
    }
    clear_has_command();
  }
}
inline ::iroha::protocol::CreateDomain* Command::release_create_domain() {
  // @@protoc_insertion_point(field_release:iroha.protocol.Command.create_domain)
  if (_internal_has_create_domain()) {
    clear_has_command();
    ::iroha::protocol::CreateDomain* temp = _impl_.command_.create_domain_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.command_.create_domain_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::iroha::protocol::CreateDomain& Command::_internal_create_domain() const {
  return _internal_has_create_domain()
      ? *_impl_.command_.create_domain_
      : reinterpret_cast< ::iroha::protocol::CreateDomain&>(::iroha::protocol::_CreateDomain_default_instance_);
}
inline const ::iroha::protocol::CreateDomain& Command::create_domain() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.Command.create_domain)
  return _internal_create_domain();
}
inline ::iroha::protocol::CreateDomain* Command::unsafe_arena_release_create_domain() {
  // @@protoc_insertion_point(field_unsafe_arena_release:iroha.protocol.Command.create_domain)
  if (_internal_has_create_domain()) {
    clear_has_command();
    ::iroha::protocol::CreateDomain* temp = _impl_.command_.create_domain_;
    _impl_.command_.create_domain_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Command::unsafe_arena_set_allocated_create_domain(::iroha::protocol::CreateDomain* create_domain) {
  clear_command();
  if (create_domain) {
    set_has_create_domain();
    _impl_.command_.create_domain_ = create_domain;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:iroha.protocol.Command.create_domain)
}
inline ::iroha::protocol::CreateDomain* Command::_internal_mutable_create_domain() {
  if (!_internal_has_create_domain()) {
    clear_command();
    set_has_create_domain();
    _impl_.command_.create_domain_ = CreateMaybeMessage< ::iroha::protocol::CreateDomain >(GetArenaForAllocation());
  }
  return _impl_.command_.create_domain_;
}
inline ::iroha::protocol::CreateDomain* Command::mutable_create_domain() {
  ::iroha::protocol::CreateDomain* _msg = _internal_mutable_create_domain();
  // @@protoc_insertion_point(field_mutable:iroha.protocol.Command.create_domain)
  return _msg;
}

// .iroha.protocol.CreateRole create_role = 8;
inline bool Command::_internal_has_create_role() const {
  return command_case() == kCreateRole;
}
inline bool Command::has_create_role() const {
  return _internal_has_create_role();
}
inline void Command::set_has_create_role() {
  _impl_._oneof_case_[0] = kCreateRole;
}
inline void Command::clear_create_role() {
  if (_internal_has_create_role()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.command_.create_role_;
    }
    clear_has_command();
  }
}
inline ::iroha::protocol::CreateRole* Command::release_create_role() {
  // @@protoc_insertion_point(field_release:iroha.protocol.Command.create_role)
  if (_internal_has_create_role()) {
    clear_has_command();
    ::iroha::protocol::CreateRole* temp = _impl_.command_.create_role_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.command_.create_role_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::iroha::protocol::CreateRole& Command::_internal_create_role() const {
  return _internal_has_create_role()
      ? *_impl_.command_.create_role_
      : reinterpret_cast< ::iroha::protocol::CreateRole&>(::iroha::protocol::_CreateRole_default_instance_);
}
inline const ::iroha::protocol::CreateRole& Command::create_role() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.Command.create_role)
  return _internal_create_role();
}
inline ::iroha::protocol::CreateRole* Command::unsafe_arena_release_create_role() {
  // @@protoc_insertion_point(field_unsafe_arena_release:iroha.protocol.Command.create_role)
  if (_internal_has_create_role()) {
    clear_has_command();
    ::iroha::protocol::CreateRole* temp = _impl_.command_.create_role_;
    _impl_.command_.create_role_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Command::unsafe_arena_set_allocated_create_role(::iroha::protocol::CreateRole* create_role) {
  clear_command();
  if (create_role) {
    set_has_create_role();
    _impl_.command_.create_role_ = create_role;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:iroha.protocol.Command.create_role)
}
inline ::iroha::protocol::CreateRole* Command::_internal_mutable_create_role() {
  if (!_internal_has_create_role()) {
    clear_command();
    set_has_create_role();
    _impl_.command_.create_role_ = CreateMaybeMessage< ::iroha::protocol::CreateRole >(GetArenaForAllocation());
  }
  return _impl_.command_.create_role_;
}
inline ::iroha::protocol::CreateRole* Command::mutable_create_role() {
  ::iroha::protocol::CreateRole* _msg = _internal_mutable_create_role();
  // @@protoc_insertion_point(field_mutable:iroha.protocol.Command.create_role)
  return _msg;
}

// .iroha.protocol.DetachRole detach_role = 9;
inline bool Command::_internal_has_detach_role() const {
  return command_case() == kDetachRole;
}
inline bool Command::has_detach_role() const {
  return _internal_has_detach_role();
}
inline void Command::set_has_detach_role() {
  _impl_._oneof_case_[0] = kDetachRole;
}
inline void Command::clear_detach_role() {
  if (_internal_has_detach_role()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.command_.detach_role_;
    }
    clear_has_command();
  }
}
inline ::iroha::protocol::DetachRole* Command::release_detach_role() {
  // @@protoc_insertion_point(field_release:iroha.protocol.Command.detach_role)
  if (_internal_has_detach_role()) {
    clear_has_command();
    ::iroha::protocol::DetachRole* temp = _impl_.command_.detach_role_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.command_.detach_role_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::iroha::protocol::DetachRole& Command::_internal_detach_role() const {
  return _internal_has_detach_role()
      ? *_impl_.command_.detach_role_
      : reinterpret_cast< ::iroha::protocol::DetachRole&>(::iroha::protocol::_DetachRole_default_instance_);
}
inline const ::iroha::protocol::DetachRole& Command::detach_role() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.Command.detach_role)
  return _internal_detach_role();
}
inline ::iroha::protocol::DetachRole* Command::unsafe_arena_release_detach_role() {
  // @@protoc_insertion_point(field_unsafe_arena_release:iroha.protocol.Command.detach_role)
  if (_internal_has_detach_role()) {
    clear_has_command();
    ::iroha::protocol::DetachRole* temp = _impl_.command_.detach_role_;
    _impl_.command_.detach_role_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Command::unsafe_arena_set_allocated_detach_role(::iroha::protocol::DetachRole* detach_role) {
  clear_command();
  if (detach_role) {
    set_has_detach_role();
    _impl_.command_.detach_role_ = detach_role;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:iroha.protocol.Command.detach_role)
}
inline ::iroha::protocol::DetachRole* Command::_internal_mutable_detach_role() {
  if (!_internal_has_detach_role()) {
    clear_command();
    set_has_detach_role();
    _impl_.command_.detach_role_ = CreateMaybeMessage< ::iroha::protocol::DetachRole >(GetArenaForAllocation());
  }
  return _impl_.command_.detach_role_;
}
inline ::iroha::protocol::DetachRole* Command::mutable_detach_role() {
  ::iroha::protocol::DetachRole* _msg = _internal_mutable_detach_role();
  // @@protoc_insertion_point(field_mutable:iroha.protocol.Command.detach_role)
  return _msg;
}

// .iroha.protocol.GrantPermission grant_permission = 10;
inline bool Command::_internal_has_grant_permission() const {
  return command_case() == kGrantPermission;
}
inline bool Command::has_grant_permission() const {
  return _internal_has_grant_permission();
}
inline void Command::set_has_grant_permission() {
  _impl_._oneof_case_[0] = kGrantPermission;
}
inline void Command::clear_grant_permission() {
  if (_internal_has_grant_permission()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.command_.grant_permission_;
    }
    clear_has_command();
  }
}
inline ::iroha::protocol::GrantPermission* Command::release_grant_permission() {
  // @@protoc_insertion_point(field_release:iroha.protocol.Command.grant_permission)
  if (_internal_has_grant_permission()) {
    clear_has_command();
    ::iroha::protocol::GrantPermission* temp = _impl_.command_.grant_permission_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.command_.grant_permission_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::iroha::protocol::GrantPermission& Command::_internal_grant_permission() const {
  return _internal_has_grant_permission()
      ? *_impl_.command_.grant_permission_
      : reinterpret_cast< ::iroha::protocol::GrantPermission&>(::iroha::protocol::_GrantPermission_default_instance_);
}
inline const ::iroha::protocol::GrantPermission& Command::grant_permission() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.Command.grant_permission)
  return _internal_grant_permission();
}
inline ::iroha::protocol::GrantPermission* Command::unsafe_arena_release_grant_permission() {
  // @@protoc_insertion_point(field_unsafe_arena_release:iroha.protocol.Command.grant_permission)
  if (_internal_has_grant_permission()) {
    clear_has_command();
    ::iroha::protocol::GrantPermission* temp = _impl_.command_.grant_permission_;
    _impl_.command_.grant_permission_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Command::unsafe_arena_set_allocated_grant_permission(::iroha::protocol::GrantPermission* grant_permission) {
  clear_command();
  if (grant_permission) {
    set_has_grant_permission();
    _impl_.command_.grant_permission_ = grant_permission;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:iroha.protocol.Command.grant_permission)
}
inline ::iroha::protocol::GrantPermission* Command::_internal_mutable_grant_permission() {
  if (!_internal_has_grant_permission()) {
    clear_command();
    set_has_grant_permission();
    _impl_.command_.grant_permission_ = CreateMaybeMessage< ::iroha::protocol::GrantPermission >(GetArenaForAllocation());
  }
  return _impl_.command_.grant_permission_;
}
inline ::iroha::protocol::GrantPermission* Command::mutable_grant_permission() {
  ::iroha::protocol::GrantPermission* _msg = _internal_mutable_grant_permission();
  // @@protoc_insertion_point(field_mutable:iroha.protocol.Command.grant_permission)
  return _msg;
}

// .iroha.protocol.RemoveSignatory remove_signatory = 11;
inline bool Command::_internal_has_remove_signatory() const {
  return command_case() == kRemoveSignatory;
}
inline bool Command::has_remove_signatory() const {
  return _internal_has_remove_signatory();
}
inline void Command::set_has_remove_signatory() {
  _impl_._oneof_case_[0] = kRemoveSignatory;
}
inline void Command::clear_remove_signatory() {
  if (_internal_has_remove_signatory()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.command_.remove_signatory_;
    }
    clear_has_command();
  }
}
inline ::iroha::protocol::RemoveSignatory* Command::release_remove_signatory() {
  // @@protoc_insertion_point(field_release:iroha.protocol.Command.remove_signatory)
  if (_internal_has_remove_signatory()) {
    clear_has_command();
    ::iroha::protocol::RemoveSignatory* temp = _impl_.command_.remove_signatory_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.command_.remove_signatory_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::iroha::protocol::RemoveSignatory& Command::_internal_remove_signatory() const {
  return _internal_has_remove_signatory()
      ? *_impl_.command_.remove_signatory_
      : reinterpret_cast< ::iroha::protocol::RemoveSignatory&>(::iroha::protocol::_RemoveSignatory_default_instance_);
}
inline const ::iroha::protocol::RemoveSignatory& Command::remove_signatory() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.Command.remove_signatory)
  return _internal_remove_signatory();
}
inline ::iroha::protocol::RemoveSignatory* Command::unsafe_arena_release_remove_signatory() {
  // @@protoc_insertion_point(field_unsafe_arena_release:iroha.protocol.Command.remove_signatory)
  if (_internal_has_remove_signatory()) {
    clear_has_command();
    ::iroha::protocol::RemoveSignatory* temp = _impl_.command_.remove_signatory_;
    _impl_.command_.remove_signatory_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Command::unsafe_arena_set_allocated_remove_signatory(::iroha::protocol::RemoveSignatory* remove_signatory) {
  clear_command();
  if (remove_signatory) {
    set_has_remove_signatory();
    _impl_.command_.remove_signatory_ = remove_signatory;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:iroha.protocol.Command.remove_signatory)
}
inline ::iroha::protocol::RemoveSignatory* Command::_internal_mutable_remove_signatory() {
  if (!_internal_has_remove_signatory()) {
    clear_command();
    set_has_remove_signatory();
    _impl_.command_.remove_signatory_ = CreateMaybeMessage< ::iroha::protocol::RemoveSignatory >(GetArenaForAllocation());
  }
  return _impl_.command_.remove_signatory_;
}
inline ::iroha::protocol::RemoveSignatory* Command::mutable_remove_signatory() {
  ::iroha::protocol::RemoveSignatory* _msg = _internal_mutable_remove_signatory();
  // @@protoc_insertion_point(field_mutable:iroha.protocol.Command.remove_signatory)
  return _msg;
}

// .iroha.protocol.RevokePermission revoke_permission = 12;
inline bool Command::_internal_has_revoke_permission() const {
  return command_case() == kRevokePermission;
}
inline bool Command::has_revoke_permission() const {
  return _internal_has_revoke_permission();
}
inline void Command::set_has_revoke_permission() {
  _impl_._oneof_case_[0] = kRevokePermission;
}
inline void Command::clear_revoke_permission() {
  if (_internal_has_revoke_permission()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.command_.revoke_permission_;
    }
    clear_has_command();
  }
}
inline ::iroha::protocol::RevokePermission* Command::release_revoke_permission() {
  // @@protoc_insertion_point(field_release:iroha.protocol.Command.revoke_permission)
  if (_internal_has_revoke_permission()) {
    clear_has_command();
    ::iroha::protocol::RevokePermission* temp = _impl_.command_.revoke_permission_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.command_.revoke_permission_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::iroha::protocol::RevokePermission& Command::_internal_revoke_permission() const {
  return _internal_has_revoke_permission()
      ? *_impl_.command_.revoke_permission_
      : reinterpret_cast< ::iroha::protocol::RevokePermission&>(::iroha::protocol::_RevokePermission_default_instance_);
}
inline const ::iroha::protocol::RevokePermission& Command::revoke_permission() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.Command.revoke_permission)
  return _internal_revoke_permission();
}
inline ::iroha::protocol::RevokePermission* Command::unsafe_arena_release_revoke_permission() {
  // @@protoc_insertion_point(field_unsafe_arena_release:iroha.protocol.Command.revoke_permission)
  if (_internal_has_revoke_permission()) {
    clear_has_command();
    ::iroha::protocol::RevokePermission* temp = _impl_.command_.revoke_permission_;
    _impl_.command_.revoke_permission_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Command::unsafe_arena_set_allocated_revoke_permission(::iroha::protocol::RevokePermission* revoke_permission) {
  clear_command();
  if (revoke_permission) {
    set_has_revoke_permission();
    _impl_.command_.revoke_permission_ = revoke_permission;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:iroha.protocol.Command.revoke_permission)
}
inline ::iroha::protocol::RevokePermission* Command::_internal_mutable_revoke_permission() {
  if (!_internal_has_revoke_permission()) {
    clear_command();
    set_has_revoke_permission();
    _impl_.command_.revoke_permission_ = CreateMaybeMessage< ::iroha::protocol::RevokePermission >(GetArenaForAllocation());
  }
  return _impl_.command_.revoke_permission_;
}
inline ::iroha::protocol::RevokePermission* Command::mutable_revoke_permission() {
  ::iroha::protocol::RevokePermission* _msg = _internal_mutable_revoke_permission();
  // @@protoc_insertion_point(field_mutable:iroha.protocol.Command.revoke_permission)
  return _msg;
}

// .iroha.protocol.SetAccountDetail set_account_detail = 13;
inline bool Command::_internal_has_set_account_detail() const {
  return command_case() == kSetAccountDetail;
}
inline bool Command::has_set_account_detail() const {
  return _internal_has_set_account_detail();
}
inline void Command::set_has_set_account_detail() {
  _impl_._oneof_case_[0] = kSetAccountDetail;
}
inline void Command::clear_set_account_detail() {
  if (_internal_has_set_account_detail()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.command_.set_account_detail_;
    }
    clear_has_command();
  }
}
inline ::iroha::protocol::SetAccountDetail* Command::release_set_account_detail() {
  // @@protoc_insertion_point(field_release:iroha.protocol.Command.set_account_detail)
  if (_internal_has_set_account_detail()) {
    clear_has_command();
    ::iroha::protocol::SetAccountDetail* temp = _impl_.command_.set_account_detail_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.command_.set_account_detail_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::iroha::protocol::SetAccountDetail& Command::_internal_set_account_detail() const {
  return _internal_has_set_account_detail()
      ? *_impl_.command_.set_account_detail_
      : reinterpret_cast< ::iroha::protocol::SetAccountDetail&>(::iroha::protocol::_SetAccountDetail_default_instance_);
}
inline const ::iroha::protocol::SetAccountDetail& Command::set_account_detail() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.Command.set_account_detail)
  return _internal_set_account_detail();
}
inline ::iroha::protocol::SetAccountDetail* Command::unsafe_arena_release_set_account_detail() {
  // @@protoc_insertion_point(field_unsafe_arena_release:iroha.protocol.Command.set_account_detail)
  if (_internal_has_set_account_detail()) {
    clear_has_command();
    ::iroha::protocol::SetAccountDetail* temp = _impl_.command_.set_account_detail_;
    _impl_.command_.set_account_detail_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Command::unsafe_arena_set_allocated_set_account_detail(::iroha::protocol::SetAccountDetail* set_account_detail) {
  clear_command();
  if (set_account_detail) {
    set_has_set_account_detail();
    _impl_.command_.set_account_detail_ = set_account_detail;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:iroha.protocol.Command.set_account_detail)
}
inline ::iroha::protocol::SetAccountDetail* Command::_internal_mutable_set_account_detail() {
  if (!_internal_has_set_account_detail()) {
    clear_command();
    set_has_set_account_detail();
    _impl_.command_.set_account_detail_ = CreateMaybeMessage< ::iroha::protocol::SetAccountDetail >(GetArenaForAllocation());
  }
  return _impl_.command_.set_account_detail_;
}
inline ::iroha::protocol::SetAccountDetail* Command::mutable_set_account_detail() {
  ::iroha::protocol::SetAccountDetail* _msg = _internal_mutable_set_account_detail();
  // @@protoc_insertion_point(field_mutable:iroha.protocol.Command.set_account_detail)
  return _msg;
}

// .iroha.protocol.SetAccountQuorum set_account_quorum = 14;
inline bool Command::_internal_has_set_account_quorum() const {
  return command_case() == kSetAccountQuorum;
}
inline bool Command::has_set_account_quorum() const {
  return _internal_has_set_account_quorum();
}
inline void Command::set_has_set_account_quorum() {
  _impl_._oneof_case_[0] = kSetAccountQuorum;
}
inline void Command::clear_set_account_quorum() {
  if (_internal_has_set_account_quorum()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.command_.set_account_quorum_;
    }
    clear_has_command();
  }
}
inline ::iroha::protocol::SetAccountQuorum* Command::release_set_account_quorum() {
  // @@protoc_insertion_point(field_release:iroha.protocol.Command.set_account_quorum)
  if (_internal_has_set_account_quorum()) {
    clear_has_command();
    ::iroha::protocol::SetAccountQuorum* temp = _impl_.command_.set_account_quorum_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.command_.set_account_quorum_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::iroha::protocol::SetAccountQuorum& Command::_internal_set_account_quorum() const {
  return _internal_has_set_account_quorum()
      ? *_impl_.command_.set_account_quorum_
      : reinterpret_cast< ::iroha::protocol::SetAccountQuorum&>(::iroha::protocol::_SetAccountQuorum_default_instance_);
}
inline const ::iroha::protocol::SetAccountQuorum& Command::set_account_quorum() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.Command.set_account_quorum)
  return _internal_set_account_quorum();
}
inline ::iroha::protocol::SetAccountQuorum* Command::unsafe_arena_release_set_account_quorum() {
  // @@protoc_insertion_point(field_unsafe_arena_release:iroha.protocol.Command.set_account_quorum)
  if (_internal_has_set_account_quorum()) {
    clear_has_command();
    ::iroha::protocol::SetAccountQuorum* temp = _impl_.command_.set_account_quorum_;
    _impl_.command_.set_account_quorum_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Command::unsafe_arena_set_allocated_set_account_quorum(::iroha::protocol::SetAccountQuorum* set_account_quorum) {
  clear_command();
  if (set_account_quorum) {
    set_has_set_account_quorum();
    _impl_.command_.set_account_quorum_ = set_account_quorum;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:iroha.protocol.Command.set_account_quorum)
}
inline ::iroha::protocol::SetAccountQuorum* Command::_internal_mutable_set_account_quorum() {
  if (!_internal_has_set_account_quorum()) {
    clear_command();
    set_has_set_account_quorum();
    _impl_.command_.set_account_quorum_ = CreateMaybeMessage< ::iroha::protocol::SetAccountQuorum >(GetArenaForAllocation());
  }
  return _impl_.command_.set_account_quorum_;
}
inline ::iroha::protocol::SetAccountQuorum* Command::mutable_set_account_quorum() {
  ::iroha::protocol::SetAccountQuorum* _msg = _internal_mutable_set_account_quorum();
  // @@protoc_insertion_point(field_mutable:iroha.protocol.Command.set_account_quorum)
  return _msg;
}

// .iroha.protocol.SubtractAssetQuantity subtract_asset_quantity = 15;
inline bool Command::_internal_has_subtract_asset_quantity() const {
  return command_case() == kSubtractAssetQuantity;
}
inline bool Command::has_subtract_asset_quantity() const {
  return _internal_has_subtract_asset_quantity();
}
inline void Command::set_has_subtract_asset_quantity() {
  _impl_._oneof_case_[0] = kSubtractAssetQuantity;
}
inline void Command::clear_subtract_asset_quantity() {
  if (_internal_has_subtract_asset_quantity()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.command_.subtract_asset_quantity_;
    }
    clear_has_command();
  }
}
inline ::iroha::protocol::SubtractAssetQuantity* Command::release_subtract_asset_quantity() {
  // @@protoc_insertion_point(field_release:iroha.protocol.Command.subtract_asset_quantity)
  if (_internal_has_subtract_asset_quantity()) {
    clear_has_command();
    ::iroha::protocol::SubtractAssetQuantity* temp = _impl_.command_.subtract_asset_quantity_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.command_.subtract_asset_quantity_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::iroha::protocol::SubtractAssetQuantity& Command::_internal_subtract_asset_quantity() const {
  return _internal_has_subtract_asset_quantity()
      ? *_impl_.command_.subtract_asset_quantity_
      : reinterpret_cast< ::iroha::protocol::SubtractAssetQuantity&>(::iroha::protocol::_SubtractAssetQuantity_default_instance_);
}
inline const ::iroha::protocol::SubtractAssetQuantity& Command::subtract_asset_quantity() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.Command.subtract_asset_quantity)
  return _internal_subtract_asset_quantity();
}
inline ::iroha::protocol::SubtractAssetQuantity* Command::unsafe_arena_release_subtract_asset_quantity() {
  // @@protoc_insertion_point(field_unsafe_arena_release:iroha.protocol.Command.subtract_asset_quantity)
  if (_internal_has_subtract_asset_quantity()) {
    clear_has_command();
    ::iroha::protocol::SubtractAssetQuantity* temp = _impl_.command_.subtract_asset_quantity_;
    _impl_.command_.subtract_asset_quantity_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Command::unsafe_arena_set_allocated_subtract_asset_quantity(::iroha::protocol::SubtractAssetQuantity* subtract_asset_quantity) {
  clear_command();
  if (subtract_asset_quantity) {
    set_has_subtract_asset_quantity();
    _impl_.command_.subtract_asset_quantity_ = subtract_asset_quantity;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:iroha.protocol.Command.subtract_asset_quantity)
}
inline ::iroha::protocol::SubtractAssetQuantity* Command::_internal_mutable_subtract_asset_quantity() {
  if (!_internal_has_subtract_asset_quantity()) {
    clear_command();
    set_has_subtract_asset_quantity();
    _impl_.command_.subtract_asset_quantity_ = CreateMaybeMessage< ::iroha::protocol::SubtractAssetQuantity >(GetArenaForAllocation());
  }
  return _impl_.command_.subtract_asset_quantity_;
}
inline ::iroha::protocol::SubtractAssetQuantity* Command::mutable_subtract_asset_quantity() {
  ::iroha::protocol::SubtractAssetQuantity* _msg = _internal_mutable_subtract_asset_quantity();
  // @@protoc_insertion_point(field_mutable:iroha.protocol.Command.subtract_asset_quantity)
  return _msg;
}

// .iroha.protocol.TransferAsset transfer_asset = 16;
inline bool Command::_internal_has_transfer_asset() const {
  return command_case() == kTransferAsset;
}
inline bool Command::has_transfer_asset() const {
  return _internal_has_transfer_asset();
}
inline void Command::set_has_transfer_asset() {
  _impl_._oneof_case_[0] = kTransferAsset;
}
inline void Command::clear_transfer_asset() {
  if (_internal_has_transfer_asset()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.command_.transfer_asset_;
    }
    clear_has_command();
  }
}
inline ::iroha::protocol::TransferAsset* Command::release_transfer_asset() {
  // @@protoc_insertion_point(field_release:iroha.protocol.Command.transfer_asset)
  if (_internal_has_transfer_asset()) {
    clear_has_command();
    ::iroha::protocol::TransferAsset* temp = _impl_.command_.transfer_asset_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.command_.transfer_asset_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::iroha::protocol::TransferAsset& Command::_internal_transfer_asset() const {
  return _internal_has_transfer_asset()
      ? *_impl_.command_.transfer_asset_
      : reinterpret_cast< ::iroha::protocol::TransferAsset&>(::iroha::protocol::_TransferAsset_default_instance_);
}
inline const ::iroha::protocol::TransferAsset& Command::transfer_asset() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.Command.transfer_asset)
  return _internal_transfer_asset();
}
inline ::iroha::protocol::TransferAsset* Command::unsafe_arena_release_transfer_asset() {
  // @@protoc_insertion_point(field_unsafe_arena_release:iroha.protocol.Command.transfer_asset)
  if (_internal_has_transfer_asset()) {
    clear_has_command();
    ::iroha::protocol::TransferAsset* temp = _impl_.command_.transfer_asset_;
    _impl_.command_.transfer_asset_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Command::unsafe_arena_set_allocated_transfer_asset(::iroha::protocol::TransferAsset* transfer_asset) {
  clear_command();
  if (transfer_asset) {
    set_has_transfer_asset();
    _impl_.command_.transfer_asset_ = transfer_asset;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:iroha.protocol.Command.transfer_asset)
}
inline ::iroha::protocol::TransferAsset* Command::_internal_mutable_transfer_asset() {
  if (!_internal_has_transfer_asset()) {
    clear_command();
    set_has_transfer_asset();
    _impl_.command_.transfer_asset_ = CreateMaybeMessage< ::iroha::protocol::TransferAsset >(GetArenaForAllocation());
  }
  return _impl_.command_.transfer_asset_;
}
inline ::iroha::protocol::TransferAsset* Command::mutable_transfer_asset() {
  ::iroha::protocol::TransferAsset* _msg = _internal_mutable_transfer_asset();
  // @@protoc_insertion_point(field_mutable:iroha.protocol.Command.transfer_asset)
  return _msg;
}

// .iroha.protocol.RemovePeer remove_peer = 17;
inline bool Command::_internal_has_remove_peer() const {
  return command_case() == kRemovePeer;
}
inline bool Command::has_remove_peer() const {
  return _internal_has_remove_peer();
}
inline void Command::set_has_remove_peer() {
  _impl_._oneof_case_[0] = kRemovePeer;
}
inline void Command::clear_remove_peer() {
  if (_internal_has_remove_peer()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.command_.remove_peer_;
    }
    clear_has_command();
  }
}
inline ::iroha::protocol::RemovePeer* Command::release_remove_peer() {
  // @@protoc_insertion_point(field_release:iroha.protocol.Command.remove_peer)
  if (_internal_has_remove_peer()) {
    clear_has_command();
    ::iroha::protocol::RemovePeer* temp = _impl_.command_.remove_peer_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.command_.remove_peer_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::iroha::protocol::RemovePeer& Command::_internal_remove_peer() const {
  return _internal_has_remove_peer()
      ? *_impl_.command_.remove_peer_
      : reinterpret_cast< ::iroha::protocol::RemovePeer&>(::iroha::protocol::_RemovePeer_default_instance_);
}
inline const ::iroha::protocol::RemovePeer& Command::remove_peer() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.Command.remove_peer)
  return _internal_remove_peer();
}
inline ::iroha::protocol::RemovePeer* Command::unsafe_arena_release_remove_peer() {
  // @@protoc_insertion_point(field_unsafe_arena_release:iroha.protocol.Command.remove_peer)
  if (_internal_has_remove_peer()) {
    clear_has_command();
    ::iroha::protocol::RemovePeer* temp = _impl_.command_.remove_peer_;
    _impl_.command_.remove_peer_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Command::unsafe_arena_set_allocated_remove_peer(::iroha::protocol::RemovePeer* remove_peer) {
  clear_command();
  if (remove_peer) {
    set_has_remove_peer();
    _impl_.command_.remove_peer_ = remove_peer;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:iroha.protocol.Command.remove_peer)
}
inline ::iroha::protocol::RemovePeer* Command::_internal_mutable_remove_peer() {
  if (!_internal_has_remove_peer()) {
    clear_command();
    set_has_remove_peer();
    _impl_.command_.remove_peer_ = CreateMaybeMessage< ::iroha::protocol::RemovePeer >(GetArenaForAllocation());
  }
  return _impl_.command_.remove_peer_;
}
inline ::iroha::protocol::RemovePeer* Command::mutable_remove_peer() {
  ::iroha::protocol::RemovePeer* _msg = _internal_mutable_remove_peer();
  // @@protoc_insertion_point(field_mutable:iroha.protocol.Command.remove_peer)
  return _msg;
}

// .iroha.protocol.CompareAndSetAccountDetail compare_and_set_account_detail = 18;
inline bool Command::_internal_has_compare_and_set_account_detail() const {
  return command_case() == kCompareAndSetAccountDetail;
}
inline bool Command::has_compare_and_set_account_detail() const {
  return _internal_has_compare_and_set_account_detail();
}
inline void Command::set_has_compare_and_set_account_detail() {
  _impl_._oneof_case_[0] = kCompareAndSetAccountDetail;
}
inline void Command::clear_compare_and_set_account_detail() {
  if (_internal_has_compare_and_set_account_detail()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.command_.compare_and_set_account_detail_;
    }
    clear_has_command();
  }
}
inline ::iroha::protocol::CompareAndSetAccountDetail* Command::release_compare_and_set_account_detail() {
  // @@protoc_insertion_point(field_release:iroha.protocol.Command.compare_and_set_account_detail)
  if (_internal_has_compare_and_set_account_detail()) {
    clear_has_command();
    ::iroha::protocol::CompareAndSetAccountDetail* temp = _impl_.command_.compare_and_set_account_detail_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.command_.compare_and_set_account_detail_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::iroha::protocol::CompareAndSetAccountDetail& Command::_internal_compare_and_set_account_detail() const {
  return _internal_has_compare_and_set_account_detail()
      ? *_impl_.command_.compare_and_set_account_detail_
      : reinterpret_cast< ::iroha::protocol::CompareAndSetAccountDetail&>(::iroha::protocol::_CompareAndSetAccountDetail_default_instance_);
}
inline const ::iroha::protocol::CompareAndSetAccountDetail& Command::compare_and_set_account_detail() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.Command.compare_and_set_account_detail)
  return _internal_compare_and_set_account_detail();
}
inline ::iroha::protocol::CompareAndSetAccountDetail* Command::unsafe_arena_release_compare_and_set_account_detail() {
  // @@protoc_insertion_point(field_unsafe_arena_release:iroha.protocol.Command.compare_and_set_account_detail)
  if (_internal_has_compare_and_set_account_detail()) {
    clear_has_command();
    ::iroha::protocol::CompareAndSetAccountDetail* temp = _impl_.command_.compare_and_set_account_detail_;
    _impl_.command_.compare_and_set_account_detail_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Command::unsafe_arena_set_allocated_compare_and_set_account_detail(::iroha::protocol::CompareAndSetAccountDetail* compare_and_set_account_detail) {
  clear_command();
  if (compare_and_set_account_detail) {
    set_has_compare_and_set_account_detail();
    _impl_.command_.compare_and_set_account_detail_ = compare_and_set_account_detail;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:iroha.protocol.Command.compare_and_set_account_detail)
}
inline ::iroha::protocol::CompareAndSetAccountDetail* Command::_internal_mutable_compare_and_set_account_detail() {
  if (!_internal_has_compare_and_set_account_detail()) {
    clear_command();
    set_has_compare_and_set_account_detail();
    _impl_.command_.compare_and_set_account_detail_ = CreateMaybeMessage< ::iroha::protocol::CompareAndSetAccountDetail >(GetArenaForAllocation());
  }
  return _impl_.command_.compare_and_set_account_detail_;
}
inline ::iroha::protocol::CompareAndSetAccountDetail* Command::mutable_compare_and_set_account_detail() {
  ::iroha::protocol::CompareAndSetAccountDetail* _msg = _internal_mutable_compare_and_set_account_detail();
  // @@protoc_insertion_point(field_mutable:iroha.protocol.Command.compare_and_set_account_detail)
  return _msg;
}

// .iroha.protocol.SetSettingValue set_setting_value = 19;
inline bool Command::_internal_has_set_setting_value() const {
  return command_case() == kSetSettingValue;
}
inline bool Command::has_set_setting_value() const {
  return _internal_has_set_setting_value();
}
inline void Command::set_has_set_setting_value() {
  _impl_._oneof_case_[0] = kSetSettingValue;
}
inline void Command::clear_set_setting_value() {
  if (_internal_has_set_setting_value()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.command_.set_setting_value_;
    }
    clear_has_command();
  }
}
inline ::iroha::protocol::SetSettingValue* Command::release_set_setting_value() {
  // @@protoc_insertion_point(field_release:iroha.protocol.Command.set_setting_value)
  if (_internal_has_set_setting_value()) {
    clear_has_command();
    ::iroha::protocol::SetSettingValue* temp = _impl_.command_.set_setting_value_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.command_.set_setting_value_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::iroha::protocol::SetSettingValue& Command::_internal_set_setting_value() const {
  return _internal_has_set_setting_value()
      ? *_impl_.command_.set_setting_value_
      : reinterpret_cast< ::iroha::protocol::SetSettingValue&>(::iroha::protocol::_SetSettingValue_default_instance_);
}
inline const ::iroha::protocol::SetSettingValue& Command::set_setting_value() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.Command.set_setting_value)
  return _internal_set_setting_value();
}
inline ::iroha::protocol::SetSettingValue* Command::unsafe_arena_release_set_setting_value() {
  // @@protoc_insertion_point(field_unsafe_arena_release:iroha.protocol.Command.set_setting_value)
  if (_internal_has_set_setting_value()) {
    clear_has_command();
    ::iroha::protocol::SetSettingValue* temp = _impl_.command_.set_setting_value_;
    _impl_.command_.set_setting_value_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Command::unsafe_arena_set_allocated_set_setting_value(::iroha::protocol::SetSettingValue* set_setting_value) {
  clear_command();
  if (set_setting_value) {
    set_has_set_setting_value();
    _impl_.command_.set_setting_value_ = set_setting_value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:iroha.protocol.Command.set_setting_value)
}
inline ::iroha::protocol::SetSettingValue* Command::_internal_mutable_set_setting_value() {
  if (!_internal_has_set_setting_value()) {
    clear_command();
    set_has_set_setting_value();
    _impl_.command_.set_setting_value_ = CreateMaybeMessage< ::iroha::protocol::SetSettingValue >(GetArenaForAllocation());
  }
  return _impl_.command_.set_setting_value_;
}
inline ::iroha::protocol::SetSettingValue* Command::mutable_set_setting_value() {
  ::iroha::protocol::SetSettingValue* _msg = _internal_mutable_set_setting_value();
  // @@protoc_insertion_point(field_mutable:iroha.protocol.Command.set_setting_value)
  return _msg;
}

// .iroha.protocol.CallEngine call_engine = 20;
inline bool Command::_internal_has_call_engine() const {
  return command_case() == kCallEngine;
}
inline bool Command::has_call_engine() const {
  return _internal_has_call_engine();
}
inline void Command::set_has_call_engine() {
  _impl_._oneof_case_[0] = kCallEngine;
}
inline void Command::clear_call_engine() {
  if (_internal_has_call_engine()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.command_.call_engine_;
    }
    clear_has_command();
  }
}
inline ::iroha::protocol::CallEngine* Command::release_call_engine() {
  // @@protoc_insertion_point(field_release:iroha.protocol.Command.call_engine)
  if (_internal_has_call_engine()) {
    clear_has_command();
    ::iroha::protocol::CallEngine* temp = _impl_.command_.call_engine_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.command_.call_engine_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::iroha::protocol::CallEngine& Command::_internal_call_engine() const {
  return _internal_has_call_engine()
      ? *_impl_.command_.call_engine_
      : reinterpret_cast< ::iroha::protocol::CallEngine&>(::iroha::protocol::_CallEngine_default_instance_);
}
inline const ::iroha::protocol::CallEngine& Command::call_engine() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.Command.call_engine)
  return _internal_call_engine();
}
inline ::iroha::protocol::CallEngine* Command::unsafe_arena_release_call_engine() {
  // @@protoc_insertion_point(field_unsafe_arena_release:iroha.protocol.Command.call_engine)
  if (_internal_has_call_engine()) {
    clear_has_command();
    ::iroha::protocol::CallEngine* temp = _impl_.command_.call_engine_;
    _impl_.command_.call_engine_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Command::unsafe_arena_set_allocated_call_engine(::iroha::protocol::CallEngine* call_engine) {
  clear_command();
  if (call_engine) {
    set_has_call_engine();
    _impl_.command_.call_engine_ = call_engine;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:iroha.protocol.Command.call_engine)
}
inline ::iroha::protocol::CallEngine* Command::_internal_mutable_call_engine() {
  if (!_internal_has_call_engine()) {
    clear_command();
    set_has_call_engine();
    _impl_.command_.call_engine_ = CreateMaybeMessage< ::iroha::protocol::CallEngine >(GetArenaForAllocation());
  }
  return _impl_.command_.call_engine_;
}
inline ::iroha::protocol::CallEngine* Command::mutable_call_engine() {
  ::iroha::protocol::CallEngine* _msg = _internal_mutable_call_engine();
  // @@protoc_insertion_point(field_mutable:iroha.protocol.Command.call_engine)
  return _msg;
}

inline bool Command::has_command() const {
  return command_case() != COMMAND_NOT_SET;
}
inline void Command::clear_has_command() {
  _impl_._oneof_case_[0] = COMMAND_NOT_SET;
}
inline Command::CommandCase Command::command_case() const {
  return Command::CommandCase(_impl_._oneof_case_[0]);
}
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace protocol
}  // namespace iroha

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::iroha::protocol::CallEngine_EngineType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::iroha::protocol::CallEngine_EngineType>() {
  return ::iroha::protocol::CallEngine_EngineType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_commands_2eproto
