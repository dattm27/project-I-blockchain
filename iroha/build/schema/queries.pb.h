// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: queries.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_queries_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_queries_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "primitive.pb.h"
#include <google/protobuf/timestamp.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_queries_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_queries_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_queries_2eproto;
namespace iroha {
namespace protocol {
class AccountDetailPaginationMeta;
struct AccountDetailPaginationMetaDefaultTypeInternal;
extern AccountDetailPaginationMetaDefaultTypeInternal _AccountDetailPaginationMeta_default_instance_;
class AssetPaginationMeta;
struct AssetPaginationMetaDefaultTypeInternal;
extern AssetPaginationMetaDefaultTypeInternal _AssetPaginationMeta_default_instance_;
class BlocksQuery;
struct BlocksQueryDefaultTypeInternal;
extern BlocksQueryDefaultTypeInternal _BlocksQuery_default_instance_;
class GetAccount;
struct GetAccountDefaultTypeInternal;
extern GetAccountDefaultTypeInternal _GetAccount_default_instance_;
class GetAccountAssetTransactions;
struct GetAccountAssetTransactionsDefaultTypeInternal;
extern GetAccountAssetTransactionsDefaultTypeInternal _GetAccountAssetTransactions_default_instance_;
class GetAccountAssets;
struct GetAccountAssetsDefaultTypeInternal;
extern GetAccountAssetsDefaultTypeInternal _GetAccountAssets_default_instance_;
class GetAccountDetail;
struct GetAccountDetailDefaultTypeInternal;
extern GetAccountDetailDefaultTypeInternal _GetAccountDetail_default_instance_;
class GetAccountTransactions;
struct GetAccountTransactionsDefaultTypeInternal;
extern GetAccountTransactionsDefaultTypeInternal _GetAccountTransactions_default_instance_;
class GetAssetInfo;
struct GetAssetInfoDefaultTypeInternal;
extern GetAssetInfoDefaultTypeInternal _GetAssetInfo_default_instance_;
class GetBlock;
struct GetBlockDefaultTypeInternal;
extern GetBlockDefaultTypeInternal _GetBlock_default_instance_;
class GetEngineReceipts;
struct GetEngineReceiptsDefaultTypeInternal;
extern GetEngineReceiptsDefaultTypeInternal _GetEngineReceipts_default_instance_;
class GetPeers;
struct GetPeersDefaultTypeInternal;
extern GetPeersDefaultTypeInternal _GetPeers_default_instance_;
class GetPendingTransactions;
struct GetPendingTransactionsDefaultTypeInternal;
extern GetPendingTransactionsDefaultTypeInternal _GetPendingTransactions_default_instance_;
class GetRolePermissions;
struct GetRolePermissionsDefaultTypeInternal;
extern GetRolePermissionsDefaultTypeInternal _GetRolePermissions_default_instance_;
class GetRoles;
struct GetRolesDefaultTypeInternal;
extern GetRolesDefaultTypeInternal _GetRoles_default_instance_;
class GetSignatories;
struct GetSignatoriesDefaultTypeInternal;
extern GetSignatoriesDefaultTypeInternal _GetSignatories_default_instance_;
class GetTransactions;
struct GetTransactionsDefaultTypeInternal;
extern GetTransactionsDefaultTypeInternal _GetTransactions_default_instance_;
class Ordering;
struct OrderingDefaultTypeInternal;
extern OrderingDefaultTypeInternal _Ordering_default_instance_;
class Ordering_FieldOrdering;
struct Ordering_FieldOrderingDefaultTypeInternal;
extern Ordering_FieldOrderingDefaultTypeInternal _Ordering_FieldOrdering_default_instance_;
class Query;
struct QueryDefaultTypeInternal;
extern QueryDefaultTypeInternal _Query_default_instance_;
class QueryPayloadMeta;
struct QueryPayloadMetaDefaultTypeInternal;
extern QueryPayloadMetaDefaultTypeInternal _QueryPayloadMeta_default_instance_;
class Query_Payload;
struct Query_PayloadDefaultTypeInternal;
extern Query_PayloadDefaultTypeInternal _Query_Payload_default_instance_;
class TxPaginationMeta;
struct TxPaginationMetaDefaultTypeInternal;
extern TxPaginationMetaDefaultTypeInternal _TxPaginationMeta_default_instance_;
}  // namespace protocol
}  // namespace iroha
PROTOBUF_NAMESPACE_OPEN
template<> ::iroha::protocol::AccountDetailPaginationMeta* Arena::CreateMaybeMessage<::iroha::protocol::AccountDetailPaginationMeta>(Arena*);
template<> ::iroha::protocol::AssetPaginationMeta* Arena::CreateMaybeMessage<::iroha::protocol::AssetPaginationMeta>(Arena*);
template<> ::iroha::protocol::BlocksQuery* Arena::CreateMaybeMessage<::iroha::protocol::BlocksQuery>(Arena*);
template<> ::iroha::protocol::GetAccount* Arena::CreateMaybeMessage<::iroha::protocol::GetAccount>(Arena*);
template<> ::iroha::protocol::GetAccountAssetTransactions* Arena::CreateMaybeMessage<::iroha::protocol::GetAccountAssetTransactions>(Arena*);
template<> ::iroha::protocol::GetAccountAssets* Arena::CreateMaybeMessage<::iroha::protocol::GetAccountAssets>(Arena*);
template<> ::iroha::protocol::GetAccountDetail* Arena::CreateMaybeMessage<::iroha::protocol::GetAccountDetail>(Arena*);
template<> ::iroha::protocol::GetAccountTransactions* Arena::CreateMaybeMessage<::iroha::protocol::GetAccountTransactions>(Arena*);
template<> ::iroha::protocol::GetAssetInfo* Arena::CreateMaybeMessage<::iroha::protocol::GetAssetInfo>(Arena*);
template<> ::iroha::protocol::GetBlock* Arena::CreateMaybeMessage<::iroha::protocol::GetBlock>(Arena*);
template<> ::iroha::protocol::GetEngineReceipts* Arena::CreateMaybeMessage<::iroha::protocol::GetEngineReceipts>(Arena*);
template<> ::iroha::protocol::GetPeers* Arena::CreateMaybeMessage<::iroha::protocol::GetPeers>(Arena*);
template<> ::iroha::protocol::GetPendingTransactions* Arena::CreateMaybeMessage<::iroha::protocol::GetPendingTransactions>(Arena*);
template<> ::iroha::protocol::GetRolePermissions* Arena::CreateMaybeMessage<::iroha::protocol::GetRolePermissions>(Arena*);
template<> ::iroha::protocol::GetRoles* Arena::CreateMaybeMessage<::iroha::protocol::GetRoles>(Arena*);
template<> ::iroha::protocol::GetSignatories* Arena::CreateMaybeMessage<::iroha::protocol::GetSignatories>(Arena*);
template<> ::iroha::protocol::GetTransactions* Arena::CreateMaybeMessage<::iroha::protocol::GetTransactions>(Arena*);
template<> ::iroha::protocol::Ordering* Arena::CreateMaybeMessage<::iroha::protocol::Ordering>(Arena*);
template<> ::iroha::protocol::Ordering_FieldOrdering* Arena::CreateMaybeMessage<::iroha::protocol::Ordering_FieldOrdering>(Arena*);
template<> ::iroha::protocol::Query* Arena::CreateMaybeMessage<::iroha::protocol::Query>(Arena*);
template<> ::iroha::protocol::QueryPayloadMeta* Arena::CreateMaybeMessage<::iroha::protocol::QueryPayloadMeta>(Arena*);
template<> ::iroha::protocol::Query_Payload* Arena::CreateMaybeMessage<::iroha::protocol::Query_Payload>(Arena*);
template<> ::iroha::protocol::TxPaginationMeta* Arena::CreateMaybeMessage<::iroha::protocol::TxPaginationMeta>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace iroha {
namespace protocol {

enum Field : int {
  kCreatedTime = 0,
  kPosition = 1,
  Field_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Field_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Field_IsValid(int value);
constexpr Field Field_MIN = kCreatedTime;
constexpr Field Field_MAX = kPosition;
constexpr int Field_ARRAYSIZE = Field_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Field_descriptor();
template<typename T>
inline const std::string& Field_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Field>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Field_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Field_descriptor(), enum_t_value);
}
inline bool Field_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Field* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Field>(
    Field_descriptor(), name, value);
}
enum Direction : int {
  kAscending = 0,
  kDescending = 1,
  Direction_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Direction_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Direction_IsValid(int value);
constexpr Direction Direction_MIN = kAscending;
constexpr Direction Direction_MAX = kDescending;
constexpr int Direction_ARRAYSIZE = Direction_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Direction_descriptor();
template<typename T>
inline const std::string& Direction_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Direction>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Direction_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Direction_descriptor(), enum_t_value);
}
inline bool Direction_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Direction* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Direction>(
    Direction_descriptor(), name, value);
}
// ===================================================================

class Ordering_FieldOrdering final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:iroha.protocol.Ordering.FieldOrdering) */ {
 public:
  inline Ordering_FieldOrdering() : Ordering_FieldOrdering(nullptr) {}
  ~Ordering_FieldOrdering() override;
  explicit PROTOBUF_CONSTEXPR Ordering_FieldOrdering(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Ordering_FieldOrdering(const Ordering_FieldOrdering& from);
  Ordering_FieldOrdering(Ordering_FieldOrdering&& from) noexcept
    : Ordering_FieldOrdering() {
    *this = ::std::move(from);
  }

  inline Ordering_FieldOrdering& operator=(const Ordering_FieldOrdering& from) {
    CopyFrom(from);
    return *this;
  }
  inline Ordering_FieldOrdering& operator=(Ordering_FieldOrdering&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Ordering_FieldOrdering& default_instance() {
    return *internal_default_instance();
  }
  static inline const Ordering_FieldOrdering* internal_default_instance() {
    return reinterpret_cast<const Ordering_FieldOrdering*>(
               &_Ordering_FieldOrdering_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Ordering_FieldOrdering& a, Ordering_FieldOrdering& b) {
    a.Swap(&b);
  }
  inline void Swap(Ordering_FieldOrdering* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Ordering_FieldOrdering* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Ordering_FieldOrdering* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Ordering_FieldOrdering>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Ordering_FieldOrdering& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Ordering_FieldOrdering& from) {
    Ordering_FieldOrdering::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Ordering_FieldOrdering* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "iroha.protocol.Ordering.FieldOrdering";
  }
  protected:
  explicit Ordering_FieldOrdering(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFieldFieldNumber = 1,
    kDirectionFieldNumber = 2,
  };
  // .iroha.protocol.Field field = 1;
  void clear_field();
  ::iroha::protocol::Field field() const;
  void set_field(::iroha::protocol::Field value);
  private:
  ::iroha::protocol::Field _internal_field() const;
  void _internal_set_field(::iroha::protocol::Field value);
  public:

  // .iroha.protocol.Direction direction = 2;
  void clear_direction();
  ::iroha::protocol::Direction direction() const;
  void set_direction(::iroha::protocol::Direction value);
  private:
  ::iroha::protocol::Direction _internal_direction() const;
  void _internal_set_direction(::iroha::protocol::Direction value);
  public:

  // @@protoc_insertion_point(class_scope:iroha.protocol.Ordering.FieldOrdering)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int field_;
    int direction_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_queries_2eproto;
};
// -------------------------------------------------------------------

class Ordering final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:iroha.protocol.Ordering) */ {
 public:
  inline Ordering() : Ordering(nullptr) {}
  ~Ordering() override;
  explicit PROTOBUF_CONSTEXPR Ordering(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Ordering(const Ordering& from);
  Ordering(Ordering&& from) noexcept
    : Ordering() {
    *this = ::std::move(from);
  }

  inline Ordering& operator=(const Ordering& from) {
    CopyFrom(from);
    return *this;
  }
  inline Ordering& operator=(Ordering&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Ordering& default_instance() {
    return *internal_default_instance();
  }
  static inline const Ordering* internal_default_instance() {
    return reinterpret_cast<const Ordering*>(
               &_Ordering_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Ordering& a, Ordering& b) {
    a.Swap(&b);
  }
  inline void Swap(Ordering* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Ordering* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Ordering* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Ordering>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Ordering& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Ordering& from) {
    Ordering::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Ordering* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "iroha.protocol.Ordering";
  }
  protected:
  explicit Ordering(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Ordering_FieldOrdering FieldOrdering;

  // accessors -------------------------------------------------------

  enum : int {
    kSequenceFieldNumber = 1,
  };
  // repeated .iroha.protocol.Ordering.FieldOrdering sequence = 1;
  int sequence_size() const;
  private:
  int _internal_sequence_size() const;
  public:
  void clear_sequence();
  ::iroha::protocol::Ordering_FieldOrdering* mutable_sequence(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::iroha::protocol::Ordering_FieldOrdering >*
      mutable_sequence();
  private:
  const ::iroha::protocol::Ordering_FieldOrdering& _internal_sequence(int index) const;
  ::iroha::protocol::Ordering_FieldOrdering* _internal_add_sequence();
  public:
  const ::iroha::protocol::Ordering_FieldOrdering& sequence(int index) const;
  ::iroha::protocol::Ordering_FieldOrdering* add_sequence();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::iroha::protocol::Ordering_FieldOrdering >&
      sequence() const;

  // @@protoc_insertion_point(class_scope:iroha.protocol.Ordering)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::iroha::protocol::Ordering_FieldOrdering > sequence_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_queries_2eproto;
};
// -------------------------------------------------------------------

class TxPaginationMeta final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:iroha.protocol.TxPaginationMeta) */ {
 public:
  inline TxPaginationMeta() : TxPaginationMeta(nullptr) {}
  ~TxPaginationMeta() override;
  explicit PROTOBUF_CONSTEXPR TxPaginationMeta(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TxPaginationMeta(const TxPaginationMeta& from);
  TxPaginationMeta(TxPaginationMeta&& from) noexcept
    : TxPaginationMeta() {
    *this = ::std::move(from);
  }

  inline TxPaginationMeta& operator=(const TxPaginationMeta& from) {
    CopyFrom(from);
    return *this;
  }
  inline TxPaginationMeta& operator=(TxPaginationMeta&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TxPaginationMeta& default_instance() {
    return *internal_default_instance();
  }
  enum OptFirstTxHashCase {
    kFirstTxHash = 2,
    OPT_FIRST_TX_HASH_NOT_SET = 0,
  };

  enum OptFirstTxTimeCase {
    kFirstTxTime = 4,
    OPT_FIRST_TX_TIME_NOT_SET = 0,
  };

  enum OptLastTxTimeCase {
    kLastTxTime = 5,
    OPT_LAST_TX_TIME_NOT_SET = 0,
  };

  enum OptFirstTxHeightCase {
    kFirstTxHeight = 6,
    OPT_FIRST_TX_HEIGHT_NOT_SET = 0,
  };

  enum OptLastTxHeightCase {
    kLastTxHeight = 7,
    OPT_LAST_TX_HEIGHT_NOT_SET = 0,
  };

  static inline const TxPaginationMeta* internal_default_instance() {
    return reinterpret_cast<const TxPaginationMeta*>(
               &_TxPaginationMeta_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(TxPaginationMeta& a, TxPaginationMeta& b) {
    a.Swap(&b);
  }
  inline void Swap(TxPaginationMeta* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TxPaginationMeta* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TxPaginationMeta* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TxPaginationMeta>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TxPaginationMeta& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TxPaginationMeta& from) {
    TxPaginationMeta::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TxPaginationMeta* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "iroha.protocol.TxPaginationMeta";
  }
  protected:
  explicit TxPaginationMeta(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOrderingFieldNumber = 3,
    kPageSizeFieldNumber = 1,
    kFirstTxHashFieldNumber = 2,
    kFirstTxTimeFieldNumber = 4,
    kLastTxTimeFieldNumber = 5,
    kFirstTxHeightFieldNumber = 6,
    kLastTxHeightFieldNumber = 7,
  };
  // .iroha.protocol.Ordering ordering = 3;
  bool has_ordering() const;
  private:
  bool _internal_has_ordering() const;
  public:
  void clear_ordering();
  const ::iroha::protocol::Ordering& ordering() const;
  PROTOBUF_NODISCARD ::iroha::protocol::Ordering* release_ordering();
  ::iroha::protocol::Ordering* mutable_ordering();
  void set_allocated_ordering(::iroha::protocol::Ordering* ordering);
  private:
  const ::iroha::protocol::Ordering& _internal_ordering() const;
  ::iroha::protocol::Ordering* _internal_mutable_ordering();
  public:
  void unsafe_arena_set_allocated_ordering(
      ::iroha::protocol::Ordering* ordering);
  ::iroha::protocol::Ordering* unsafe_arena_release_ordering();

  // uint32 page_size = 1;
  void clear_page_size();
  uint32_t page_size() const;
  void set_page_size(uint32_t value);
  private:
  uint32_t _internal_page_size() const;
  void _internal_set_page_size(uint32_t value);
  public:

  // string first_tx_hash = 2;
  bool has_first_tx_hash() const;
  private:
  bool _internal_has_first_tx_hash() const;
  public:
  void clear_first_tx_hash();
  const std::string& first_tx_hash() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_first_tx_hash(ArgT0&& arg0, ArgT... args);
  std::string* mutable_first_tx_hash();
  PROTOBUF_NODISCARD std::string* release_first_tx_hash();
  void set_allocated_first_tx_hash(std::string* first_tx_hash);
  private:
  const std::string& _internal_first_tx_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_first_tx_hash(const std::string& value);
  std::string* _internal_mutable_first_tx_hash();
  public:

  // .google.protobuf.Timestamp first_tx_time = 4;
  bool has_first_tx_time() const;
  private:
  bool _internal_has_first_tx_time() const;
  public:
  void clear_first_tx_time();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& first_tx_time() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_first_tx_time();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_first_tx_time();
  void set_allocated_first_tx_time(::PROTOBUF_NAMESPACE_ID::Timestamp* first_tx_time);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_first_tx_time() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_first_tx_time();
  public:
  void unsafe_arena_set_allocated_first_tx_time(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* first_tx_time);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_first_tx_time();

  // .google.protobuf.Timestamp last_tx_time = 5;
  bool has_last_tx_time() const;
  private:
  bool _internal_has_last_tx_time() const;
  public:
  void clear_last_tx_time();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& last_tx_time() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_last_tx_time();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_last_tx_time();
  void set_allocated_last_tx_time(::PROTOBUF_NAMESPACE_ID::Timestamp* last_tx_time);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_last_tx_time() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_last_tx_time();
  public:
  void unsafe_arena_set_allocated_last_tx_time(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* last_tx_time);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_last_tx_time();

  // uint64 first_tx_height = 6;
  bool has_first_tx_height() const;
  private:
  bool _internal_has_first_tx_height() const;
  public:
  void clear_first_tx_height();
  uint64_t first_tx_height() const;
  void set_first_tx_height(uint64_t value);
  private:
  uint64_t _internal_first_tx_height() const;
  void _internal_set_first_tx_height(uint64_t value);
  public:

  // uint64 last_tx_height = 7;
  bool has_last_tx_height() const;
  private:
  bool _internal_has_last_tx_height() const;
  public:
  void clear_last_tx_height();
  uint64_t last_tx_height() const;
  void set_last_tx_height(uint64_t value);
  private:
  uint64_t _internal_last_tx_height() const;
  void _internal_set_last_tx_height(uint64_t value);
  public:

  void clear_opt_first_tx_hash();
  OptFirstTxHashCase opt_first_tx_hash_case() const;
  void clear_opt_first_tx_time();
  OptFirstTxTimeCase opt_first_tx_time_case() const;
  void clear_opt_last_tx_time();
  OptLastTxTimeCase opt_last_tx_time_case() const;
  void clear_opt_first_tx_height();
  OptFirstTxHeightCase opt_first_tx_height_case() const;
  void clear_opt_last_tx_height();
  OptLastTxHeightCase opt_last_tx_height_case() const;
  // @@protoc_insertion_point(class_scope:iroha.protocol.TxPaginationMeta)
 private:
  class _Internal;
  void set_has_first_tx_hash();
  void set_has_first_tx_time();
  void set_has_last_tx_time();
  void set_has_first_tx_height();
  void set_has_last_tx_height();

  inline bool has_opt_first_tx_hash() const;
  inline void clear_has_opt_first_tx_hash();

  inline bool has_opt_first_tx_time() const;
  inline void clear_has_opt_first_tx_time();

  inline bool has_opt_last_tx_time() const;
  inline void clear_has_opt_last_tx_time();

  inline bool has_opt_first_tx_height() const;
  inline void clear_has_opt_first_tx_height();

  inline bool has_opt_last_tx_height() const;
  inline void clear_has_opt_last_tx_height();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::iroha::protocol::Ordering* ordering_;
    uint32_t page_size_;
    union OptFirstTxHashUnion {
      constexpr OptFirstTxHashUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr first_tx_hash_;
    } opt_first_tx_hash_;
    union OptFirstTxTimeUnion {
      constexpr OptFirstTxTimeUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::PROTOBUF_NAMESPACE_ID::Timestamp* first_tx_time_;
    } opt_first_tx_time_;
    union OptLastTxTimeUnion {
      constexpr OptLastTxTimeUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::PROTOBUF_NAMESPACE_ID::Timestamp* last_tx_time_;
    } opt_last_tx_time_;
    union OptFirstTxHeightUnion {
      constexpr OptFirstTxHeightUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      uint64_t first_tx_height_;
    } opt_first_tx_height_;
    union OptLastTxHeightUnion {
      constexpr OptLastTxHeightUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      uint64_t last_tx_height_;
    } opt_last_tx_height_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[5];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_queries_2eproto;
};
// -------------------------------------------------------------------

class AssetPaginationMeta final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:iroha.protocol.AssetPaginationMeta) */ {
 public:
  inline AssetPaginationMeta() : AssetPaginationMeta(nullptr) {}
  ~AssetPaginationMeta() override;
  explicit PROTOBUF_CONSTEXPR AssetPaginationMeta(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AssetPaginationMeta(const AssetPaginationMeta& from);
  AssetPaginationMeta(AssetPaginationMeta&& from) noexcept
    : AssetPaginationMeta() {
    *this = ::std::move(from);
  }

  inline AssetPaginationMeta& operator=(const AssetPaginationMeta& from) {
    CopyFrom(from);
    return *this;
  }
  inline AssetPaginationMeta& operator=(AssetPaginationMeta&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AssetPaginationMeta& default_instance() {
    return *internal_default_instance();
  }
  enum OptFirstAssetIdCase {
    kFirstAssetId = 2,
    OPT_FIRST_ASSET_ID_NOT_SET = 0,
  };

  static inline const AssetPaginationMeta* internal_default_instance() {
    return reinterpret_cast<const AssetPaginationMeta*>(
               &_AssetPaginationMeta_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(AssetPaginationMeta& a, AssetPaginationMeta& b) {
    a.Swap(&b);
  }
  inline void Swap(AssetPaginationMeta* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AssetPaginationMeta* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AssetPaginationMeta* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AssetPaginationMeta>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AssetPaginationMeta& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AssetPaginationMeta& from) {
    AssetPaginationMeta::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AssetPaginationMeta* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "iroha.protocol.AssetPaginationMeta";
  }
  protected:
  explicit AssetPaginationMeta(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPageSizeFieldNumber = 1,
    kFirstAssetIdFieldNumber = 2,
  };
  // uint32 page_size = 1;
  void clear_page_size();
  uint32_t page_size() const;
  void set_page_size(uint32_t value);
  private:
  uint32_t _internal_page_size() const;
  void _internal_set_page_size(uint32_t value);
  public:

  // string first_asset_id = 2;
  bool has_first_asset_id() const;
  private:
  bool _internal_has_first_asset_id() const;
  public:
  void clear_first_asset_id();
  const std::string& first_asset_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_first_asset_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_first_asset_id();
  PROTOBUF_NODISCARD std::string* release_first_asset_id();
  void set_allocated_first_asset_id(std::string* first_asset_id);
  private:
  const std::string& _internal_first_asset_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_first_asset_id(const std::string& value);
  std::string* _internal_mutable_first_asset_id();
  public:

  void clear_opt_first_asset_id();
  OptFirstAssetIdCase opt_first_asset_id_case() const;
  // @@protoc_insertion_point(class_scope:iroha.protocol.AssetPaginationMeta)
 private:
  class _Internal;
  void set_has_first_asset_id();

  inline bool has_opt_first_asset_id() const;
  inline void clear_has_opt_first_asset_id();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t page_size_;
    union OptFirstAssetIdUnion {
      constexpr OptFirstAssetIdUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr first_asset_id_;
    } opt_first_asset_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_queries_2eproto;
};
// -------------------------------------------------------------------

class GetAccount final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:iroha.protocol.GetAccount) */ {
 public:
  inline GetAccount() : GetAccount(nullptr) {}
  ~GetAccount() override;
  explicit PROTOBUF_CONSTEXPR GetAccount(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetAccount(const GetAccount& from);
  GetAccount(GetAccount&& from) noexcept
    : GetAccount() {
    *this = ::std::move(from);
  }

  inline GetAccount& operator=(const GetAccount& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetAccount& operator=(GetAccount&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetAccount& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetAccount* internal_default_instance() {
    return reinterpret_cast<const GetAccount*>(
               &_GetAccount_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(GetAccount& a, GetAccount& b) {
    a.Swap(&b);
  }
  inline void Swap(GetAccount* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetAccount* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetAccount* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetAccount>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetAccount& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetAccount& from) {
    GetAccount::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetAccount* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "iroha.protocol.GetAccount";
  }
  protected:
  explicit GetAccount(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAccountIdFieldNumber = 1,
  };
  // string account_id = 1;
  void clear_account_id();
  const std::string& account_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_account_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_account_id();
  PROTOBUF_NODISCARD std::string* release_account_id();
  void set_allocated_account_id(std::string* account_id);
  private:
  const std::string& _internal_account_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_account_id(const std::string& value);
  std::string* _internal_mutable_account_id();
  public:

  // @@protoc_insertion_point(class_scope:iroha.protocol.GetAccount)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr account_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_queries_2eproto;
};
// -------------------------------------------------------------------

class GetBlock final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:iroha.protocol.GetBlock) */ {
 public:
  inline GetBlock() : GetBlock(nullptr) {}
  ~GetBlock() override;
  explicit PROTOBUF_CONSTEXPR GetBlock(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetBlock(const GetBlock& from);
  GetBlock(GetBlock&& from) noexcept
    : GetBlock() {
    *this = ::std::move(from);
  }

  inline GetBlock& operator=(const GetBlock& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetBlock& operator=(GetBlock&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetBlock& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetBlock* internal_default_instance() {
    return reinterpret_cast<const GetBlock*>(
               &_GetBlock_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(GetBlock& a, GetBlock& b) {
    a.Swap(&b);
  }
  inline void Swap(GetBlock* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetBlock* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetBlock* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetBlock>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetBlock& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetBlock& from) {
    GetBlock::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetBlock* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "iroha.protocol.GetBlock";
  }
  protected:
  explicit GetBlock(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeightFieldNumber = 1,
  };
  // uint64 height = 1;
  void clear_height();
  uint64_t height() const;
  void set_height(uint64_t value);
  private:
  uint64_t _internal_height() const;
  void _internal_set_height(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:iroha.protocol.GetBlock)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t height_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_queries_2eproto;
};
// -------------------------------------------------------------------

class GetSignatories final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:iroha.protocol.GetSignatories) */ {
 public:
  inline GetSignatories() : GetSignatories(nullptr) {}
  ~GetSignatories() override;
  explicit PROTOBUF_CONSTEXPR GetSignatories(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetSignatories(const GetSignatories& from);
  GetSignatories(GetSignatories&& from) noexcept
    : GetSignatories() {
    *this = ::std::move(from);
  }

  inline GetSignatories& operator=(const GetSignatories& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetSignatories& operator=(GetSignatories&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetSignatories& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetSignatories* internal_default_instance() {
    return reinterpret_cast<const GetSignatories*>(
               &_GetSignatories_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(GetSignatories& a, GetSignatories& b) {
    a.Swap(&b);
  }
  inline void Swap(GetSignatories* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetSignatories* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetSignatories* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetSignatories>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetSignatories& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetSignatories& from) {
    GetSignatories::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetSignatories* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "iroha.protocol.GetSignatories";
  }
  protected:
  explicit GetSignatories(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAccountIdFieldNumber = 1,
  };
  // string account_id = 1;
  void clear_account_id();
  const std::string& account_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_account_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_account_id();
  PROTOBUF_NODISCARD std::string* release_account_id();
  void set_allocated_account_id(std::string* account_id);
  private:
  const std::string& _internal_account_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_account_id(const std::string& value);
  std::string* _internal_mutable_account_id();
  public:

  // @@protoc_insertion_point(class_scope:iroha.protocol.GetSignatories)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr account_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_queries_2eproto;
};
// -------------------------------------------------------------------

class GetAccountTransactions final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:iroha.protocol.GetAccountTransactions) */ {
 public:
  inline GetAccountTransactions() : GetAccountTransactions(nullptr) {}
  ~GetAccountTransactions() override;
  explicit PROTOBUF_CONSTEXPR GetAccountTransactions(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetAccountTransactions(const GetAccountTransactions& from);
  GetAccountTransactions(GetAccountTransactions&& from) noexcept
    : GetAccountTransactions() {
    *this = ::std::move(from);
  }

  inline GetAccountTransactions& operator=(const GetAccountTransactions& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetAccountTransactions& operator=(GetAccountTransactions&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetAccountTransactions& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetAccountTransactions* internal_default_instance() {
    return reinterpret_cast<const GetAccountTransactions*>(
               &_GetAccountTransactions_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(GetAccountTransactions& a, GetAccountTransactions& b) {
    a.Swap(&b);
  }
  inline void Swap(GetAccountTransactions* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetAccountTransactions* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetAccountTransactions* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetAccountTransactions>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetAccountTransactions& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetAccountTransactions& from) {
    GetAccountTransactions::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetAccountTransactions* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "iroha.protocol.GetAccountTransactions";
  }
  protected:
  explicit GetAccountTransactions(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAccountIdFieldNumber = 1,
    kPaginationMetaFieldNumber = 2,
  };
  // string account_id = 1;
  void clear_account_id();
  const std::string& account_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_account_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_account_id();
  PROTOBUF_NODISCARD std::string* release_account_id();
  void set_allocated_account_id(std::string* account_id);
  private:
  const std::string& _internal_account_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_account_id(const std::string& value);
  std::string* _internal_mutable_account_id();
  public:

  // .iroha.protocol.TxPaginationMeta pagination_meta = 2;
  bool has_pagination_meta() const;
  private:
  bool _internal_has_pagination_meta() const;
  public:
  void clear_pagination_meta();
  const ::iroha::protocol::TxPaginationMeta& pagination_meta() const;
  PROTOBUF_NODISCARD ::iroha::protocol::TxPaginationMeta* release_pagination_meta();
  ::iroha::protocol::TxPaginationMeta* mutable_pagination_meta();
  void set_allocated_pagination_meta(::iroha::protocol::TxPaginationMeta* pagination_meta);
  private:
  const ::iroha::protocol::TxPaginationMeta& _internal_pagination_meta() const;
  ::iroha::protocol::TxPaginationMeta* _internal_mutable_pagination_meta();
  public:
  void unsafe_arena_set_allocated_pagination_meta(
      ::iroha::protocol::TxPaginationMeta* pagination_meta);
  ::iroha::protocol::TxPaginationMeta* unsafe_arena_release_pagination_meta();

  // @@protoc_insertion_point(class_scope:iroha.protocol.GetAccountTransactions)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr account_id_;
    ::iroha::protocol::TxPaginationMeta* pagination_meta_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_queries_2eproto;
};
// -------------------------------------------------------------------

class GetAccountAssetTransactions final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:iroha.protocol.GetAccountAssetTransactions) */ {
 public:
  inline GetAccountAssetTransactions() : GetAccountAssetTransactions(nullptr) {}
  ~GetAccountAssetTransactions() override;
  explicit PROTOBUF_CONSTEXPR GetAccountAssetTransactions(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetAccountAssetTransactions(const GetAccountAssetTransactions& from);
  GetAccountAssetTransactions(GetAccountAssetTransactions&& from) noexcept
    : GetAccountAssetTransactions() {
    *this = ::std::move(from);
  }

  inline GetAccountAssetTransactions& operator=(const GetAccountAssetTransactions& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetAccountAssetTransactions& operator=(GetAccountAssetTransactions&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetAccountAssetTransactions& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetAccountAssetTransactions* internal_default_instance() {
    return reinterpret_cast<const GetAccountAssetTransactions*>(
               &_GetAccountAssetTransactions_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(GetAccountAssetTransactions& a, GetAccountAssetTransactions& b) {
    a.Swap(&b);
  }
  inline void Swap(GetAccountAssetTransactions* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetAccountAssetTransactions* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetAccountAssetTransactions* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetAccountAssetTransactions>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetAccountAssetTransactions& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetAccountAssetTransactions& from) {
    GetAccountAssetTransactions::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetAccountAssetTransactions* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "iroha.protocol.GetAccountAssetTransactions";
  }
  protected:
  explicit GetAccountAssetTransactions(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAccountIdFieldNumber = 1,
    kAssetIdFieldNumber = 2,
    kPaginationMetaFieldNumber = 3,
  };
  // string account_id = 1;
  void clear_account_id();
  const std::string& account_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_account_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_account_id();
  PROTOBUF_NODISCARD std::string* release_account_id();
  void set_allocated_account_id(std::string* account_id);
  private:
  const std::string& _internal_account_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_account_id(const std::string& value);
  std::string* _internal_mutable_account_id();
  public:

  // string asset_id = 2;
  void clear_asset_id();
  const std::string& asset_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_asset_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_asset_id();
  PROTOBUF_NODISCARD std::string* release_asset_id();
  void set_allocated_asset_id(std::string* asset_id);
  private:
  const std::string& _internal_asset_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_asset_id(const std::string& value);
  std::string* _internal_mutable_asset_id();
  public:

  // .iroha.protocol.TxPaginationMeta pagination_meta = 3;
  bool has_pagination_meta() const;
  private:
  bool _internal_has_pagination_meta() const;
  public:
  void clear_pagination_meta();
  const ::iroha::protocol::TxPaginationMeta& pagination_meta() const;
  PROTOBUF_NODISCARD ::iroha::protocol::TxPaginationMeta* release_pagination_meta();
  ::iroha::protocol::TxPaginationMeta* mutable_pagination_meta();
  void set_allocated_pagination_meta(::iroha::protocol::TxPaginationMeta* pagination_meta);
  private:
  const ::iroha::protocol::TxPaginationMeta& _internal_pagination_meta() const;
  ::iroha::protocol::TxPaginationMeta* _internal_mutable_pagination_meta();
  public:
  void unsafe_arena_set_allocated_pagination_meta(
      ::iroha::protocol::TxPaginationMeta* pagination_meta);
  ::iroha::protocol::TxPaginationMeta* unsafe_arena_release_pagination_meta();

  // @@protoc_insertion_point(class_scope:iroha.protocol.GetAccountAssetTransactions)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr account_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr asset_id_;
    ::iroha::protocol::TxPaginationMeta* pagination_meta_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_queries_2eproto;
};
// -------------------------------------------------------------------

class GetTransactions final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:iroha.protocol.GetTransactions) */ {
 public:
  inline GetTransactions() : GetTransactions(nullptr) {}
  ~GetTransactions() override;
  explicit PROTOBUF_CONSTEXPR GetTransactions(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetTransactions(const GetTransactions& from);
  GetTransactions(GetTransactions&& from) noexcept
    : GetTransactions() {
    *this = ::std::move(from);
  }

  inline GetTransactions& operator=(const GetTransactions& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetTransactions& operator=(GetTransactions&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetTransactions& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetTransactions* internal_default_instance() {
    return reinterpret_cast<const GetTransactions*>(
               &_GetTransactions_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(GetTransactions& a, GetTransactions& b) {
    a.Swap(&b);
  }
  inline void Swap(GetTransactions* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetTransactions* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetTransactions* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetTransactions>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetTransactions& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetTransactions& from) {
    GetTransactions::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetTransactions* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "iroha.protocol.GetTransactions";
  }
  protected:
  explicit GetTransactions(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTxHashesFieldNumber = 1,
  };
  // repeated string tx_hashes = 1;
  int tx_hashes_size() const;
  private:
  int _internal_tx_hashes_size() const;
  public:
  void clear_tx_hashes();
  const std::string& tx_hashes(int index) const;
  std::string* mutable_tx_hashes(int index);
  void set_tx_hashes(int index, const std::string& value);
  void set_tx_hashes(int index, std::string&& value);
  void set_tx_hashes(int index, const char* value);
  void set_tx_hashes(int index, const char* value, size_t size);
  std::string* add_tx_hashes();
  void add_tx_hashes(const std::string& value);
  void add_tx_hashes(std::string&& value);
  void add_tx_hashes(const char* value);
  void add_tx_hashes(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& tx_hashes() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_tx_hashes();
  private:
  const std::string& _internal_tx_hashes(int index) const;
  std::string* _internal_add_tx_hashes();
  public:

  // @@protoc_insertion_point(class_scope:iroha.protocol.GetTransactions)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> tx_hashes_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_queries_2eproto;
};
// -------------------------------------------------------------------

class GetAccountAssets final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:iroha.protocol.GetAccountAssets) */ {
 public:
  inline GetAccountAssets() : GetAccountAssets(nullptr) {}
  ~GetAccountAssets() override;
  explicit PROTOBUF_CONSTEXPR GetAccountAssets(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetAccountAssets(const GetAccountAssets& from);
  GetAccountAssets(GetAccountAssets&& from) noexcept
    : GetAccountAssets() {
    *this = ::std::move(from);
  }

  inline GetAccountAssets& operator=(const GetAccountAssets& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetAccountAssets& operator=(GetAccountAssets&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetAccountAssets& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetAccountAssets* internal_default_instance() {
    return reinterpret_cast<const GetAccountAssets*>(
               &_GetAccountAssets_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(GetAccountAssets& a, GetAccountAssets& b) {
    a.Swap(&b);
  }
  inline void Swap(GetAccountAssets* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetAccountAssets* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetAccountAssets* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetAccountAssets>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetAccountAssets& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetAccountAssets& from) {
    GetAccountAssets::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetAccountAssets* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "iroha.protocol.GetAccountAssets";
  }
  protected:
  explicit GetAccountAssets(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAccountIdFieldNumber = 1,
    kPaginationMetaFieldNumber = 2,
  };
  // string account_id = 1;
  void clear_account_id();
  const std::string& account_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_account_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_account_id();
  PROTOBUF_NODISCARD std::string* release_account_id();
  void set_allocated_account_id(std::string* account_id);
  private:
  const std::string& _internal_account_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_account_id(const std::string& value);
  std::string* _internal_mutable_account_id();
  public:

  // .iroha.protocol.AssetPaginationMeta pagination_meta = 2;
  bool has_pagination_meta() const;
  private:
  bool _internal_has_pagination_meta() const;
  public:
  void clear_pagination_meta();
  const ::iroha::protocol::AssetPaginationMeta& pagination_meta() const;
  PROTOBUF_NODISCARD ::iroha::protocol::AssetPaginationMeta* release_pagination_meta();
  ::iroha::protocol::AssetPaginationMeta* mutable_pagination_meta();
  void set_allocated_pagination_meta(::iroha::protocol::AssetPaginationMeta* pagination_meta);
  private:
  const ::iroha::protocol::AssetPaginationMeta& _internal_pagination_meta() const;
  ::iroha::protocol::AssetPaginationMeta* _internal_mutable_pagination_meta();
  public:
  void unsafe_arena_set_allocated_pagination_meta(
      ::iroha::protocol::AssetPaginationMeta* pagination_meta);
  ::iroha::protocol::AssetPaginationMeta* unsafe_arena_release_pagination_meta();

  // @@protoc_insertion_point(class_scope:iroha.protocol.GetAccountAssets)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr account_id_;
    ::iroha::protocol::AssetPaginationMeta* pagination_meta_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_queries_2eproto;
};
// -------------------------------------------------------------------

class AccountDetailPaginationMeta final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:iroha.protocol.AccountDetailPaginationMeta) */ {
 public:
  inline AccountDetailPaginationMeta() : AccountDetailPaginationMeta(nullptr) {}
  ~AccountDetailPaginationMeta() override;
  explicit PROTOBUF_CONSTEXPR AccountDetailPaginationMeta(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AccountDetailPaginationMeta(const AccountDetailPaginationMeta& from);
  AccountDetailPaginationMeta(AccountDetailPaginationMeta&& from) noexcept
    : AccountDetailPaginationMeta() {
    *this = ::std::move(from);
  }

  inline AccountDetailPaginationMeta& operator=(const AccountDetailPaginationMeta& from) {
    CopyFrom(from);
    return *this;
  }
  inline AccountDetailPaginationMeta& operator=(AccountDetailPaginationMeta&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AccountDetailPaginationMeta& default_instance() {
    return *internal_default_instance();
  }
  static inline const AccountDetailPaginationMeta* internal_default_instance() {
    return reinterpret_cast<const AccountDetailPaginationMeta*>(
               &_AccountDetailPaginationMeta_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(AccountDetailPaginationMeta& a, AccountDetailPaginationMeta& b) {
    a.Swap(&b);
  }
  inline void Swap(AccountDetailPaginationMeta* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AccountDetailPaginationMeta* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AccountDetailPaginationMeta* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AccountDetailPaginationMeta>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AccountDetailPaginationMeta& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AccountDetailPaginationMeta& from) {
    AccountDetailPaginationMeta::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AccountDetailPaginationMeta* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "iroha.protocol.AccountDetailPaginationMeta";
  }
  protected:
  explicit AccountDetailPaginationMeta(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFirstRecordIdFieldNumber = 2,
    kPageSizeFieldNumber = 1,
  };
  // .iroha.protocol.AccountDetailRecordId first_record_id = 2;
  bool has_first_record_id() const;
  private:
  bool _internal_has_first_record_id() const;
  public:
  void clear_first_record_id();
  const ::iroha::protocol::AccountDetailRecordId& first_record_id() const;
  PROTOBUF_NODISCARD ::iroha::protocol::AccountDetailRecordId* release_first_record_id();
  ::iroha::protocol::AccountDetailRecordId* mutable_first_record_id();
  void set_allocated_first_record_id(::iroha::protocol::AccountDetailRecordId* first_record_id);
  private:
  const ::iroha::protocol::AccountDetailRecordId& _internal_first_record_id() const;
  ::iroha::protocol::AccountDetailRecordId* _internal_mutable_first_record_id();
  public:
  void unsafe_arena_set_allocated_first_record_id(
      ::iroha::protocol::AccountDetailRecordId* first_record_id);
  ::iroha::protocol::AccountDetailRecordId* unsafe_arena_release_first_record_id();

  // uint32 page_size = 1;
  void clear_page_size();
  uint32_t page_size() const;
  void set_page_size(uint32_t value);
  private:
  uint32_t _internal_page_size() const;
  void _internal_set_page_size(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:iroha.protocol.AccountDetailPaginationMeta)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::iroha::protocol::AccountDetailRecordId* first_record_id_;
    uint32_t page_size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_queries_2eproto;
};
// -------------------------------------------------------------------

class GetAccountDetail final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:iroha.protocol.GetAccountDetail) */ {
 public:
  inline GetAccountDetail() : GetAccountDetail(nullptr) {}
  ~GetAccountDetail() override;
  explicit PROTOBUF_CONSTEXPR GetAccountDetail(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetAccountDetail(const GetAccountDetail& from);
  GetAccountDetail(GetAccountDetail&& from) noexcept
    : GetAccountDetail() {
    *this = ::std::move(from);
  }

  inline GetAccountDetail& operator=(const GetAccountDetail& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetAccountDetail& operator=(GetAccountDetail&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetAccountDetail& default_instance() {
    return *internal_default_instance();
  }
  enum OptAccountIdCase {
    kAccountId = 1,
    OPT_ACCOUNT_ID_NOT_SET = 0,
  };

  enum OptKeyCase {
    kKey = 2,
    OPT_KEY_NOT_SET = 0,
  };

  enum OptWriterCase {
    kWriter = 3,
    OPT_WRITER_NOT_SET = 0,
  };

  static inline const GetAccountDetail* internal_default_instance() {
    return reinterpret_cast<const GetAccountDetail*>(
               &_GetAccountDetail_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(GetAccountDetail& a, GetAccountDetail& b) {
    a.Swap(&b);
  }
  inline void Swap(GetAccountDetail* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetAccountDetail* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetAccountDetail* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetAccountDetail>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetAccountDetail& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetAccountDetail& from) {
    GetAccountDetail::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetAccountDetail* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "iroha.protocol.GetAccountDetail";
  }
  protected:
  explicit GetAccountDetail(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPaginationMetaFieldNumber = 4,
    kAccountIdFieldNumber = 1,
    kKeyFieldNumber = 2,
    kWriterFieldNumber = 3,
  };
  // .iroha.protocol.AccountDetailPaginationMeta pagination_meta = 4;
  bool has_pagination_meta() const;
  private:
  bool _internal_has_pagination_meta() const;
  public:
  void clear_pagination_meta();
  const ::iroha::protocol::AccountDetailPaginationMeta& pagination_meta() const;
  PROTOBUF_NODISCARD ::iroha::protocol::AccountDetailPaginationMeta* release_pagination_meta();
  ::iroha::protocol::AccountDetailPaginationMeta* mutable_pagination_meta();
  void set_allocated_pagination_meta(::iroha::protocol::AccountDetailPaginationMeta* pagination_meta);
  private:
  const ::iroha::protocol::AccountDetailPaginationMeta& _internal_pagination_meta() const;
  ::iroha::protocol::AccountDetailPaginationMeta* _internal_mutable_pagination_meta();
  public:
  void unsafe_arena_set_allocated_pagination_meta(
      ::iroha::protocol::AccountDetailPaginationMeta* pagination_meta);
  ::iroha::protocol::AccountDetailPaginationMeta* unsafe_arena_release_pagination_meta();

  // string account_id = 1;
  bool has_account_id() const;
  private:
  bool _internal_has_account_id() const;
  public:
  void clear_account_id();
  const std::string& account_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_account_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_account_id();
  PROTOBUF_NODISCARD std::string* release_account_id();
  void set_allocated_account_id(std::string* account_id);
  private:
  const std::string& _internal_account_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_account_id(const std::string& value);
  std::string* _internal_mutable_account_id();
  public:

  // string key = 2;
  bool has_key() const;
  private:
  bool _internal_has_key() const;
  public:
  void clear_key();
  const std::string& key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // string writer = 3;
  bool has_writer() const;
  private:
  bool _internal_has_writer() const;
  public:
  void clear_writer();
  const std::string& writer() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_writer(ArgT0&& arg0, ArgT... args);
  std::string* mutable_writer();
  PROTOBUF_NODISCARD std::string* release_writer();
  void set_allocated_writer(std::string* writer);
  private:
  const std::string& _internal_writer() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_writer(const std::string& value);
  std::string* _internal_mutable_writer();
  public:

  void clear_opt_account_id();
  OptAccountIdCase opt_account_id_case() const;
  void clear_opt_key();
  OptKeyCase opt_key_case() const;
  void clear_opt_writer();
  OptWriterCase opt_writer_case() const;
  // @@protoc_insertion_point(class_scope:iroha.protocol.GetAccountDetail)
 private:
  class _Internal;
  void set_has_account_id();
  void set_has_key();
  void set_has_writer();

  inline bool has_opt_account_id() const;
  inline void clear_has_opt_account_id();

  inline bool has_opt_key() const;
  inline void clear_has_opt_key();

  inline bool has_opt_writer() const;
  inline void clear_has_opt_writer();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::iroha::protocol::AccountDetailPaginationMeta* pagination_meta_;
    union OptAccountIdUnion {
      constexpr OptAccountIdUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr account_id_;
    } opt_account_id_;
    union OptKeyUnion {
      constexpr OptKeyUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
    } opt_key_;
    union OptWriterUnion {
      constexpr OptWriterUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr writer_;
    } opt_writer_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[3];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_queries_2eproto;
};
// -------------------------------------------------------------------

class GetAssetInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:iroha.protocol.GetAssetInfo) */ {
 public:
  inline GetAssetInfo() : GetAssetInfo(nullptr) {}
  ~GetAssetInfo() override;
  explicit PROTOBUF_CONSTEXPR GetAssetInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetAssetInfo(const GetAssetInfo& from);
  GetAssetInfo(GetAssetInfo&& from) noexcept
    : GetAssetInfo() {
    *this = ::std::move(from);
  }

  inline GetAssetInfo& operator=(const GetAssetInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetAssetInfo& operator=(GetAssetInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetAssetInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetAssetInfo* internal_default_instance() {
    return reinterpret_cast<const GetAssetInfo*>(
               &_GetAssetInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(GetAssetInfo& a, GetAssetInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(GetAssetInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetAssetInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetAssetInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetAssetInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetAssetInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetAssetInfo& from) {
    GetAssetInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetAssetInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "iroha.protocol.GetAssetInfo";
  }
  protected:
  explicit GetAssetInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAssetIdFieldNumber = 1,
  };
  // string asset_id = 1;
  void clear_asset_id();
  const std::string& asset_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_asset_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_asset_id();
  PROTOBUF_NODISCARD std::string* release_asset_id();
  void set_allocated_asset_id(std::string* asset_id);
  private:
  const std::string& _internal_asset_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_asset_id(const std::string& value);
  std::string* _internal_mutable_asset_id();
  public:

  // @@protoc_insertion_point(class_scope:iroha.protocol.GetAssetInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr asset_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_queries_2eproto;
};
// -------------------------------------------------------------------

class GetRoles final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:iroha.protocol.GetRoles) */ {
 public:
  inline GetRoles() : GetRoles(nullptr) {}
  explicit PROTOBUF_CONSTEXPR GetRoles(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetRoles(const GetRoles& from);
  GetRoles(GetRoles&& from) noexcept
    : GetRoles() {
    *this = ::std::move(from);
  }

  inline GetRoles& operator=(const GetRoles& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetRoles& operator=(GetRoles&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetRoles& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetRoles* internal_default_instance() {
    return reinterpret_cast<const GetRoles*>(
               &_GetRoles_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(GetRoles& a, GetRoles& b) {
    a.Swap(&b);
  }
  inline void Swap(GetRoles* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetRoles* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetRoles* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetRoles>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const GetRoles& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const GetRoles& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "iroha.protocol.GetRoles";
  }
  protected:
  explicit GetRoles(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:iroha.protocol.GetRoles)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_queries_2eproto;
};
// -------------------------------------------------------------------

class GetRolePermissions final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:iroha.protocol.GetRolePermissions) */ {
 public:
  inline GetRolePermissions() : GetRolePermissions(nullptr) {}
  ~GetRolePermissions() override;
  explicit PROTOBUF_CONSTEXPR GetRolePermissions(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetRolePermissions(const GetRolePermissions& from);
  GetRolePermissions(GetRolePermissions&& from) noexcept
    : GetRolePermissions() {
    *this = ::std::move(from);
  }

  inline GetRolePermissions& operator=(const GetRolePermissions& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetRolePermissions& operator=(GetRolePermissions&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetRolePermissions& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetRolePermissions* internal_default_instance() {
    return reinterpret_cast<const GetRolePermissions*>(
               &_GetRolePermissions_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(GetRolePermissions& a, GetRolePermissions& b) {
    a.Swap(&b);
  }
  inline void Swap(GetRolePermissions* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetRolePermissions* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetRolePermissions* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetRolePermissions>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetRolePermissions& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetRolePermissions& from) {
    GetRolePermissions::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetRolePermissions* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "iroha.protocol.GetRolePermissions";
  }
  protected:
  explicit GetRolePermissions(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRoleIdFieldNumber = 1,
  };
  // string role_id = 1;
  void clear_role_id();
  const std::string& role_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_role_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_role_id();
  PROTOBUF_NODISCARD std::string* release_role_id();
  void set_allocated_role_id(std::string* role_id);
  private:
  const std::string& _internal_role_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_role_id(const std::string& value);
  std::string* _internal_mutable_role_id();
  public:

  // @@protoc_insertion_point(class_scope:iroha.protocol.GetRolePermissions)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr role_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_queries_2eproto;
};
// -------------------------------------------------------------------

class GetPendingTransactions final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:iroha.protocol.GetPendingTransactions) */ {
 public:
  inline GetPendingTransactions() : GetPendingTransactions(nullptr) {}
  ~GetPendingTransactions() override;
  explicit PROTOBUF_CONSTEXPR GetPendingTransactions(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetPendingTransactions(const GetPendingTransactions& from);
  GetPendingTransactions(GetPendingTransactions&& from) noexcept
    : GetPendingTransactions() {
    *this = ::std::move(from);
  }

  inline GetPendingTransactions& operator=(const GetPendingTransactions& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetPendingTransactions& operator=(GetPendingTransactions&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetPendingTransactions& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetPendingTransactions* internal_default_instance() {
    return reinterpret_cast<const GetPendingTransactions*>(
               &_GetPendingTransactions_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(GetPendingTransactions& a, GetPendingTransactions& b) {
    a.Swap(&b);
  }
  inline void Swap(GetPendingTransactions* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetPendingTransactions* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetPendingTransactions* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetPendingTransactions>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetPendingTransactions& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetPendingTransactions& from) {
    GetPendingTransactions::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetPendingTransactions* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "iroha.protocol.GetPendingTransactions";
  }
  protected:
  explicit GetPendingTransactions(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPaginationMetaFieldNumber = 1,
  };
  // .iroha.protocol.TxPaginationMeta pagination_meta = 1;
  bool has_pagination_meta() const;
  private:
  bool _internal_has_pagination_meta() const;
  public:
  void clear_pagination_meta();
  const ::iroha::protocol::TxPaginationMeta& pagination_meta() const;
  PROTOBUF_NODISCARD ::iroha::protocol::TxPaginationMeta* release_pagination_meta();
  ::iroha::protocol::TxPaginationMeta* mutable_pagination_meta();
  void set_allocated_pagination_meta(::iroha::protocol::TxPaginationMeta* pagination_meta);
  private:
  const ::iroha::protocol::TxPaginationMeta& _internal_pagination_meta() const;
  ::iroha::protocol::TxPaginationMeta* _internal_mutable_pagination_meta();
  public:
  void unsafe_arena_set_allocated_pagination_meta(
      ::iroha::protocol::TxPaginationMeta* pagination_meta);
  ::iroha::protocol::TxPaginationMeta* unsafe_arena_release_pagination_meta();

  // @@protoc_insertion_point(class_scope:iroha.protocol.GetPendingTransactions)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::iroha::protocol::TxPaginationMeta* pagination_meta_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_queries_2eproto;
};
// -------------------------------------------------------------------

class GetPeers final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:iroha.protocol.GetPeers) */ {
 public:
  inline GetPeers() : GetPeers(nullptr) {}
  explicit PROTOBUF_CONSTEXPR GetPeers(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetPeers(const GetPeers& from);
  GetPeers(GetPeers&& from) noexcept
    : GetPeers() {
    *this = ::std::move(from);
  }

  inline GetPeers& operator=(const GetPeers& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetPeers& operator=(GetPeers&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetPeers& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetPeers* internal_default_instance() {
    return reinterpret_cast<const GetPeers*>(
               &_GetPeers_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(GetPeers& a, GetPeers& b) {
    a.Swap(&b);
  }
  inline void Swap(GetPeers* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetPeers* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetPeers* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetPeers>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const GetPeers& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const GetPeers& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "iroha.protocol.GetPeers";
  }
  protected:
  explicit GetPeers(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:iroha.protocol.GetPeers)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_queries_2eproto;
};
// -------------------------------------------------------------------

class QueryPayloadMeta final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:iroha.protocol.QueryPayloadMeta) */ {
 public:
  inline QueryPayloadMeta() : QueryPayloadMeta(nullptr) {}
  ~QueryPayloadMeta() override;
  explicit PROTOBUF_CONSTEXPR QueryPayloadMeta(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueryPayloadMeta(const QueryPayloadMeta& from);
  QueryPayloadMeta(QueryPayloadMeta&& from) noexcept
    : QueryPayloadMeta() {
    *this = ::std::move(from);
  }

  inline QueryPayloadMeta& operator=(const QueryPayloadMeta& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryPayloadMeta& operator=(QueryPayloadMeta&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryPayloadMeta& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryPayloadMeta* internal_default_instance() {
    return reinterpret_cast<const QueryPayloadMeta*>(
               &_QueryPayloadMeta_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(QueryPayloadMeta& a, QueryPayloadMeta& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryPayloadMeta* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryPayloadMeta* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryPayloadMeta* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QueryPayloadMeta>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QueryPayloadMeta& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QueryPayloadMeta& from) {
    QueryPayloadMeta::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QueryPayloadMeta* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "iroha.protocol.QueryPayloadMeta";
  }
  protected:
  explicit QueryPayloadMeta(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCreatorAccountIdFieldNumber = 2,
    kCreatedTimeFieldNumber = 1,
    kQueryCounterFieldNumber = 3,
  };
  // string creator_account_id = 2;
  void clear_creator_account_id();
  const std::string& creator_account_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_creator_account_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_creator_account_id();
  PROTOBUF_NODISCARD std::string* release_creator_account_id();
  void set_allocated_creator_account_id(std::string* creator_account_id);
  private:
  const std::string& _internal_creator_account_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_creator_account_id(const std::string& value);
  std::string* _internal_mutable_creator_account_id();
  public:

  // uint64 created_time = 1;
  void clear_created_time();
  uint64_t created_time() const;
  void set_created_time(uint64_t value);
  private:
  uint64_t _internal_created_time() const;
  void _internal_set_created_time(uint64_t value);
  public:

  // uint64 query_counter = 3;
  void clear_query_counter();
  uint64_t query_counter() const;
  void set_query_counter(uint64_t value);
  private:
  uint64_t _internal_query_counter() const;
  void _internal_set_query_counter(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:iroha.protocol.QueryPayloadMeta)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr creator_account_id_;
    uint64_t created_time_;
    uint64_t query_counter_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_queries_2eproto;
};
// -------------------------------------------------------------------

class GetEngineReceipts final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:iroha.protocol.GetEngineReceipts) */ {
 public:
  inline GetEngineReceipts() : GetEngineReceipts(nullptr) {}
  ~GetEngineReceipts() override;
  explicit PROTOBUF_CONSTEXPR GetEngineReceipts(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetEngineReceipts(const GetEngineReceipts& from);
  GetEngineReceipts(GetEngineReceipts&& from) noexcept
    : GetEngineReceipts() {
    *this = ::std::move(from);
  }

  inline GetEngineReceipts& operator=(const GetEngineReceipts& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetEngineReceipts& operator=(GetEngineReceipts&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetEngineReceipts& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetEngineReceipts* internal_default_instance() {
    return reinterpret_cast<const GetEngineReceipts*>(
               &_GetEngineReceipts_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(GetEngineReceipts& a, GetEngineReceipts& b) {
    a.Swap(&b);
  }
  inline void Swap(GetEngineReceipts* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetEngineReceipts* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetEngineReceipts* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetEngineReceipts>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetEngineReceipts& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetEngineReceipts& from) {
    GetEngineReceipts::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetEngineReceipts* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "iroha.protocol.GetEngineReceipts";
  }
  protected:
  explicit GetEngineReceipts(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTxHashFieldNumber = 1,
  };
  // string tx_hash = 1;
  void clear_tx_hash();
  const std::string& tx_hash() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tx_hash(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tx_hash();
  PROTOBUF_NODISCARD std::string* release_tx_hash();
  void set_allocated_tx_hash(std::string* tx_hash);
  private:
  const std::string& _internal_tx_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tx_hash(const std::string& value);
  std::string* _internal_mutable_tx_hash();
  public:

  // @@protoc_insertion_point(class_scope:iroha.protocol.GetEngineReceipts)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tx_hash_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_queries_2eproto;
};
// -------------------------------------------------------------------

class Query_Payload final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:iroha.protocol.Query.Payload) */ {
 public:
  inline Query_Payload() : Query_Payload(nullptr) {}
  ~Query_Payload() override;
  explicit PROTOBUF_CONSTEXPR Query_Payload(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Query_Payload(const Query_Payload& from);
  Query_Payload(Query_Payload&& from) noexcept
    : Query_Payload() {
    *this = ::std::move(from);
  }

  inline Query_Payload& operator=(const Query_Payload& from) {
    CopyFrom(from);
    return *this;
  }
  inline Query_Payload& operator=(Query_Payload&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Query_Payload& default_instance() {
    return *internal_default_instance();
  }
  enum QueryCase {
    kGetAccount = 3,
    kGetSignatories = 4,
    kGetAccountTransactions = 5,
    kGetAccountAssetTransactions = 6,
    kGetTransactions = 7,
    kGetAccountAssets = 8,
    kGetAccountDetail = 9,
    kGetRoles = 10,
    kGetRolePermissions = 11,
    kGetAssetInfo = 12,
    kGetPendingTransactions = 13,
    kGetBlock = 14,
    kGetPeers = 15,
    kGetEngineReceipts = 16,
    QUERY_NOT_SET = 0,
  };

  static inline const Query_Payload* internal_default_instance() {
    return reinterpret_cast<const Query_Payload*>(
               &_Query_Payload_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(Query_Payload& a, Query_Payload& b) {
    a.Swap(&b);
  }
  inline void Swap(Query_Payload* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Query_Payload* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Query_Payload* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Query_Payload>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Query_Payload& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Query_Payload& from) {
    Query_Payload::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Query_Payload* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "iroha.protocol.Query.Payload";
  }
  protected:
  explicit Query_Payload(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMetaFieldNumber = 1,
    kGetAccountFieldNumber = 3,
    kGetSignatoriesFieldNumber = 4,
    kGetAccountTransactionsFieldNumber = 5,
    kGetAccountAssetTransactionsFieldNumber = 6,
    kGetTransactionsFieldNumber = 7,
    kGetAccountAssetsFieldNumber = 8,
    kGetAccountDetailFieldNumber = 9,
    kGetRolesFieldNumber = 10,
    kGetRolePermissionsFieldNumber = 11,
    kGetAssetInfoFieldNumber = 12,
    kGetPendingTransactionsFieldNumber = 13,
    kGetBlockFieldNumber = 14,
    kGetPeersFieldNumber = 15,
    kGetEngineReceiptsFieldNumber = 16,
  };
  // .iroha.protocol.QueryPayloadMeta meta = 1;
  bool has_meta() const;
  private:
  bool _internal_has_meta() const;
  public:
  void clear_meta();
  const ::iroha::protocol::QueryPayloadMeta& meta() const;
  PROTOBUF_NODISCARD ::iroha::protocol::QueryPayloadMeta* release_meta();
  ::iroha::protocol::QueryPayloadMeta* mutable_meta();
  void set_allocated_meta(::iroha::protocol::QueryPayloadMeta* meta);
  private:
  const ::iroha::protocol::QueryPayloadMeta& _internal_meta() const;
  ::iroha::protocol::QueryPayloadMeta* _internal_mutable_meta();
  public:
  void unsafe_arena_set_allocated_meta(
      ::iroha::protocol::QueryPayloadMeta* meta);
  ::iroha::protocol::QueryPayloadMeta* unsafe_arena_release_meta();

  // .iroha.protocol.GetAccount get_account = 3;
  bool has_get_account() const;
  private:
  bool _internal_has_get_account() const;
  public:
  void clear_get_account();
  const ::iroha::protocol::GetAccount& get_account() const;
  PROTOBUF_NODISCARD ::iroha::protocol::GetAccount* release_get_account();
  ::iroha::protocol::GetAccount* mutable_get_account();
  void set_allocated_get_account(::iroha::protocol::GetAccount* get_account);
  private:
  const ::iroha::protocol::GetAccount& _internal_get_account() const;
  ::iroha::protocol::GetAccount* _internal_mutable_get_account();
  public:
  void unsafe_arena_set_allocated_get_account(
      ::iroha::protocol::GetAccount* get_account);
  ::iroha::protocol::GetAccount* unsafe_arena_release_get_account();

  // .iroha.protocol.GetSignatories get_signatories = 4;
  bool has_get_signatories() const;
  private:
  bool _internal_has_get_signatories() const;
  public:
  void clear_get_signatories();
  const ::iroha::protocol::GetSignatories& get_signatories() const;
  PROTOBUF_NODISCARD ::iroha::protocol::GetSignatories* release_get_signatories();
  ::iroha::protocol::GetSignatories* mutable_get_signatories();
  void set_allocated_get_signatories(::iroha::protocol::GetSignatories* get_signatories);
  private:
  const ::iroha::protocol::GetSignatories& _internal_get_signatories() const;
  ::iroha::protocol::GetSignatories* _internal_mutable_get_signatories();
  public:
  void unsafe_arena_set_allocated_get_signatories(
      ::iroha::protocol::GetSignatories* get_signatories);
  ::iroha::protocol::GetSignatories* unsafe_arena_release_get_signatories();

  // .iroha.protocol.GetAccountTransactions get_account_transactions = 5;
  bool has_get_account_transactions() const;
  private:
  bool _internal_has_get_account_transactions() const;
  public:
  void clear_get_account_transactions();
  const ::iroha::protocol::GetAccountTransactions& get_account_transactions() const;
  PROTOBUF_NODISCARD ::iroha::protocol::GetAccountTransactions* release_get_account_transactions();
  ::iroha::protocol::GetAccountTransactions* mutable_get_account_transactions();
  void set_allocated_get_account_transactions(::iroha::protocol::GetAccountTransactions* get_account_transactions);
  private:
  const ::iroha::protocol::GetAccountTransactions& _internal_get_account_transactions() const;
  ::iroha::protocol::GetAccountTransactions* _internal_mutable_get_account_transactions();
  public:
  void unsafe_arena_set_allocated_get_account_transactions(
      ::iroha::protocol::GetAccountTransactions* get_account_transactions);
  ::iroha::protocol::GetAccountTransactions* unsafe_arena_release_get_account_transactions();

  // .iroha.protocol.GetAccountAssetTransactions get_account_asset_transactions = 6;
  bool has_get_account_asset_transactions() const;
  private:
  bool _internal_has_get_account_asset_transactions() const;
  public:
  void clear_get_account_asset_transactions();
  const ::iroha::protocol::GetAccountAssetTransactions& get_account_asset_transactions() const;
  PROTOBUF_NODISCARD ::iroha::protocol::GetAccountAssetTransactions* release_get_account_asset_transactions();
  ::iroha::protocol::GetAccountAssetTransactions* mutable_get_account_asset_transactions();
  void set_allocated_get_account_asset_transactions(::iroha::protocol::GetAccountAssetTransactions* get_account_asset_transactions);
  private:
  const ::iroha::protocol::GetAccountAssetTransactions& _internal_get_account_asset_transactions() const;
  ::iroha::protocol::GetAccountAssetTransactions* _internal_mutable_get_account_asset_transactions();
  public:
  void unsafe_arena_set_allocated_get_account_asset_transactions(
      ::iroha::protocol::GetAccountAssetTransactions* get_account_asset_transactions);
  ::iroha::protocol::GetAccountAssetTransactions* unsafe_arena_release_get_account_asset_transactions();

  // .iroha.protocol.GetTransactions get_transactions = 7;
  bool has_get_transactions() const;
  private:
  bool _internal_has_get_transactions() const;
  public:
  void clear_get_transactions();
  const ::iroha::protocol::GetTransactions& get_transactions() const;
  PROTOBUF_NODISCARD ::iroha::protocol::GetTransactions* release_get_transactions();
  ::iroha::protocol::GetTransactions* mutable_get_transactions();
  void set_allocated_get_transactions(::iroha::protocol::GetTransactions* get_transactions);
  private:
  const ::iroha::protocol::GetTransactions& _internal_get_transactions() const;
  ::iroha::protocol::GetTransactions* _internal_mutable_get_transactions();
  public:
  void unsafe_arena_set_allocated_get_transactions(
      ::iroha::protocol::GetTransactions* get_transactions);
  ::iroha::protocol::GetTransactions* unsafe_arena_release_get_transactions();

  // .iroha.protocol.GetAccountAssets get_account_assets = 8;
  bool has_get_account_assets() const;
  private:
  bool _internal_has_get_account_assets() const;
  public:
  void clear_get_account_assets();
  const ::iroha::protocol::GetAccountAssets& get_account_assets() const;
  PROTOBUF_NODISCARD ::iroha::protocol::GetAccountAssets* release_get_account_assets();
  ::iroha::protocol::GetAccountAssets* mutable_get_account_assets();
  void set_allocated_get_account_assets(::iroha::protocol::GetAccountAssets* get_account_assets);
  private:
  const ::iroha::protocol::GetAccountAssets& _internal_get_account_assets() const;
  ::iroha::protocol::GetAccountAssets* _internal_mutable_get_account_assets();
  public:
  void unsafe_arena_set_allocated_get_account_assets(
      ::iroha::protocol::GetAccountAssets* get_account_assets);
  ::iroha::protocol::GetAccountAssets* unsafe_arena_release_get_account_assets();

  // .iroha.protocol.GetAccountDetail get_account_detail = 9;
  bool has_get_account_detail() const;
  private:
  bool _internal_has_get_account_detail() const;
  public:
  void clear_get_account_detail();
  const ::iroha::protocol::GetAccountDetail& get_account_detail() const;
  PROTOBUF_NODISCARD ::iroha::protocol::GetAccountDetail* release_get_account_detail();
  ::iroha::protocol::GetAccountDetail* mutable_get_account_detail();
  void set_allocated_get_account_detail(::iroha::protocol::GetAccountDetail* get_account_detail);
  private:
  const ::iroha::protocol::GetAccountDetail& _internal_get_account_detail() const;
  ::iroha::protocol::GetAccountDetail* _internal_mutable_get_account_detail();
  public:
  void unsafe_arena_set_allocated_get_account_detail(
      ::iroha::protocol::GetAccountDetail* get_account_detail);
  ::iroha::protocol::GetAccountDetail* unsafe_arena_release_get_account_detail();

  // .iroha.protocol.GetRoles get_roles = 10;
  bool has_get_roles() const;
  private:
  bool _internal_has_get_roles() const;
  public:
  void clear_get_roles();
  const ::iroha::protocol::GetRoles& get_roles() const;
  PROTOBUF_NODISCARD ::iroha::protocol::GetRoles* release_get_roles();
  ::iroha::protocol::GetRoles* mutable_get_roles();
  void set_allocated_get_roles(::iroha::protocol::GetRoles* get_roles);
  private:
  const ::iroha::protocol::GetRoles& _internal_get_roles() const;
  ::iroha::protocol::GetRoles* _internal_mutable_get_roles();
  public:
  void unsafe_arena_set_allocated_get_roles(
      ::iroha::protocol::GetRoles* get_roles);
  ::iroha::protocol::GetRoles* unsafe_arena_release_get_roles();

  // .iroha.protocol.GetRolePermissions get_role_permissions = 11;
  bool has_get_role_permissions() const;
  private:
  bool _internal_has_get_role_permissions() const;
  public:
  void clear_get_role_permissions();
  const ::iroha::protocol::GetRolePermissions& get_role_permissions() const;
  PROTOBUF_NODISCARD ::iroha::protocol::GetRolePermissions* release_get_role_permissions();
  ::iroha::protocol::GetRolePermissions* mutable_get_role_permissions();
  void set_allocated_get_role_permissions(::iroha::protocol::GetRolePermissions* get_role_permissions);
  private:
  const ::iroha::protocol::GetRolePermissions& _internal_get_role_permissions() const;
  ::iroha::protocol::GetRolePermissions* _internal_mutable_get_role_permissions();
  public:
  void unsafe_arena_set_allocated_get_role_permissions(
      ::iroha::protocol::GetRolePermissions* get_role_permissions);
  ::iroha::protocol::GetRolePermissions* unsafe_arena_release_get_role_permissions();

  // .iroha.protocol.GetAssetInfo get_asset_info = 12;
  bool has_get_asset_info() const;
  private:
  bool _internal_has_get_asset_info() const;
  public:
  void clear_get_asset_info();
  const ::iroha::protocol::GetAssetInfo& get_asset_info() const;
  PROTOBUF_NODISCARD ::iroha::protocol::GetAssetInfo* release_get_asset_info();
  ::iroha::protocol::GetAssetInfo* mutable_get_asset_info();
  void set_allocated_get_asset_info(::iroha::protocol::GetAssetInfo* get_asset_info);
  private:
  const ::iroha::protocol::GetAssetInfo& _internal_get_asset_info() const;
  ::iroha::protocol::GetAssetInfo* _internal_mutable_get_asset_info();
  public:
  void unsafe_arena_set_allocated_get_asset_info(
      ::iroha::protocol::GetAssetInfo* get_asset_info);
  ::iroha::protocol::GetAssetInfo* unsafe_arena_release_get_asset_info();

  // .iroha.protocol.GetPendingTransactions get_pending_transactions = 13;
  bool has_get_pending_transactions() const;
  private:
  bool _internal_has_get_pending_transactions() const;
  public:
  void clear_get_pending_transactions();
  const ::iroha::protocol::GetPendingTransactions& get_pending_transactions() const;
  PROTOBUF_NODISCARD ::iroha::protocol::GetPendingTransactions* release_get_pending_transactions();
  ::iroha::protocol::GetPendingTransactions* mutable_get_pending_transactions();
  void set_allocated_get_pending_transactions(::iroha::protocol::GetPendingTransactions* get_pending_transactions);
  private:
  const ::iroha::protocol::GetPendingTransactions& _internal_get_pending_transactions() const;
  ::iroha::protocol::GetPendingTransactions* _internal_mutable_get_pending_transactions();
  public:
  void unsafe_arena_set_allocated_get_pending_transactions(
      ::iroha::protocol::GetPendingTransactions* get_pending_transactions);
  ::iroha::protocol::GetPendingTransactions* unsafe_arena_release_get_pending_transactions();

  // .iroha.protocol.GetBlock get_block = 14;
  bool has_get_block() const;
  private:
  bool _internal_has_get_block() const;
  public:
  void clear_get_block();
  const ::iroha::protocol::GetBlock& get_block() const;
  PROTOBUF_NODISCARD ::iroha::protocol::GetBlock* release_get_block();
  ::iroha::protocol::GetBlock* mutable_get_block();
  void set_allocated_get_block(::iroha::protocol::GetBlock* get_block);
  private:
  const ::iroha::protocol::GetBlock& _internal_get_block() const;
  ::iroha::protocol::GetBlock* _internal_mutable_get_block();
  public:
  void unsafe_arena_set_allocated_get_block(
      ::iroha::protocol::GetBlock* get_block);
  ::iroha::protocol::GetBlock* unsafe_arena_release_get_block();

  // .iroha.protocol.GetPeers get_peers = 15;
  bool has_get_peers() const;
  private:
  bool _internal_has_get_peers() const;
  public:
  void clear_get_peers();
  const ::iroha::protocol::GetPeers& get_peers() const;
  PROTOBUF_NODISCARD ::iroha::protocol::GetPeers* release_get_peers();
  ::iroha::protocol::GetPeers* mutable_get_peers();
  void set_allocated_get_peers(::iroha::protocol::GetPeers* get_peers);
  private:
  const ::iroha::protocol::GetPeers& _internal_get_peers() const;
  ::iroha::protocol::GetPeers* _internal_mutable_get_peers();
  public:
  void unsafe_arena_set_allocated_get_peers(
      ::iroha::protocol::GetPeers* get_peers);
  ::iroha::protocol::GetPeers* unsafe_arena_release_get_peers();

  // .iroha.protocol.GetEngineReceipts get_engine_receipts = 16;
  bool has_get_engine_receipts() const;
  private:
  bool _internal_has_get_engine_receipts() const;
  public:
  void clear_get_engine_receipts();
  const ::iroha::protocol::GetEngineReceipts& get_engine_receipts() const;
  PROTOBUF_NODISCARD ::iroha::protocol::GetEngineReceipts* release_get_engine_receipts();
  ::iroha::protocol::GetEngineReceipts* mutable_get_engine_receipts();
  void set_allocated_get_engine_receipts(::iroha::protocol::GetEngineReceipts* get_engine_receipts);
  private:
  const ::iroha::protocol::GetEngineReceipts& _internal_get_engine_receipts() const;
  ::iroha::protocol::GetEngineReceipts* _internal_mutable_get_engine_receipts();
  public:
  void unsafe_arena_set_allocated_get_engine_receipts(
      ::iroha::protocol::GetEngineReceipts* get_engine_receipts);
  ::iroha::protocol::GetEngineReceipts* unsafe_arena_release_get_engine_receipts();

  void clear_query();
  QueryCase query_case() const;
  // @@protoc_insertion_point(class_scope:iroha.protocol.Query.Payload)
 private:
  class _Internal;
  void set_has_get_account();
  void set_has_get_signatories();
  void set_has_get_account_transactions();
  void set_has_get_account_asset_transactions();
  void set_has_get_transactions();
  void set_has_get_account_assets();
  void set_has_get_account_detail();
  void set_has_get_roles();
  void set_has_get_role_permissions();
  void set_has_get_asset_info();
  void set_has_get_pending_transactions();
  void set_has_get_block();
  void set_has_get_peers();
  void set_has_get_engine_receipts();

  inline bool has_query() const;
  inline void clear_has_query();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::iroha::protocol::QueryPayloadMeta* meta_;
    union QueryUnion {
      constexpr QueryUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::iroha::protocol::GetAccount* get_account_;
      ::iroha::protocol::GetSignatories* get_signatories_;
      ::iroha::protocol::GetAccountTransactions* get_account_transactions_;
      ::iroha::protocol::GetAccountAssetTransactions* get_account_asset_transactions_;
      ::iroha::protocol::GetTransactions* get_transactions_;
      ::iroha::protocol::GetAccountAssets* get_account_assets_;
      ::iroha::protocol::GetAccountDetail* get_account_detail_;
      ::iroha::protocol::GetRoles* get_roles_;
      ::iroha::protocol::GetRolePermissions* get_role_permissions_;
      ::iroha::protocol::GetAssetInfo* get_asset_info_;
      ::iroha::protocol::GetPendingTransactions* get_pending_transactions_;
      ::iroha::protocol::GetBlock* get_block_;
      ::iroha::protocol::GetPeers* get_peers_;
      ::iroha::protocol::GetEngineReceipts* get_engine_receipts_;
    } query_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_queries_2eproto;
};
// -------------------------------------------------------------------

class Query final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:iroha.protocol.Query) */ {
 public:
  inline Query() : Query(nullptr) {}
  ~Query() override;
  explicit PROTOBUF_CONSTEXPR Query(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Query(const Query& from);
  Query(Query&& from) noexcept
    : Query() {
    *this = ::std::move(from);
  }

  inline Query& operator=(const Query& from) {
    CopyFrom(from);
    return *this;
  }
  inline Query& operator=(Query&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Query& default_instance() {
    return *internal_default_instance();
  }
  static inline const Query* internal_default_instance() {
    return reinterpret_cast<const Query*>(
               &_Query_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(Query& a, Query& b) {
    a.Swap(&b);
  }
  inline void Swap(Query* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Query* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Query* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Query>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Query& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Query& from) {
    Query::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Query* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "iroha.protocol.Query";
  }
  protected:
  explicit Query(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Query_Payload Payload;

  // accessors -------------------------------------------------------

  enum : int {
    kPayloadFieldNumber = 1,
    kSignatureFieldNumber = 2,
  };
  // .iroha.protocol.Query.Payload payload = 1;
  bool has_payload() const;
  private:
  bool _internal_has_payload() const;
  public:
  void clear_payload();
  const ::iroha::protocol::Query_Payload& payload() const;
  PROTOBUF_NODISCARD ::iroha::protocol::Query_Payload* release_payload();
  ::iroha::protocol::Query_Payload* mutable_payload();
  void set_allocated_payload(::iroha::protocol::Query_Payload* payload);
  private:
  const ::iroha::protocol::Query_Payload& _internal_payload() const;
  ::iroha::protocol::Query_Payload* _internal_mutable_payload();
  public:
  void unsafe_arena_set_allocated_payload(
      ::iroha::protocol::Query_Payload* payload);
  ::iroha::protocol::Query_Payload* unsafe_arena_release_payload();

  // .iroha.protocol.Signature signature = 2;
  bool has_signature() const;
  private:
  bool _internal_has_signature() const;
  public:
  void clear_signature();
  const ::iroha::protocol::Signature& signature() const;
  PROTOBUF_NODISCARD ::iroha::protocol::Signature* release_signature();
  ::iroha::protocol::Signature* mutable_signature();
  void set_allocated_signature(::iroha::protocol::Signature* signature);
  private:
  const ::iroha::protocol::Signature& _internal_signature() const;
  ::iroha::protocol::Signature* _internal_mutable_signature();
  public:
  void unsafe_arena_set_allocated_signature(
      ::iroha::protocol::Signature* signature);
  ::iroha::protocol::Signature* unsafe_arena_release_signature();

  // @@protoc_insertion_point(class_scope:iroha.protocol.Query)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::iroha::protocol::Query_Payload* payload_;
    ::iroha::protocol::Signature* signature_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_queries_2eproto;
};
// -------------------------------------------------------------------

class BlocksQuery final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:iroha.protocol.BlocksQuery) */ {
 public:
  inline BlocksQuery() : BlocksQuery(nullptr) {}
  ~BlocksQuery() override;
  explicit PROTOBUF_CONSTEXPR BlocksQuery(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BlocksQuery(const BlocksQuery& from);
  BlocksQuery(BlocksQuery&& from) noexcept
    : BlocksQuery() {
    *this = ::std::move(from);
  }

  inline BlocksQuery& operator=(const BlocksQuery& from) {
    CopyFrom(from);
    return *this;
  }
  inline BlocksQuery& operator=(BlocksQuery&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BlocksQuery& default_instance() {
    return *internal_default_instance();
  }
  static inline const BlocksQuery* internal_default_instance() {
    return reinterpret_cast<const BlocksQuery*>(
               &_BlocksQuery_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(BlocksQuery& a, BlocksQuery& b) {
    a.Swap(&b);
  }
  inline void Swap(BlocksQuery* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BlocksQuery* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BlocksQuery* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BlocksQuery>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BlocksQuery& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BlocksQuery& from) {
    BlocksQuery::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BlocksQuery* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "iroha.protocol.BlocksQuery";
  }
  protected:
  explicit BlocksQuery(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMetaFieldNumber = 1,
    kSignatureFieldNumber = 2,
  };
  // .iroha.protocol.QueryPayloadMeta meta = 1;
  bool has_meta() const;
  private:
  bool _internal_has_meta() const;
  public:
  void clear_meta();
  const ::iroha::protocol::QueryPayloadMeta& meta() const;
  PROTOBUF_NODISCARD ::iroha::protocol::QueryPayloadMeta* release_meta();
  ::iroha::protocol::QueryPayloadMeta* mutable_meta();
  void set_allocated_meta(::iroha::protocol::QueryPayloadMeta* meta);
  private:
  const ::iroha::protocol::QueryPayloadMeta& _internal_meta() const;
  ::iroha::protocol::QueryPayloadMeta* _internal_mutable_meta();
  public:
  void unsafe_arena_set_allocated_meta(
      ::iroha::protocol::QueryPayloadMeta* meta);
  ::iroha::protocol::QueryPayloadMeta* unsafe_arena_release_meta();

  // .iroha.protocol.Signature signature = 2;
  bool has_signature() const;
  private:
  bool _internal_has_signature() const;
  public:
  void clear_signature();
  const ::iroha::protocol::Signature& signature() const;
  PROTOBUF_NODISCARD ::iroha::protocol::Signature* release_signature();
  ::iroha::protocol::Signature* mutable_signature();
  void set_allocated_signature(::iroha::protocol::Signature* signature);
  private:
  const ::iroha::protocol::Signature& _internal_signature() const;
  ::iroha::protocol::Signature* _internal_mutable_signature();
  public:
  void unsafe_arena_set_allocated_signature(
      ::iroha::protocol::Signature* signature);
  ::iroha::protocol::Signature* unsafe_arena_release_signature();

  // @@protoc_insertion_point(class_scope:iroha.protocol.BlocksQuery)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::iroha::protocol::QueryPayloadMeta* meta_;
    ::iroha::protocol::Signature* signature_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_queries_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Ordering_FieldOrdering

// .iroha.protocol.Field field = 1;
inline void Ordering_FieldOrdering::clear_field() {
  _impl_.field_ = 0;
}
inline ::iroha::protocol::Field Ordering_FieldOrdering::_internal_field() const {
  return static_cast< ::iroha::protocol::Field >(_impl_.field_);
}
inline ::iroha::protocol::Field Ordering_FieldOrdering::field() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.Ordering.FieldOrdering.field)
  return _internal_field();
}
inline void Ordering_FieldOrdering::_internal_set_field(::iroha::protocol::Field value) {
  
  _impl_.field_ = value;
}
inline void Ordering_FieldOrdering::set_field(::iroha::protocol::Field value) {
  _internal_set_field(value);
  // @@protoc_insertion_point(field_set:iroha.protocol.Ordering.FieldOrdering.field)
}

// .iroha.protocol.Direction direction = 2;
inline void Ordering_FieldOrdering::clear_direction() {
  _impl_.direction_ = 0;
}
inline ::iroha::protocol::Direction Ordering_FieldOrdering::_internal_direction() const {
  return static_cast< ::iroha::protocol::Direction >(_impl_.direction_);
}
inline ::iroha::protocol::Direction Ordering_FieldOrdering::direction() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.Ordering.FieldOrdering.direction)
  return _internal_direction();
}
inline void Ordering_FieldOrdering::_internal_set_direction(::iroha::protocol::Direction value) {
  
  _impl_.direction_ = value;
}
inline void Ordering_FieldOrdering::set_direction(::iroha::protocol::Direction value) {
  _internal_set_direction(value);
  // @@protoc_insertion_point(field_set:iroha.protocol.Ordering.FieldOrdering.direction)
}

// -------------------------------------------------------------------

// Ordering

// repeated .iroha.protocol.Ordering.FieldOrdering sequence = 1;
inline int Ordering::_internal_sequence_size() const {
  return _impl_.sequence_.size();
}
inline int Ordering::sequence_size() const {
  return _internal_sequence_size();
}
inline void Ordering::clear_sequence() {
  _impl_.sequence_.Clear();
}
inline ::iroha::protocol::Ordering_FieldOrdering* Ordering::mutable_sequence(int index) {
  // @@protoc_insertion_point(field_mutable:iroha.protocol.Ordering.sequence)
  return _impl_.sequence_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::iroha::protocol::Ordering_FieldOrdering >*
Ordering::mutable_sequence() {
  // @@protoc_insertion_point(field_mutable_list:iroha.protocol.Ordering.sequence)
  return &_impl_.sequence_;
}
inline const ::iroha::protocol::Ordering_FieldOrdering& Ordering::_internal_sequence(int index) const {
  return _impl_.sequence_.Get(index);
}
inline const ::iroha::protocol::Ordering_FieldOrdering& Ordering::sequence(int index) const {
  // @@protoc_insertion_point(field_get:iroha.protocol.Ordering.sequence)
  return _internal_sequence(index);
}
inline ::iroha::protocol::Ordering_FieldOrdering* Ordering::_internal_add_sequence() {
  return _impl_.sequence_.Add();
}
inline ::iroha::protocol::Ordering_FieldOrdering* Ordering::add_sequence() {
  ::iroha::protocol::Ordering_FieldOrdering* _add = _internal_add_sequence();
  // @@protoc_insertion_point(field_add:iroha.protocol.Ordering.sequence)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::iroha::protocol::Ordering_FieldOrdering >&
Ordering::sequence() const {
  // @@protoc_insertion_point(field_list:iroha.protocol.Ordering.sequence)
  return _impl_.sequence_;
}

// -------------------------------------------------------------------

// TxPaginationMeta

// uint32 page_size = 1;
inline void TxPaginationMeta::clear_page_size() {
  _impl_.page_size_ = 0u;
}
inline uint32_t TxPaginationMeta::_internal_page_size() const {
  return _impl_.page_size_;
}
inline uint32_t TxPaginationMeta::page_size() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.TxPaginationMeta.page_size)
  return _internal_page_size();
}
inline void TxPaginationMeta::_internal_set_page_size(uint32_t value) {
  
  _impl_.page_size_ = value;
}
inline void TxPaginationMeta::set_page_size(uint32_t value) {
  _internal_set_page_size(value);
  // @@protoc_insertion_point(field_set:iroha.protocol.TxPaginationMeta.page_size)
}

// string first_tx_hash = 2;
inline bool TxPaginationMeta::_internal_has_first_tx_hash() const {
  return opt_first_tx_hash_case() == kFirstTxHash;
}
inline bool TxPaginationMeta::has_first_tx_hash() const {
  return _internal_has_first_tx_hash();
}
inline void TxPaginationMeta::set_has_first_tx_hash() {
  _impl_._oneof_case_[0] = kFirstTxHash;
}
inline void TxPaginationMeta::clear_first_tx_hash() {
  if (_internal_has_first_tx_hash()) {
    _impl_.opt_first_tx_hash_.first_tx_hash_.Destroy();
    clear_has_opt_first_tx_hash();
  }
}
inline const std::string& TxPaginationMeta::first_tx_hash() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.TxPaginationMeta.first_tx_hash)
  return _internal_first_tx_hash();
}
template <typename ArgT0, typename... ArgT>
inline void TxPaginationMeta::set_first_tx_hash(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_first_tx_hash()) {
    clear_opt_first_tx_hash();
    set_has_first_tx_hash();
    _impl_.opt_first_tx_hash_.first_tx_hash_.InitDefault();
  }
  _impl_.opt_first_tx_hash_.first_tx_hash_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:iroha.protocol.TxPaginationMeta.first_tx_hash)
}
inline std::string* TxPaginationMeta::mutable_first_tx_hash() {
  std::string* _s = _internal_mutable_first_tx_hash();
  // @@protoc_insertion_point(field_mutable:iroha.protocol.TxPaginationMeta.first_tx_hash)
  return _s;
}
inline const std::string& TxPaginationMeta::_internal_first_tx_hash() const {
  if (_internal_has_first_tx_hash()) {
    return _impl_.opt_first_tx_hash_.first_tx_hash_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void TxPaginationMeta::_internal_set_first_tx_hash(const std::string& value) {
  if (!_internal_has_first_tx_hash()) {
    clear_opt_first_tx_hash();
    set_has_first_tx_hash();
    _impl_.opt_first_tx_hash_.first_tx_hash_.InitDefault();
  }
  _impl_.opt_first_tx_hash_.first_tx_hash_.Set(value, GetArenaForAllocation());
}
inline std::string* TxPaginationMeta::_internal_mutable_first_tx_hash() {
  if (!_internal_has_first_tx_hash()) {
    clear_opt_first_tx_hash();
    set_has_first_tx_hash();
    _impl_.opt_first_tx_hash_.first_tx_hash_.InitDefault();
  }
  return _impl_.opt_first_tx_hash_.first_tx_hash_.Mutable(      GetArenaForAllocation());
}
inline std::string* TxPaginationMeta::release_first_tx_hash() {
  // @@protoc_insertion_point(field_release:iroha.protocol.TxPaginationMeta.first_tx_hash)
  if (_internal_has_first_tx_hash()) {
    clear_has_opt_first_tx_hash();
    return _impl_.opt_first_tx_hash_.first_tx_hash_.Release();
  } else {
    return nullptr;
  }
}
inline void TxPaginationMeta::set_allocated_first_tx_hash(std::string* first_tx_hash) {
  if (has_opt_first_tx_hash()) {
    clear_opt_first_tx_hash();
  }
  if (first_tx_hash != nullptr) {
    set_has_first_tx_hash();
    _impl_.opt_first_tx_hash_.first_tx_hash_.InitAllocated(first_tx_hash, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:iroha.protocol.TxPaginationMeta.first_tx_hash)
}

// .iroha.protocol.Ordering ordering = 3;
inline bool TxPaginationMeta::_internal_has_ordering() const {
  return this != internal_default_instance() && _impl_.ordering_ != nullptr;
}
inline bool TxPaginationMeta::has_ordering() const {
  return _internal_has_ordering();
}
inline void TxPaginationMeta::clear_ordering() {
  if (GetArenaForAllocation() == nullptr && _impl_.ordering_ != nullptr) {
    delete _impl_.ordering_;
  }
  _impl_.ordering_ = nullptr;
}
inline const ::iroha::protocol::Ordering& TxPaginationMeta::_internal_ordering() const {
  const ::iroha::protocol::Ordering* p = _impl_.ordering_;
  return p != nullptr ? *p : reinterpret_cast<const ::iroha::protocol::Ordering&>(
      ::iroha::protocol::_Ordering_default_instance_);
}
inline const ::iroha::protocol::Ordering& TxPaginationMeta::ordering() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.TxPaginationMeta.ordering)
  return _internal_ordering();
}
inline void TxPaginationMeta::unsafe_arena_set_allocated_ordering(
    ::iroha::protocol::Ordering* ordering) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.ordering_);
  }
  _impl_.ordering_ = ordering;
  if (ordering) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:iroha.protocol.TxPaginationMeta.ordering)
}
inline ::iroha::protocol::Ordering* TxPaginationMeta::release_ordering() {
  
  ::iroha::protocol::Ordering* temp = _impl_.ordering_;
  _impl_.ordering_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::iroha::protocol::Ordering* TxPaginationMeta::unsafe_arena_release_ordering() {
  // @@protoc_insertion_point(field_release:iroha.protocol.TxPaginationMeta.ordering)
  
  ::iroha::protocol::Ordering* temp = _impl_.ordering_;
  _impl_.ordering_ = nullptr;
  return temp;
}
inline ::iroha::protocol::Ordering* TxPaginationMeta::_internal_mutable_ordering() {
  
  if (_impl_.ordering_ == nullptr) {
    auto* p = CreateMaybeMessage<::iroha::protocol::Ordering>(GetArenaForAllocation());
    _impl_.ordering_ = p;
  }
  return _impl_.ordering_;
}
inline ::iroha::protocol::Ordering* TxPaginationMeta::mutable_ordering() {
  ::iroha::protocol::Ordering* _msg = _internal_mutable_ordering();
  // @@protoc_insertion_point(field_mutable:iroha.protocol.TxPaginationMeta.ordering)
  return _msg;
}
inline void TxPaginationMeta::set_allocated_ordering(::iroha::protocol::Ordering* ordering) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.ordering_;
  }
  if (ordering) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(ordering);
    if (message_arena != submessage_arena) {
      ordering = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ordering, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.ordering_ = ordering;
  // @@protoc_insertion_point(field_set_allocated:iroha.protocol.TxPaginationMeta.ordering)
}

// .google.protobuf.Timestamp first_tx_time = 4;
inline bool TxPaginationMeta::_internal_has_first_tx_time() const {
  return opt_first_tx_time_case() == kFirstTxTime;
}
inline bool TxPaginationMeta::has_first_tx_time() const {
  return _internal_has_first_tx_time();
}
inline void TxPaginationMeta::set_has_first_tx_time() {
  _impl_._oneof_case_[1] = kFirstTxTime;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* TxPaginationMeta::release_first_tx_time() {
  // @@protoc_insertion_point(field_release:iroha.protocol.TxPaginationMeta.first_tx_time)
  if (_internal_has_first_tx_time()) {
    clear_has_opt_first_tx_time();
    ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.opt_first_tx_time_.first_tx_time_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.opt_first_tx_time_.first_tx_time_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& TxPaginationMeta::_internal_first_tx_time() const {
  return _internal_has_first_tx_time()
      ? *_impl_.opt_first_tx_time_.first_tx_time_
      : reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::Timestamp&>(::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& TxPaginationMeta::first_tx_time() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.TxPaginationMeta.first_tx_time)
  return _internal_first_tx_time();
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* TxPaginationMeta::unsafe_arena_release_first_tx_time() {
  // @@protoc_insertion_point(field_unsafe_arena_release:iroha.protocol.TxPaginationMeta.first_tx_time)
  if (_internal_has_first_tx_time()) {
    clear_has_opt_first_tx_time();
    ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.opt_first_tx_time_.first_tx_time_;
    _impl_.opt_first_tx_time_.first_tx_time_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TxPaginationMeta::unsafe_arena_set_allocated_first_tx_time(::PROTOBUF_NAMESPACE_ID::Timestamp* first_tx_time) {
  clear_opt_first_tx_time();
  if (first_tx_time) {
    set_has_first_tx_time();
    _impl_.opt_first_tx_time_.first_tx_time_ = first_tx_time;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:iroha.protocol.TxPaginationMeta.first_tx_time)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* TxPaginationMeta::_internal_mutable_first_tx_time() {
  if (!_internal_has_first_tx_time()) {
    clear_opt_first_tx_time();
    set_has_first_tx_time();
    _impl_.opt_first_tx_time_.first_tx_time_ = CreateMaybeMessage< ::PROTOBUF_NAMESPACE_ID::Timestamp >(GetArenaForAllocation());
  }
  return _impl_.opt_first_tx_time_.first_tx_time_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* TxPaginationMeta::mutable_first_tx_time() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_first_tx_time();
  // @@protoc_insertion_point(field_mutable:iroha.protocol.TxPaginationMeta.first_tx_time)
  return _msg;
}

// .google.protobuf.Timestamp last_tx_time = 5;
inline bool TxPaginationMeta::_internal_has_last_tx_time() const {
  return opt_last_tx_time_case() == kLastTxTime;
}
inline bool TxPaginationMeta::has_last_tx_time() const {
  return _internal_has_last_tx_time();
}
inline void TxPaginationMeta::set_has_last_tx_time() {
  _impl_._oneof_case_[2] = kLastTxTime;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* TxPaginationMeta::release_last_tx_time() {
  // @@protoc_insertion_point(field_release:iroha.protocol.TxPaginationMeta.last_tx_time)
  if (_internal_has_last_tx_time()) {
    clear_has_opt_last_tx_time();
    ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.opt_last_tx_time_.last_tx_time_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.opt_last_tx_time_.last_tx_time_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& TxPaginationMeta::_internal_last_tx_time() const {
  return _internal_has_last_tx_time()
      ? *_impl_.opt_last_tx_time_.last_tx_time_
      : reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::Timestamp&>(::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& TxPaginationMeta::last_tx_time() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.TxPaginationMeta.last_tx_time)
  return _internal_last_tx_time();
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* TxPaginationMeta::unsafe_arena_release_last_tx_time() {
  // @@protoc_insertion_point(field_unsafe_arena_release:iroha.protocol.TxPaginationMeta.last_tx_time)
  if (_internal_has_last_tx_time()) {
    clear_has_opt_last_tx_time();
    ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.opt_last_tx_time_.last_tx_time_;
    _impl_.opt_last_tx_time_.last_tx_time_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TxPaginationMeta::unsafe_arena_set_allocated_last_tx_time(::PROTOBUF_NAMESPACE_ID::Timestamp* last_tx_time) {
  clear_opt_last_tx_time();
  if (last_tx_time) {
    set_has_last_tx_time();
    _impl_.opt_last_tx_time_.last_tx_time_ = last_tx_time;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:iroha.protocol.TxPaginationMeta.last_tx_time)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* TxPaginationMeta::_internal_mutable_last_tx_time() {
  if (!_internal_has_last_tx_time()) {
    clear_opt_last_tx_time();
    set_has_last_tx_time();
    _impl_.opt_last_tx_time_.last_tx_time_ = CreateMaybeMessage< ::PROTOBUF_NAMESPACE_ID::Timestamp >(GetArenaForAllocation());
  }
  return _impl_.opt_last_tx_time_.last_tx_time_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* TxPaginationMeta::mutable_last_tx_time() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_last_tx_time();
  // @@protoc_insertion_point(field_mutable:iroha.protocol.TxPaginationMeta.last_tx_time)
  return _msg;
}

// uint64 first_tx_height = 6;
inline bool TxPaginationMeta::_internal_has_first_tx_height() const {
  return opt_first_tx_height_case() == kFirstTxHeight;
}
inline bool TxPaginationMeta::has_first_tx_height() const {
  return _internal_has_first_tx_height();
}
inline void TxPaginationMeta::set_has_first_tx_height() {
  _impl_._oneof_case_[3] = kFirstTxHeight;
}
inline void TxPaginationMeta::clear_first_tx_height() {
  if (_internal_has_first_tx_height()) {
    _impl_.opt_first_tx_height_.first_tx_height_ = uint64_t{0u};
    clear_has_opt_first_tx_height();
  }
}
inline uint64_t TxPaginationMeta::_internal_first_tx_height() const {
  if (_internal_has_first_tx_height()) {
    return _impl_.opt_first_tx_height_.first_tx_height_;
  }
  return uint64_t{0u};
}
inline void TxPaginationMeta::_internal_set_first_tx_height(uint64_t value) {
  if (!_internal_has_first_tx_height()) {
    clear_opt_first_tx_height();
    set_has_first_tx_height();
  }
  _impl_.opt_first_tx_height_.first_tx_height_ = value;
}
inline uint64_t TxPaginationMeta::first_tx_height() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.TxPaginationMeta.first_tx_height)
  return _internal_first_tx_height();
}
inline void TxPaginationMeta::set_first_tx_height(uint64_t value) {
  _internal_set_first_tx_height(value);
  // @@protoc_insertion_point(field_set:iroha.protocol.TxPaginationMeta.first_tx_height)
}

// uint64 last_tx_height = 7;
inline bool TxPaginationMeta::_internal_has_last_tx_height() const {
  return opt_last_tx_height_case() == kLastTxHeight;
}
inline bool TxPaginationMeta::has_last_tx_height() const {
  return _internal_has_last_tx_height();
}
inline void TxPaginationMeta::set_has_last_tx_height() {
  _impl_._oneof_case_[4] = kLastTxHeight;
}
inline void TxPaginationMeta::clear_last_tx_height() {
  if (_internal_has_last_tx_height()) {
    _impl_.opt_last_tx_height_.last_tx_height_ = uint64_t{0u};
    clear_has_opt_last_tx_height();
  }
}
inline uint64_t TxPaginationMeta::_internal_last_tx_height() const {
  if (_internal_has_last_tx_height()) {
    return _impl_.opt_last_tx_height_.last_tx_height_;
  }
  return uint64_t{0u};
}
inline void TxPaginationMeta::_internal_set_last_tx_height(uint64_t value) {
  if (!_internal_has_last_tx_height()) {
    clear_opt_last_tx_height();
    set_has_last_tx_height();
  }
  _impl_.opt_last_tx_height_.last_tx_height_ = value;
}
inline uint64_t TxPaginationMeta::last_tx_height() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.TxPaginationMeta.last_tx_height)
  return _internal_last_tx_height();
}
inline void TxPaginationMeta::set_last_tx_height(uint64_t value) {
  _internal_set_last_tx_height(value);
  // @@protoc_insertion_point(field_set:iroha.protocol.TxPaginationMeta.last_tx_height)
}

inline bool TxPaginationMeta::has_opt_first_tx_hash() const {
  return opt_first_tx_hash_case() != OPT_FIRST_TX_HASH_NOT_SET;
}
inline void TxPaginationMeta::clear_has_opt_first_tx_hash() {
  _impl_._oneof_case_[0] = OPT_FIRST_TX_HASH_NOT_SET;
}
inline bool TxPaginationMeta::has_opt_first_tx_time() const {
  return opt_first_tx_time_case() != OPT_FIRST_TX_TIME_NOT_SET;
}
inline void TxPaginationMeta::clear_has_opt_first_tx_time() {
  _impl_._oneof_case_[1] = OPT_FIRST_TX_TIME_NOT_SET;
}
inline bool TxPaginationMeta::has_opt_last_tx_time() const {
  return opt_last_tx_time_case() != OPT_LAST_TX_TIME_NOT_SET;
}
inline void TxPaginationMeta::clear_has_opt_last_tx_time() {
  _impl_._oneof_case_[2] = OPT_LAST_TX_TIME_NOT_SET;
}
inline bool TxPaginationMeta::has_opt_first_tx_height() const {
  return opt_first_tx_height_case() != OPT_FIRST_TX_HEIGHT_NOT_SET;
}
inline void TxPaginationMeta::clear_has_opt_first_tx_height() {
  _impl_._oneof_case_[3] = OPT_FIRST_TX_HEIGHT_NOT_SET;
}
inline bool TxPaginationMeta::has_opt_last_tx_height() const {
  return opt_last_tx_height_case() != OPT_LAST_TX_HEIGHT_NOT_SET;
}
inline void TxPaginationMeta::clear_has_opt_last_tx_height() {
  _impl_._oneof_case_[4] = OPT_LAST_TX_HEIGHT_NOT_SET;
}
inline TxPaginationMeta::OptFirstTxHashCase TxPaginationMeta::opt_first_tx_hash_case() const {
  return TxPaginationMeta::OptFirstTxHashCase(_impl_._oneof_case_[0]);
}
inline TxPaginationMeta::OptFirstTxTimeCase TxPaginationMeta::opt_first_tx_time_case() const {
  return TxPaginationMeta::OptFirstTxTimeCase(_impl_._oneof_case_[1]);
}
inline TxPaginationMeta::OptLastTxTimeCase TxPaginationMeta::opt_last_tx_time_case() const {
  return TxPaginationMeta::OptLastTxTimeCase(_impl_._oneof_case_[2]);
}
inline TxPaginationMeta::OptFirstTxHeightCase TxPaginationMeta::opt_first_tx_height_case() const {
  return TxPaginationMeta::OptFirstTxHeightCase(_impl_._oneof_case_[3]);
}
inline TxPaginationMeta::OptLastTxHeightCase TxPaginationMeta::opt_last_tx_height_case() const {
  return TxPaginationMeta::OptLastTxHeightCase(_impl_._oneof_case_[4]);
}
// -------------------------------------------------------------------

// AssetPaginationMeta

// uint32 page_size = 1;
inline void AssetPaginationMeta::clear_page_size() {
  _impl_.page_size_ = 0u;
}
inline uint32_t AssetPaginationMeta::_internal_page_size() const {
  return _impl_.page_size_;
}
inline uint32_t AssetPaginationMeta::page_size() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.AssetPaginationMeta.page_size)
  return _internal_page_size();
}
inline void AssetPaginationMeta::_internal_set_page_size(uint32_t value) {
  
  _impl_.page_size_ = value;
}
inline void AssetPaginationMeta::set_page_size(uint32_t value) {
  _internal_set_page_size(value);
  // @@protoc_insertion_point(field_set:iroha.protocol.AssetPaginationMeta.page_size)
}

// string first_asset_id = 2;
inline bool AssetPaginationMeta::_internal_has_first_asset_id() const {
  return opt_first_asset_id_case() == kFirstAssetId;
}
inline bool AssetPaginationMeta::has_first_asset_id() const {
  return _internal_has_first_asset_id();
}
inline void AssetPaginationMeta::set_has_first_asset_id() {
  _impl_._oneof_case_[0] = kFirstAssetId;
}
inline void AssetPaginationMeta::clear_first_asset_id() {
  if (_internal_has_first_asset_id()) {
    _impl_.opt_first_asset_id_.first_asset_id_.Destroy();
    clear_has_opt_first_asset_id();
  }
}
inline const std::string& AssetPaginationMeta::first_asset_id() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.AssetPaginationMeta.first_asset_id)
  return _internal_first_asset_id();
}
template <typename ArgT0, typename... ArgT>
inline void AssetPaginationMeta::set_first_asset_id(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_first_asset_id()) {
    clear_opt_first_asset_id();
    set_has_first_asset_id();
    _impl_.opt_first_asset_id_.first_asset_id_.InitDefault();
  }
  _impl_.opt_first_asset_id_.first_asset_id_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:iroha.protocol.AssetPaginationMeta.first_asset_id)
}
inline std::string* AssetPaginationMeta::mutable_first_asset_id() {
  std::string* _s = _internal_mutable_first_asset_id();
  // @@protoc_insertion_point(field_mutable:iroha.protocol.AssetPaginationMeta.first_asset_id)
  return _s;
}
inline const std::string& AssetPaginationMeta::_internal_first_asset_id() const {
  if (_internal_has_first_asset_id()) {
    return _impl_.opt_first_asset_id_.first_asset_id_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void AssetPaginationMeta::_internal_set_first_asset_id(const std::string& value) {
  if (!_internal_has_first_asset_id()) {
    clear_opt_first_asset_id();
    set_has_first_asset_id();
    _impl_.opt_first_asset_id_.first_asset_id_.InitDefault();
  }
  _impl_.opt_first_asset_id_.first_asset_id_.Set(value, GetArenaForAllocation());
}
inline std::string* AssetPaginationMeta::_internal_mutable_first_asset_id() {
  if (!_internal_has_first_asset_id()) {
    clear_opt_first_asset_id();
    set_has_first_asset_id();
    _impl_.opt_first_asset_id_.first_asset_id_.InitDefault();
  }
  return _impl_.opt_first_asset_id_.first_asset_id_.Mutable(      GetArenaForAllocation());
}
inline std::string* AssetPaginationMeta::release_first_asset_id() {
  // @@protoc_insertion_point(field_release:iroha.protocol.AssetPaginationMeta.first_asset_id)
  if (_internal_has_first_asset_id()) {
    clear_has_opt_first_asset_id();
    return _impl_.opt_first_asset_id_.first_asset_id_.Release();
  } else {
    return nullptr;
  }
}
inline void AssetPaginationMeta::set_allocated_first_asset_id(std::string* first_asset_id) {
  if (has_opt_first_asset_id()) {
    clear_opt_first_asset_id();
  }
  if (first_asset_id != nullptr) {
    set_has_first_asset_id();
    _impl_.opt_first_asset_id_.first_asset_id_.InitAllocated(first_asset_id, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:iroha.protocol.AssetPaginationMeta.first_asset_id)
}

inline bool AssetPaginationMeta::has_opt_first_asset_id() const {
  return opt_first_asset_id_case() != OPT_FIRST_ASSET_ID_NOT_SET;
}
inline void AssetPaginationMeta::clear_has_opt_first_asset_id() {
  _impl_._oneof_case_[0] = OPT_FIRST_ASSET_ID_NOT_SET;
}
inline AssetPaginationMeta::OptFirstAssetIdCase AssetPaginationMeta::opt_first_asset_id_case() const {
  return AssetPaginationMeta::OptFirstAssetIdCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// GetAccount

// string account_id = 1;
inline void GetAccount::clear_account_id() {
  _impl_.account_id_.ClearToEmpty();
}
inline const std::string& GetAccount::account_id() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.GetAccount.account_id)
  return _internal_account_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetAccount::set_account_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.account_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:iroha.protocol.GetAccount.account_id)
}
inline std::string* GetAccount::mutable_account_id() {
  std::string* _s = _internal_mutable_account_id();
  // @@protoc_insertion_point(field_mutable:iroha.protocol.GetAccount.account_id)
  return _s;
}
inline const std::string& GetAccount::_internal_account_id() const {
  return _impl_.account_id_.Get();
}
inline void GetAccount::_internal_set_account_id(const std::string& value) {
  
  _impl_.account_id_.Set(value, GetArenaForAllocation());
}
inline std::string* GetAccount::_internal_mutable_account_id() {
  
  return _impl_.account_id_.Mutable(GetArenaForAllocation());
}
inline std::string* GetAccount::release_account_id() {
  // @@protoc_insertion_point(field_release:iroha.protocol.GetAccount.account_id)
  return _impl_.account_id_.Release();
}
inline void GetAccount::set_allocated_account_id(std::string* account_id) {
  if (account_id != nullptr) {
    
  } else {
    
  }
  _impl_.account_id_.SetAllocated(account_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.account_id_.IsDefault()) {
    _impl_.account_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:iroha.protocol.GetAccount.account_id)
}

// -------------------------------------------------------------------

// GetBlock

// uint64 height = 1;
inline void GetBlock::clear_height() {
  _impl_.height_ = uint64_t{0u};
}
inline uint64_t GetBlock::_internal_height() const {
  return _impl_.height_;
}
inline uint64_t GetBlock::height() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.GetBlock.height)
  return _internal_height();
}
inline void GetBlock::_internal_set_height(uint64_t value) {
  
  _impl_.height_ = value;
}
inline void GetBlock::set_height(uint64_t value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:iroha.protocol.GetBlock.height)
}

// -------------------------------------------------------------------

// GetSignatories

// string account_id = 1;
inline void GetSignatories::clear_account_id() {
  _impl_.account_id_.ClearToEmpty();
}
inline const std::string& GetSignatories::account_id() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.GetSignatories.account_id)
  return _internal_account_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetSignatories::set_account_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.account_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:iroha.protocol.GetSignatories.account_id)
}
inline std::string* GetSignatories::mutable_account_id() {
  std::string* _s = _internal_mutable_account_id();
  // @@protoc_insertion_point(field_mutable:iroha.protocol.GetSignatories.account_id)
  return _s;
}
inline const std::string& GetSignatories::_internal_account_id() const {
  return _impl_.account_id_.Get();
}
inline void GetSignatories::_internal_set_account_id(const std::string& value) {
  
  _impl_.account_id_.Set(value, GetArenaForAllocation());
}
inline std::string* GetSignatories::_internal_mutable_account_id() {
  
  return _impl_.account_id_.Mutable(GetArenaForAllocation());
}
inline std::string* GetSignatories::release_account_id() {
  // @@protoc_insertion_point(field_release:iroha.protocol.GetSignatories.account_id)
  return _impl_.account_id_.Release();
}
inline void GetSignatories::set_allocated_account_id(std::string* account_id) {
  if (account_id != nullptr) {
    
  } else {
    
  }
  _impl_.account_id_.SetAllocated(account_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.account_id_.IsDefault()) {
    _impl_.account_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:iroha.protocol.GetSignatories.account_id)
}

// -------------------------------------------------------------------

// GetAccountTransactions

// string account_id = 1;
inline void GetAccountTransactions::clear_account_id() {
  _impl_.account_id_.ClearToEmpty();
}
inline const std::string& GetAccountTransactions::account_id() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.GetAccountTransactions.account_id)
  return _internal_account_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetAccountTransactions::set_account_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.account_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:iroha.protocol.GetAccountTransactions.account_id)
}
inline std::string* GetAccountTransactions::mutable_account_id() {
  std::string* _s = _internal_mutable_account_id();
  // @@protoc_insertion_point(field_mutable:iroha.protocol.GetAccountTransactions.account_id)
  return _s;
}
inline const std::string& GetAccountTransactions::_internal_account_id() const {
  return _impl_.account_id_.Get();
}
inline void GetAccountTransactions::_internal_set_account_id(const std::string& value) {
  
  _impl_.account_id_.Set(value, GetArenaForAllocation());
}
inline std::string* GetAccountTransactions::_internal_mutable_account_id() {
  
  return _impl_.account_id_.Mutable(GetArenaForAllocation());
}
inline std::string* GetAccountTransactions::release_account_id() {
  // @@protoc_insertion_point(field_release:iroha.protocol.GetAccountTransactions.account_id)
  return _impl_.account_id_.Release();
}
inline void GetAccountTransactions::set_allocated_account_id(std::string* account_id) {
  if (account_id != nullptr) {
    
  } else {
    
  }
  _impl_.account_id_.SetAllocated(account_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.account_id_.IsDefault()) {
    _impl_.account_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:iroha.protocol.GetAccountTransactions.account_id)
}

// .iroha.protocol.TxPaginationMeta pagination_meta = 2;
inline bool GetAccountTransactions::_internal_has_pagination_meta() const {
  return this != internal_default_instance() && _impl_.pagination_meta_ != nullptr;
}
inline bool GetAccountTransactions::has_pagination_meta() const {
  return _internal_has_pagination_meta();
}
inline void GetAccountTransactions::clear_pagination_meta() {
  if (GetArenaForAllocation() == nullptr && _impl_.pagination_meta_ != nullptr) {
    delete _impl_.pagination_meta_;
  }
  _impl_.pagination_meta_ = nullptr;
}
inline const ::iroha::protocol::TxPaginationMeta& GetAccountTransactions::_internal_pagination_meta() const {
  const ::iroha::protocol::TxPaginationMeta* p = _impl_.pagination_meta_;
  return p != nullptr ? *p : reinterpret_cast<const ::iroha::protocol::TxPaginationMeta&>(
      ::iroha::protocol::_TxPaginationMeta_default_instance_);
}
inline const ::iroha::protocol::TxPaginationMeta& GetAccountTransactions::pagination_meta() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.GetAccountTransactions.pagination_meta)
  return _internal_pagination_meta();
}
inline void GetAccountTransactions::unsafe_arena_set_allocated_pagination_meta(
    ::iroha::protocol::TxPaginationMeta* pagination_meta) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pagination_meta_);
  }
  _impl_.pagination_meta_ = pagination_meta;
  if (pagination_meta) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:iroha.protocol.GetAccountTransactions.pagination_meta)
}
inline ::iroha::protocol::TxPaginationMeta* GetAccountTransactions::release_pagination_meta() {
  
  ::iroha::protocol::TxPaginationMeta* temp = _impl_.pagination_meta_;
  _impl_.pagination_meta_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::iroha::protocol::TxPaginationMeta* GetAccountTransactions::unsafe_arena_release_pagination_meta() {
  // @@protoc_insertion_point(field_release:iroha.protocol.GetAccountTransactions.pagination_meta)
  
  ::iroha::protocol::TxPaginationMeta* temp = _impl_.pagination_meta_;
  _impl_.pagination_meta_ = nullptr;
  return temp;
}
inline ::iroha::protocol::TxPaginationMeta* GetAccountTransactions::_internal_mutable_pagination_meta() {
  
  if (_impl_.pagination_meta_ == nullptr) {
    auto* p = CreateMaybeMessage<::iroha::protocol::TxPaginationMeta>(GetArenaForAllocation());
    _impl_.pagination_meta_ = p;
  }
  return _impl_.pagination_meta_;
}
inline ::iroha::protocol::TxPaginationMeta* GetAccountTransactions::mutable_pagination_meta() {
  ::iroha::protocol::TxPaginationMeta* _msg = _internal_mutable_pagination_meta();
  // @@protoc_insertion_point(field_mutable:iroha.protocol.GetAccountTransactions.pagination_meta)
  return _msg;
}
inline void GetAccountTransactions::set_allocated_pagination_meta(::iroha::protocol::TxPaginationMeta* pagination_meta) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.pagination_meta_;
  }
  if (pagination_meta) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(pagination_meta);
    if (message_arena != submessage_arena) {
      pagination_meta = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pagination_meta, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.pagination_meta_ = pagination_meta;
  // @@protoc_insertion_point(field_set_allocated:iroha.protocol.GetAccountTransactions.pagination_meta)
}

// -------------------------------------------------------------------

// GetAccountAssetTransactions

// string account_id = 1;
inline void GetAccountAssetTransactions::clear_account_id() {
  _impl_.account_id_.ClearToEmpty();
}
inline const std::string& GetAccountAssetTransactions::account_id() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.GetAccountAssetTransactions.account_id)
  return _internal_account_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetAccountAssetTransactions::set_account_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.account_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:iroha.protocol.GetAccountAssetTransactions.account_id)
}
inline std::string* GetAccountAssetTransactions::mutable_account_id() {
  std::string* _s = _internal_mutable_account_id();
  // @@protoc_insertion_point(field_mutable:iroha.protocol.GetAccountAssetTransactions.account_id)
  return _s;
}
inline const std::string& GetAccountAssetTransactions::_internal_account_id() const {
  return _impl_.account_id_.Get();
}
inline void GetAccountAssetTransactions::_internal_set_account_id(const std::string& value) {
  
  _impl_.account_id_.Set(value, GetArenaForAllocation());
}
inline std::string* GetAccountAssetTransactions::_internal_mutable_account_id() {
  
  return _impl_.account_id_.Mutable(GetArenaForAllocation());
}
inline std::string* GetAccountAssetTransactions::release_account_id() {
  // @@protoc_insertion_point(field_release:iroha.protocol.GetAccountAssetTransactions.account_id)
  return _impl_.account_id_.Release();
}
inline void GetAccountAssetTransactions::set_allocated_account_id(std::string* account_id) {
  if (account_id != nullptr) {
    
  } else {
    
  }
  _impl_.account_id_.SetAllocated(account_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.account_id_.IsDefault()) {
    _impl_.account_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:iroha.protocol.GetAccountAssetTransactions.account_id)
}

// string asset_id = 2;
inline void GetAccountAssetTransactions::clear_asset_id() {
  _impl_.asset_id_.ClearToEmpty();
}
inline const std::string& GetAccountAssetTransactions::asset_id() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.GetAccountAssetTransactions.asset_id)
  return _internal_asset_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetAccountAssetTransactions::set_asset_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.asset_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:iroha.protocol.GetAccountAssetTransactions.asset_id)
}
inline std::string* GetAccountAssetTransactions::mutable_asset_id() {
  std::string* _s = _internal_mutable_asset_id();
  // @@protoc_insertion_point(field_mutable:iroha.protocol.GetAccountAssetTransactions.asset_id)
  return _s;
}
inline const std::string& GetAccountAssetTransactions::_internal_asset_id() const {
  return _impl_.asset_id_.Get();
}
inline void GetAccountAssetTransactions::_internal_set_asset_id(const std::string& value) {
  
  _impl_.asset_id_.Set(value, GetArenaForAllocation());
}
inline std::string* GetAccountAssetTransactions::_internal_mutable_asset_id() {
  
  return _impl_.asset_id_.Mutable(GetArenaForAllocation());
}
inline std::string* GetAccountAssetTransactions::release_asset_id() {
  // @@protoc_insertion_point(field_release:iroha.protocol.GetAccountAssetTransactions.asset_id)
  return _impl_.asset_id_.Release();
}
inline void GetAccountAssetTransactions::set_allocated_asset_id(std::string* asset_id) {
  if (asset_id != nullptr) {
    
  } else {
    
  }
  _impl_.asset_id_.SetAllocated(asset_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.asset_id_.IsDefault()) {
    _impl_.asset_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:iroha.protocol.GetAccountAssetTransactions.asset_id)
}

// .iroha.protocol.TxPaginationMeta pagination_meta = 3;
inline bool GetAccountAssetTransactions::_internal_has_pagination_meta() const {
  return this != internal_default_instance() && _impl_.pagination_meta_ != nullptr;
}
inline bool GetAccountAssetTransactions::has_pagination_meta() const {
  return _internal_has_pagination_meta();
}
inline void GetAccountAssetTransactions::clear_pagination_meta() {
  if (GetArenaForAllocation() == nullptr && _impl_.pagination_meta_ != nullptr) {
    delete _impl_.pagination_meta_;
  }
  _impl_.pagination_meta_ = nullptr;
}
inline const ::iroha::protocol::TxPaginationMeta& GetAccountAssetTransactions::_internal_pagination_meta() const {
  const ::iroha::protocol::TxPaginationMeta* p = _impl_.pagination_meta_;
  return p != nullptr ? *p : reinterpret_cast<const ::iroha::protocol::TxPaginationMeta&>(
      ::iroha::protocol::_TxPaginationMeta_default_instance_);
}
inline const ::iroha::protocol::TxPaginationMeta& GetAccountAssetTransactions::pagination_meta() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.GetAccountAssetTransactions.pagination_meta)
  return _internal_pagination_meta();
}
inline void GetAccountAssetTransactions::unsafe_arena_set_allocated_pagination_meta(
    ::iroha::protocol::TxPaginationMeta* pagination_meta) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pagination_meta_);
  }
  _impl_.pagination_meta_ = pagination_meta;
  if (pagination_meta) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:iroha.protocol.GetAccountAssetTransactions.pagination_meta)
}
inline ::iroha::protocol::TxPaginationMeta* GetAccountAssetTransactions::release_pagination_meta() {
  
  ::iroha::protocol::TxPaginationMeta* temp = _impl_.pagination_meta_;
  _impl_.pagination_meta_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::iroha::protocol::TxPaginationMeta* GetAccountAssetTransactions::unsafe_arena_release_pagination_meta() {
  // @@protoc_insertion_point(field_release:iroha.protocol.GetAccountAssetTransactions.pagination_meta)
  
  ::iroha::protocol::TxPaginationMeta* temp = _impl_.pagination_meta_;
  _impl_.pagination_meta_ = nullptr;
  return temp;
}
inline ::iroha::protocol::TxPaginationMeta* GetAccountAssetTransactions::_internal_mutable_pagination_meta() {
  
  if (_impl_.pagination_meta_ == nullptr) {
    auto* p = CreateMaybeMessage<::iroha::protocol::TxPaginationMeta>(GetArenaForAllocation());
    _impl_.pagination_meta_ = p;
  }
  return _impl_.pagination_meta_;
}
inline ::iroha::protocol::TxPaginationMeta* GetAccountAssetTransactions::mutable_pagination_meta() {
  ::iroha::protocol::TxPaginationMeta* _msg = _internal_mutable_pagination_meta();
  // @@protoc_insertion_point(field_mutable:iroha.protocol.GetAccountAssetTransactions.pagination_meta)
  return _msg;
}
inline void GetAccountAssetTransactions::set_allocated_pagination_meta(::iroha::protocol::TxPaginationMeta* pagination_meta) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.pagination_meta_;
  }
  if (pagination_meta) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(pagination_meta);
    if (message_arena != submessage_arena) {
      pagination_meta = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pagination_meta, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.pagination_meta_ = pagination_meta;
  // @@protoc_insertion_point(field_set_allocated:iroha.protocol.GetAccountAssetTransactions.pagination_meta)
}

// -------------------------------------------------------------------

// GetTransactions

// repeated string tx_hashes = 1;
inline int GetTransactions::_internal_tx_hashes_size() const {
  return _impl_.tx_hashes_.size();
}
inline int GetTransactions::tx_hashes_size() const {
  return _internal_tx_hashes_size();
}
inline void GetTransactions::clear_tx_hashes() {
  _impl_.tx_hashes_.Clear();
}
inline std::string* GetTransactions::add_tx_hashes() {
  std::string* _s = _internal_add_tx_hashes();
  // @@protoc_insertion_point(field_add_mutable:iroha.protocol.GetTransactions.tx_hashes)
  return _s;
}
inline const std::string& GetTransactions::_internal_tx_hashes(int index) const {
  return _impl_.tx_hashes_.Get(index);
}
inline const std::string& GetTransactions::tx_hashes(int index) const {
  // @@protoc_insertion_point(field_get:iroha.protocol.GetTransactions.tx_hashes)
  return _internal_tx_hashes(index);
}
inline std::string* GetTransactions::mutable_tx_hashes(int index) {
  // @@protoc_insertion_point(field_mutable:iroha.protocol.GetTransactions.tx_hashes)
  return _impl_.tx_hashes_.Mutable(index);
}
inline void GetTransactions::set_tx_hashes(int index, const std::string& value) {
  _impl_.tx_hashes_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:iroha.protocol.GetTransactions.tx_hashes)
}
inline void GetTransactions::set_tx_hashes(int index, std::string&& value) {
  _impl_.tx_hashes_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:iroha.protocol.GetTransactions.tx_hashes)
}
inline void GetTransactions::set_tx_hashes(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.tx_hashes_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:iroha.protocol.GetTransactions.tx_hashes)
}
inline void GetTransactions::set_tx_hashes(int index, const char* value, size_t size) {
  _impl_.tx_hashes_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:iroha.protocol.GetTransactions.tx_hashes)
}
inline std::string* GetTransactions::_internal_add_tx_hashes() {
  return _impl_.tx_hashes_.Add();
}
inline void GetTransactions::add_tx_hashes(const std::string& value) {
  _impl_.tx_hashes_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:iroha.protocol.GetTransactions.tx_hashes)
}
inline void GetTransactions::add_tx_hashes(std::string&& value) {
  _impl_.tx_hashes_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:iroha.protocol.GetTransactions.tx_hashes)
}
inline void GetTransactions::add_tx_hashes(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.tx_hashes_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:iroha.protocol.GetTransactions.tx_hashes)
}
inline void GetTransactions::add_tx_hashes(const char* value, size_t size) {
  _impl_.tx_hashes_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:iroha.protocol.GetTransactions.tx_hashes)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
GetTransactions::tx_hashes() const {
  // @@protoc_insertion_point(field_list:iroha.protocol.GetTransactions.tx_hashes)
  return _impl_.tx_hashes_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
GetTransactions::mutable_tx_hashes() {
  // @@protoc_insertion_point(field_mutable_list:iroha.protocol.GetTransactions.tx_hashes)
  return &_impl_.tx_hashes_;
}

// -------------------------------------------------------------------

// GetAccountAssets

// string account_id = 1;
inline void GetAccountAssets::clear_account_id() {
  _impl_.account_id_.ClearToEmpty();
}
inline const std::string& GetAccountAssets::account_id() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.GetAccountAssets.account_id)
  return _internal_account_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetAccountAssets::set_account_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.account_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:iroha.protocol.GetAccountAssets.account_id)
}
inline std::string* GetAccountAssets::mutable_account_id() {
  std::string* _s = _internal_mutable_account_id();
  // @@protoc_insertion_point(field_mutable:iroha.protocol.GetAccountAssets.account_id)
  return _s;
}
inline const std::string& GetAccountAssets::_internal_account_id() const {
  return _impl_.account_id_.Get();
}
inline void GetAccountAssets::_internal_set_account_id(const std::string& value) {
  
  _impl_.account_id_.Set(value, GetArenaForAllocation());
}
inline std::string* GetAccountAssets::_internal_mutable_account_id() {
  
  return _impl_.account_id_.Mutable(GetArenaForAllocation());
}
inline std::string* GetAccountAssets::release_account_id() {
  // @@protoc_insertion_point(field_release:iroha.protocol.GetAccountAssets.account_id)
  return _impl_.account_id_.Release();
}
inline void GetAccountAssets::set_allocated_account_id(std::string* account_id) {
  if (account_id != nullptr) {
    
  } else {
    
  }
  _impl_.account_id_.SetAllocated(account_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.account_id_.IsDefault()) {
    _impl_.account_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:iroha.protocol.GetAccountAssets.account_id)
}

// .iroha.protocol.AssetPaginationMeta pagination_meta = 2;
inline bool GetAccountAssets::_internal_has_pagination_meta() const {
  return this != internal_default_instance() && _impl_.pagination_meta_ != nullptr;
}
inline bool GetAccountAssets::has_pagination_meta() const {
  return _internal_has_pagination_meta();
}
inline void GetAccountAssets::clear_pagination_meta() {
  if (GetArenaForAllocation() == nullptr && _impl_.pagination_meta_ != nullptr) {
    delete _impl_.pagination_meta_;
  }
  _impl_.pagination_meta_ = nullptr;
}
inline const ::iroha::protocol::AssetPaginationMeta& GetAccountAssets::_internal_pagination_meta() const {
  const ::iroha::protocol::AssetPaginationMeta* p = _impl_.pagination_meta_;
  return p != nullptr ? *p : reinterpret_cast<const ::iroha::protocol::AssetPaginationMeta&>(
      ::iroha::protocol::_AssetPaginationMeta_default_instance_);
}
inline const ::iroha::protocol::AssetPaginationMeta& GetAccountAssets::pagination_meta() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.GetAccountAssets.pagination_meta)
  return _internal_pagination_meta();
}
inline void GetAccountAssets::unsafe_arena_set_allocated_pagination_meta(
    ::iroha::protocol::AssetPaginationMeta* pagination_meta) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pagination_meta_);
  }
  _impl_.pagination_meta_ = pagination_meta;
  if (pagination_meta) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:iroha.protocol.GetAccountAssets.pagination_meta)
}
inline ::iroha::protocol::AssetPaginationMeta* GetAccountAssets::release_pagination_meta() {
  
  ::iroha::protocol::AssetPaginationMeta* temp = _impl_.pagination_meta_;
  _impl_.pagination_meta_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::iroha::protocol::AssetPaginationMeta* GetAccountAssets::unsafe_arena_release_pagination_meta() {
  // @@protoc_insertion_point(field_release:iroha.protocol.GetAccountAssets.pagination_meta)
  
  ::iroha::protocol::AssetPaginationMeta* temp = _impl_.pagination_meta_;
  _impl_.pagination_meta_ = nullptr;
  return temp;
}
inline ::iroha::protocol::AssetPaginationMeta* GetAccountAssets::_internal_mutable_pagination_meta() {
  
  if (_impl_.pagination_meta_ == nullptr) {
    auto* p = CreateMaybeMessage<::iroha::protocol::AssetPaginationMeta>(GetArenaForAllocation());
    _impl_.pagination_meta_ = p;
  }
  return _impl_.pagination_meta_;
}
inline ::iroha::protocol::AssetPaginationMeta* GetAccountAssets::mutable_pagination_meta() {
  ::iroha::protocol::AssetPaginationMeta* _msg = _internal_mutable_pagination_meta();
  // @@protoc_insertion_point(field_mutable:iroha.protocol.GetAccountAssets.pagination_meta)
  return _msg;
}
inline void GetAccountAssets::set_allocated_pagination_meta(::iroha::protocol::AssetPaginationMeta* pagination_meta) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.pagination_meta_;
  }
  if (pagination_meta) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(pagination_meta);
    if (message_arena != submessage_arena) {
      pagination_meta = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pagination_meta, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.pagination_meta_ = pagination_meta;
  // @@protoc_insertion_point(field_set_allocated:iroha.protocol.GetAccountAssets.pagination_meta)
}

// -------------------------------------------------------------------

// AccountDetailPaginationMeta

// uint32 page_size = 1;
inline void AccountDetailPaginationMeta::clear_page_size() {
  _impl_.page_size_ = 0u;
}
inline uint32_t AccountDetailPaginationMeta::_internal_page_size() const {
  return _impl_.page_size_;
}
inline uint32_t AccountDetailPaginationMeta::page_size() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.AccountDetailPaginationMeta.page_size)
  return _internal_page_size();
}
inline void AccountDetailPaginationMeta::_internal_set_page_size(uint32_t value) {
  
  _impl_.page_size_ = value;
}
inline void AccountDetailPaginationMeta::set_page_size(uint32_t value) {
  _internal_set_page_size(value);
  // @@protoc_insertion_point(field_set:iroha.protocol.AccountDetailPaginationMeta.page_size)
}

// .iroha.protocol.AccountDetailRecordId first_record_id = 2;
inline bool AccountDetailPaginationMeta::_internal_has_first_record_id() const {
  return this != internal_default_instance() && _impl_.first_record_id_ != nullptr;
}
inline bool AccountDetailPaginationMeta::has_first_record_id() const {
  return _internal_has_first_record_id();
}
inline const ::iroha::protocol::AccountDetailRecordId& AccountDetailPaginationMeta::_internal_first_record_id() const {
  const ::iroha::protocol::AccountDetailRecordId* p = _impl_.first_record_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::iroha::protocol::AccountDetailRecordId&>(
      ::iroha::protocol::_AccountDetailRecordId_default_instance_);
}
inline const ::iroha::protocol::AccountDetailRecordId& AccountDetailPaginationMeta::first_record_id() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.AccountDetailPaginationMeta.first_record_id)
  return _internal_first_record_id();
}
inline void AccountDetailPaginationMeta::unsafe_arena_set_allocated_first_record_id(
    ::iroha::protocol::AccountDetailRecordId* first_record_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.first_record_id_);
  }
  _impl_.first_record_id_ = first_record_id;
  if (first_record_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:iroha.protocol.AccountDetailPaginationMeta.first_record_id)
}
inline ::iroha::protocol::AccountDetailRecordId* AccountDetailPaginationMeta::release_first_record_id() {
  
  ::iroha::protocol::AccountDetailRecordId* temp = _impl_.first_record_id_;
  _impl_.first_record_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::iroha::protocol::AccountDetailRecordId* AccountDetailPaginationMeta::unsafe_arena_release_first_record_id() {
  // @@protoc_insertion_point(field_release:iroha.protocol.AccountDetailPaginationMeta.first_record_id)
  
  ::iroha::protocol::AccountDetailRecordId* temp = _impl_.first_record_id_;
  _impl_.first_record_id_ = nullptr;
  return temp;
}
inline ::iroha::protocol::AccountDetailRecordId* AccountDetailPaginationMeta::_internal_mutable_first_record_id() {
  
  if (_impl_.first_record_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::iroha::protocol::AccountDetailRecordId>(GetArenaForAllocation());
    _impl_.first_record_id_ = p;
  }
  return _impl_.first_record_id_;
}
inline ::iroha::protocol::AccountDetailRecordId* AccountDetailPaginationMeta::mutable_first_record_id() {
  ::iroha::protocol::AccountDetailRecordId* _msg = _internal_mutable_first_record_id();
  // @@protoc_insertion_point(field_mutable:iroha.protocol.AccountDetailPaginationMeta.first_record_id)
  return _msg;
}
inline void AccountDetailPaginationMeta::set_allocated_first_record_id(::iroha::protocol::AccountDetailRecordId* first_record_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.first_record_id_);
  }
  if (first_record_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(first_record_id));
    if (message_arena != submessage_arena) {
      first_record_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, first_record_id, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.first_record_id_ = first_record_id;
  // @@protoc_insertion_point(field_set_allocated:iroha.protocol.AccountDetailPaginationMeta.first_record_id)
}

// -------------------------------------------------------------------

// GetAccountDetail

// string account_id = 1;
inline bool GetAccountDetail::_internal_has_account_id() const {
  return opt_account_id_case() == kAccountId;
}
inline bool GetAccountDetail::has_account_id() const {
  return _internal_has_account_id();
}
inline void GetAccountDetail::set_has_account_id() {
  _impl_._oneof_case_[0] = kAccountId;
}
inline void GetAccountDetail::clear_account_id() {
  if (_internal_has_account_id()) {
    _impl_.opt_account_id_.account_id_.Destroy();
    clear_has_opt_account_id();
  }
}
inline const std::string& GetAccountDetail::account_id() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.GetAccountDetail.account_id)
  return _internal_account_id();
}
template <typename ArgT0, typename... ArgT>
inline void GetAccountDetail::set_account_id(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_account_id()) {
    clear_opt_account_id();
    set_has_account_id();
    _impl_.opt_account_id_.account_id_.InitDefault();
  }
  _impl_.opt_account_id_.account_id_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:iroha.protocol.GetAccountDetail.account_id)
}
inline std::string* GetAccountDetail::mutable_account_id() {
  std::string* _s = _internal_mutable_account_id();
  // @@protoc_insertion_point(field_mutable:iroha.protocol.GetAccountDetail.account_id)
  return _s;
}
inline const std::string& GetAccountDetail::_internal_account_id() const {
  if (_internal_has_account_id()) {
    return _impl_.opt_account_id_.account_id_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void GetAccountDetail::_internal_set_account_id(const std::string& value) {
  if (!_internal_has_account_id()) {
    clear_opt_account_id();
    set_has_account_id();
    _impl_.opt_account_id_.account_id_.InitDefault();
  }
  _impl_.opt_account_id_.account_id_.Set(value, GetArenaForAllocation());
}
inline std::string* GetAccountDetail::_internal_mutable_account_id() {
  if (!_internal_has_account_id()) {
    clear_opt_account_id();
    set_has_account_id();
    _impl_.opt_account_id_.account_id_.InitDefault();
  }
  return _impl_.opt_account_id_.account_id_.Mutable(      GetArenaForAllocation());
}
inline std::string* GetAccountDetail::release_account_id() {
  // @@protoc_insertion_point(field_release:iroha.protocol.GetAccountDetail.account_id)
  if (_internal_has_account_id()) {
    clear_has_opt_account_id();
    return _impl_.opt_account_id_.account_id_.Release();
  } else {
    return nullptr;
  }
}
inline void GetAccountDetail::set_allocated_account_id(std::string* account_id) {
  if (has_opt_account_id()) {
    clear_opt_account_id();
  }
  if (account_id != nullptr) {
    set_has_account_id();
    _impl_.opt_account_id_.account_id_.InitAllocated(account_id, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:iroha.protocol.GetAccountDetail.account_id)
}

// string key = 2;
inline bool GetAccountDetail::_internal_has_key() const {
  return opt_key_case() == kKey;
}
inline bool GetAccountDetail::has_key() const {
  return _internal_has_key();
}
inline void GetAccountDetail::set_has_key() {
  _impl_._oneof_case_[1] = kKey;
}
inline void GetAccountDetail::clear_key() {
  if (_internal_has_key()) {
    _impl_.opt_key_.key_.Destroy();
    clear_has_opt_key();
  }
}
inline const std::string& GetAccountDetail::key() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.GetAccountDetail.key)
  return _internal_key();
}
template <typename ArgT0, typename... ArgT>
inline void GetAccountDetail::set_key(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_key()) {
    clear_opt_key();
    set_has_key();
    _impl_.opt_key_.key_.InitDefault();
  }
  _impl_.opt_key_.key_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:iroha.protocol.GetAccountDetail.key)
}
inline std::string* GetAccountDetail::mutable_key() {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:iroha.protocol.GetAccountDetail.key)
  return _s;
}
inline const std::string& GetAccountDetail::_internal_key() const {
  if (_internal_has_key()) {
    return _impl_.opt_key_.key_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void GetAccountDetail::_internal_set_key(const std::string& value) {
  if (!_internal_has_key()) {
    clear_opt_key();
    set_has_key();
    _impl_.opt_key_.key_.InitDefault();
  }
  _impl_.opt_key_.key_.Set(value, GetArenaForAllocation());
}
inline std::string* GetAccountDetail::_internal_mutable_key() {
  if (!_internal_has_key()) {
    clear_opt_key();
    set_has_key();
    _impl_.opt_key_.key_.InitDefault();
  }
  return _impl_.opt_key_.key_.Mutable(      GetArenaForAllocation());
}
inline std::string* GetAccountDetail::release_key() {
  // @@protoc_insertion_point(field_release:iroha.protocol.GetAccountDetail.key)
  if (_internal_has_key()) {
    clear_has_opt_key();
    return _impl_.opt_key_.key_.Release();
  } else {
    return nullptr;
  }
}
inline void GetAccountDetail::set_allocated_key(std::string* key) {
  if (has_opt_key()) {
    clear_opt_key();
  }
  if (key != nullptr) {
    set_has_key();
    _impl_.opt_key_.key_.InitAllocated(key, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:iroha.protocol.GetAccountDetail.key)
}

// string writer = 3;
inline bool GetAccountDetail::_internal_has_writer() const {
  return opt_writer_case() == kWriter;
}
inline bool GetAccountDetail::has_writer() const {
  return _internal_has_writer();
}
inline void GetAccountDetail::set_has_writer() {
  _impl_._oneof_case_[2] = kWriter;
}
inline void GetAccountDetail::clear_writer() {
  if (_internal_has_writer()) {
    _impl_.opt_writer_.writer_.Destroy();
    clear_has_opt_writer();
  }
}
inline const std::string& GetAccountDetail::writer() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.GetAccountDetail.writer)
  return _internal_writer();
}
template <typename ArgT0, typename... ArgT>
inline void GetAccountDetail::set_writer(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_writer()) {
    clear_opt_writer();
    set_has_writer();
    _impl_.opt_writer_.writer_.InitDefault();
  }
  _impl_.opt_writer_.writer_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:iroha.protocol.GetAccountDetail.writer)
}
inline std::string* GetAccountDetail::mutable_writer() {
  std::string* _s = _internal_mutable_writer();
  // @@protoc_insertion_point(field_mutable:iroha.protocol.GetAccountDetail.writer)
  return _s;
}
inline const std::string& GetAccountDetail::_internal_writer() const {
  if (_internal_has_writer()) {
    return _impl_.opt_writer_.writer_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void GetAccountDetail::_internal_set_writer(const std::string& value) {
  if (!_internal_has_writer()) {
    clear_opt_writer();
    set_has_writer();
    _impl_.opt_writer_.writer_.InitDefault();
  }
  _impl_.opt_writer_.writer_.Set(value, GetArenaForAllocation());
}
inline std::string* GetAccountDetail::_internal_mutable_writer() {
  if (!_internal_has_writer()) {
    clear_opt_writer();
    set_has_writer();
    _impl_.opt_writer_.writer_.InitDefault();
  }
  return _impl_.opt_writer_.writer_.Mutable(      GetArenaForAllocation());
}
inline std::string* GetAccountDetail::release_writer() {
  // @@protoc_insertion_point(field_release:iroha.protocol.GetAccountDetail.writer)
  if (_internal_has_writer()) {
    clear_has_opt_writer();
    return _impl_.opt_writer_.writer_.Release();
  } else {
    return nullptr;
  }
}
inline void GetAccountDetail::set_allocated_writer(std::string* writer) {
  if (has_opt_writer()) {
    clear_opt_writer();
  }
  if (writer != nullptr) {
    set_has_writer();
    _impl_.opt_writer_.writer_.InitAllocated(writer, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:iroha.protocol.GetAccountDetail.writer)
}

// .iroha.protocol.AccountDetailPaginationMeta pagination_meta = 4;
inline bool GetAccountDetail::_internal_has_pagination_meta() const {
  return this != internal_default_instance() && _impl_.pagination_meta_ != nullptr;
}
inline bool GetAccountDetail::has_pagination_meta() const {
  return _internal_has_pagination_meta();
}
inline void GetAccountDetail::clear_pagination_meta() {
  if (GetArenaForAllocation() == nullptr && _impl_.pagination_meta_ != nullptr) {
    delete _impl_.pagination_meta_;
  }
  _impl_.pagination_meta_ = nullptr;
}
inline const ::iroha::protocol::AccountDetailPaginationMeta& GetAccountDetail::_internal_pagination_meta() const {
  const ::iroha::protocol::AccountDetailPaginationMeta* p = _impl_.pagination_meta_;
  return p != nullptr ? *p : reinterpret_cast<const ::iroha::protocol::AccountDetailPaginationMeta&>(
      ::iroha::protocol::_AccountDetailPaginationMeta_default_instance_);
}
inline const ::iroha::protocol::AccountDetailPaginationMeta& GetAccountDetail::pagination_meta() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.GetAccountDetail.pagination_meta)
  return _internal_pagination_meta();
}
inline void GetAccountDetail::unsafe_arena_set_allocated_pagination_meta(
    ::iroha::protocol::AccountDetailPaginationMeta* pagination_meta) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pagination_meta_);
  }
  _impl_.pagination_meta_ = pagination_meta;
  if (pagination_meta) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:iroha.protocol.GetAccountDetail.pagination_meta)
}
inline ::iroha::protocol::AccountDetailPaginationMeta* GetAccountDetail::release_pagination_meta() {
  
  ::iroha::protocol::AccountDetailPaginationMeta* temp = _impl_.pagination_meta_;
  _impl_.pagination_meta_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::iroha::protocol::AccountDetailPaginationMeta* GetAccountDetail::unsafe_arena_release_pagination_meta() {
  // @@protoc_insertion_point(field_release:iroha.protocol.GetAccountDetail.pagination_meta)
  
  ::iroha::protocol::AccountDetailPaginationMeta* temp = _impl_.pagination_meta_;
  _impl_.pagination_meta_ = nullptr;
  return temp;
}
inline ::iroha::protocol::AccountDetailPaginationMeta* GetAccountDetail::_internal_mutable_pagination_meta() {
  
  if (_impl_.pagination_meta_ == nullptr) {
    auto* p = CreateMaybeMessage<::iroha::protocol::AccountDetailPaginationMeta>(GetArenaForAllocation());
    _impl_.pagination_meta_ = p;
  }
  return _impl_.pagination_meta_;
}
inline ::iroha::protocol::AccountDetailPaginationMeta* GetAccountDetail::mutable_pagination_meta() {
  ::iroha::protocol::AccountDetailPaginationMeta* _msg = _internal_mutable_pagination_meta();
  // @@protoc_insertion_point(field_mutable:iroha.protocol.GetAccountDetail.pagination_meta)
  return _msg;
}
inline void GetAccountDetail::set_allocated_pagination_meta(::iroha::protocol::AccountDetailPaginationMeta* pagination_meta) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.pagination_meta_;
  }
  if (pagination_meta) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(pagination_meta);
    if (message_arena != submessage_arena) {
      pagination_meta = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pagination_meta, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.pagination_meta_ = pagination_meta;
  // @@protoc_insertion_point(field_set_allocated:iroha.protocol.GetAccountDetail.pagination_meta)
}

inline bool GetAccountDetail::has_opt_account_id() const {
  return opt_account_id_case() != OPT_ACCOUNT_ID_NOT_SET;
}
inline void GetAccountDetail::clear_has_opt_account_id() {
  _impl_._oneof_case_[0] = OPT_ACCOUNT_ID_NOT_SET;
}
inline bool GetAccountDetail::has_opt_key() const {
  return opt_key_case() != OPT_KEY_NOT_SET;
}
inline void GetAccountDetail::clear_has_opt_key() {
  _impl_._oneof_case_[1] = OPT_KEY_NOT_SET;
}
inline bool GetAccountDetail::has_opt_writer() const {
  return opt_writer_case() != OPT_WRITER_NOT_SET;
}
inline void GetAccountDetail::clear_has_opt_writer() {
  _impl_._oneof_case_[2] = OPT_WRITER_NOT_SET;
}
inline GetAccountDetail::OptAccountIdCase GetAccountDetail::opt_account_id_case() const {
  return GetAccountDetail::OptAccountIdCase(_impl_._oneof_case_[0]);
}
inline GetAccountDetail::OptKeyCase GetAccountDetail::opt_key_case() const {
  return GetAccountDetail::OptKeyCase(_impl_._oneof_case_[1]);
}
inline GetAccountDetail::OptWriterCase GetAccountDetail::opt_writer_case() const {
  return GetAccountDetail::OptWriterCase(_impl_._oneof_case_[2]);
}
// -------------------------------------------------------------------

// GetAssetInfo

// string asset_id = 1;
inline void GetAssetInfo::clear_asset_id() {
  _impl_.asset_id_.ClearToEmpty();
}
inline const std::string& GetAssetInfo::asset_id() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.GetAssetInfo.asset_id)
  return _internal_asset_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetAssetInfo::set_asset_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.asset_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:iroha.protocol.GetAssetInfo.asset_id)
}
inline std::string* GetAssetInfo::mutable_asset_id() {
  std::string* _s = _internal_mutable_asset_id();
  // @@protoc_insertion_point(field_mutable:iroha.protocol.GetAssetInfo.asset_id)
  return _s;
}
inline const std::string& GetAssetInfo::_internal_asset_id() const {
  return _impl_.asset_id_.Get();
}
inline void GetAssetInfo::_internal_set_asset_id(const std::string& value) {
  
  _impl_.asset_id_.Set(value, GetArenaForAllocation());
}
inline std::string* GetAssetInfo::_internal_mutable_asset_id() {
  
  return _impl_.asset_id_.Mutable(GetArenaForAllocation());
}
inline std::string* GetAssetInfo::release_asset_id() {
  // @@protoc_insertion_point(field_release:iroha.protocol.GetAssetInfo.asset_id)
  return _impl_.asset_id_.Release();
}
inline void GetAssetInfo::set_allocated_asset_id(std::string* asset_id) {
  if (asset_id != nullptr) {
    
  } else {
    
  }
  _impl_.asset_id_.SetAllocated(asset_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.asset_id_.IsDefault()) {
    _impl_.asset_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:iroha.protocol.GetAssetInfo.asset_id)
}

// -------------------------------------------------------------------

// GetRoles

// -------------------------------------------------------------------

// GetRolePermissions

// string role_id = 1;
inline void GetRolePermissions::clear_role_id() {
  _impl_.role_id_.ClearToEmpty();
}
inline const std::string& GetRolePermissions::role_id() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.GetRolePermissions.role_id)
  return _internal_role_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetRolePermissions::set_role_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.role_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:iroha.protocol.GetRolePermissions.role_id)
}
inline std::string* GetRolePermissions::mutable_role_id() {
  std::string* _s = _internal_mutable_role_id();
  // @@protoc_insertion_point(field_mutable:iroha.protocol.GetRolePermissions.role_id)
  return _s;
}
inline const std::string& GetRolePermissions::_internal_role_id() const {
  return _impl_.role_id_.Get();
}
inline void GetRolePermissions::_internal_set_role_id(const std::string& value) {
  
  _impl_.role_id_.Set(value, GetArenaForAllocation());
}
inline std::string* GetRolePermissions::_internal_mutable_role_id() {
  
  return _impl_.role_id_.Mutable(GetArenaForAllocation());
}
inline std::string* GetRolePermissions::release_role_id() {
  // @@protoc_insertion_point(field_release:iroha.protocol.GetRolePermissions.role_id)
  return _impl_.role_id_.Release();
}
inline void GetRolePermissions::set_allocated_role_id(std::string* role_id) {
  if (role_id != nullptr) {
    
  } else {
    
  }
  _impl_.role_id_.SetAllocated(role_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.role_id_.IsDefault()) {
    _impl_.role_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:iroha.protocol.GetRolePermissions.role_id)
}

// -------------------------------------------------------------------

// GetPendingTransactions

// .iroha.protocol.TxPaginationMeta pagination_meta = 1;
inline bool GetPendingTransactions::_internal_has_pagination_meta() const {
  return this != internal_default_instance() && _impl_.pagination_meta_ != nullptr;
}
inline bool GetPendingTransactions::has_pagination_meta() const {
  return _internal_has_pagination_meta();
}
inline void GetPendingTransactions::clear_pagination_meta() {
  if (GetArenaForAllocation() == nullptr && _impl_.pagination_meta_ != nullptr) {
    delete _impl_.pagination_meta_;
  }
  _impl_.pagination_meta_ = nullptr;
}
inline const ::iroha::protocol::TxPaginationMeta& GetPendingTransactions::_internal_pagination_meta() const {
  const ::iroha::protocol::TxPaginationMeta* p = _impl_.pagination_meta_;
  return p != nullptr ? *p : reinterpret_cast<const ::iroha::protocol::TxPaginationMeta&>(
      ::iroha::protocol::_TxPaginationMeta_default_instance_);
}
inline const ::iroha::protocol::TxPaginationMeta& GetPendingTransactions::pagination_meta() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.GetPendingTransactions.pagination_meta)
  return _internal_pagination_meta();
}
inline void GetPendingTransactions::unsafe_arena_set_allocated_pagination_meta(
    ::iroha::protocol::TxPaginationMeta* pagination_meta) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pagination_meta_);
  }
  _impl_.pagination_meta_ = pagination_meta;
  if (pagination_meta) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:iroha.protocol.GetPendingTransactions.pagination_meta)
}
inline ::iroha::protocol::TxPaginationMeta* GetPendingTransactions::release_pagination_meta() {
  
  ::iroha::protocol::TxPaginationMeta* temp = _impl_.pagination_meta_;
  _impl_.pagination_meta_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::iroha::protocol::TxPaginationMeta* GetPendingTransactions::unsafe_arena_release_pagination_meta() {
  // @@protoc_insertion_point(field_release:iroha.protocol.GetPendingTransactions.pagination_meta)
  
  ::iroha::protocol::TxPaginationMeta* temp = _impl_.pagination_meta_;
  _impl_.pagination_meta_ = nullptr;
  return temp;
}
inline ::iroha::protocol::TxPaginationMeta* GetPendingTransactions::_internal_mutable_pagination_meta() {
  
  if (_impl_.pagination_meta_ == nullptr) {
    auto* p = CreateMaybeMessage<::iroha::protocol::TxPaginationMeta>(GetArenaForAllocation());
    _impl_.pagination_meta_ = p;
  }
  return _impl_.pagination_meta_;
}
inline ::iroha::protocol::TxPaginationMeta* GetPendingTransactions::mutable_pagination_meta() {
  ::iroha::protocol::TxPaginationMeta* _msg = _internal_mutable_pagination_meta();
  // @@protoc_insertion_point(field_mutable:iroha.protocol.GetPendingTransactions.pagination_meta)
  return _msg;
}
inline void GetPendingTransactions::set_allocated_pagination_meta(::iroha::protocol::TxPaginationMeta* pagination_meta) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.pagination_meta_;
  }
  if (pagination_meta) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(pagination_meta);
    if (message_arena != submessage_arena) {
      pagination_meta = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pagination_meta, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.pagination_meta_ = pagination_meta;
  // @@protoc_insertion_point(field_set_allocated:iroha.protocol.GetPendingTransactions.pagination_meta)
}

// -------------------------------------------------------------------

// GetPeers

// -------------------------------------------------------------------

// QueryPayloadMeta

// uint64 created_time = 1;
inline void QueryPayloadMeta::clear_created_time() {
  _impl_.created_time_ = uint64_t{0u};
}
inline uint64_t QueryPayloadMeta::_internal_created_time() const {
  return _impl_.created_time_;
}
inline uint64_t QueryPayloadMeta::created_time() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.QueryPayloadMeta.created_time)
  return _internal_created_time();
}
inline void QueryPayloadMeta::_internal_set_created_time(uint64_t value) {
  
  _impl_.created_time_ = value;
}
inline void QueryPayloadMeta::set_created_time(uint64_t value) {
  _internal_set_created_time(value);
  // @@protoc_insertion_point(field_set:iroha.protocol.QueryPayloadMeta.created_time)
}

// string creator_account_id = 2;
inline void QueryPayloadMeta::clear_creator_account_id() {
  _impl_.creator_account_id_.ClearToEmpty();
}
inline const std::string& QueryPayloadMeta::creator_account_id() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.QueryPayloadMeta.creator_account_id)
  return _internal_creator_account_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void QueryPayloadMeta::set_creator_account_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.creator_account_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:iroha.protocol.QueryPayloadMeta.creator_account_id)
}
inline std::string* QueryPayloadMeta::mutable_creator_account_id() {
  std::string* _s = _internal_mutable_creator_account_id();
  // @@protoc_insertion_point(field_mutable:iroha.protocol.QueryPayloadMeta.creator_account_id)
  return _s;
}
inline const std::string& QueryPayloadMeta::_internal_creator_account_id() const {
  return _impl_.creator_account_id_.Get();
}
inline void QueryPayloadMeta::_internal_set_creator_account_id(const std::string& value) {
  
  _impl_.creator_account_id_.Set(value, GetArenaForAllocation());
}
inline std::string* QueryPayloadMeta::_internal_mutable_creator_account_id() {
  
  return _impl_.creator_account_id_.Mutable(GetArenaForAllocation());
}
inline std::string* QueryPayloadMeta::release_creator_account_id() {
  // @@protoc_insertion_point(field_release:iroha.protocol.QueryPayloadMeta.creator_account_id)
  return _impl_.creator_account_id_.Release();
}
inline void QueryPayloadMeta::set_allocated_creator_account_id(std::string* creator_account_id) {
  if (creator_account_id != nullptr) {
    
  } else {
    
  }
  _impl_.creator_account_id_.SetAllocated(creator_account_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.creator_account_id_.IsDefault()) {
    _impl_.creator_account_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:iroha.protocol.QueryPayloadMeta.creator_account_id)
}

// uint64 query_counter = 3;
inline void QueryPayloadMeta::clear_query_counter() {
  _impl_.query_counter_ = uint64_t{0u};
}
inline uint64_t QueryPayloadMeta::_internal_query_counter() const {
  return _impl_.query_counter_;
}
inline uint64_t QueryPayloadMeta::query_counter() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.QueryPayloadMeta.query_counter)
  return _internal_query_counter();
}
inline void QueryPayloadMeta::_internal_set_query_counter(uint64_t value) {
  
  _impl_.query_counter_ = value;
}
inline void QueryPayloadMeta::set_query_counter(uint64_t value) {
  _internal_set_query_counter(value);
  // @@protoc_insertion_point(field_set:iroha.protocol.QueryPayloadMeta.query_counter)
}

// -------------------------------------------------------------------

// GetEngineReceipts

// string tx_hash = 1;
inline void GetEngineReceipts::clear_tx_hash() {
  _impl_.tx_hash_.ClearToEmpty();
}
inline const std::string& GetEngineReceipts::tx_hash() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.GetEngineReceipts.tx_hash)
  return _internal_tx_hash();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetEngineReceipts::set_tx_hash(ArgT0&& arg0, ArgT... args) {
 
 _impl_.tx_hash_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:iroha.protocol.GetEngineReceipts.tx_hash)
}
inline std::string* GetEngineReceipts::mutable_tx_hash() {
  std::string* _s = _internal_mutable_tx_hash();
  // @@protoc_insertion_point(field_mutable:iroha.protocol.GetEngineReceipts.tx_hash)
  return _s;
}
inline const std::string& GetEngineReceipts::_internal_tx_hash() const {
  return _impl_.tx_hash_.Get();
}
inline void GetEngineReceipts::_internal_set_tx_hash(const std::string& value) {
  
  _impl_.tx_hash_.Set(value, GetArenaForAllocation());
}
inline std::string* GetEngineReceipts::_internal_mutable_tx_hash() {
  
  return _impl_.tx_hash_.Mutable(GetArenaForAllocation());
}
inline std::string* GetEngineReceipts::release_tx_hash() {
  // @@protoc_insertion_point(field_release:iroha.protocol.GetEngineReceipts.tx_hash)
  return _impl_.tx_hash_.Release();
}
inline void GetEngineReceipts::set_allocated_tx_hash(std::string* tx_hash) {
  if (tx_hash != nullptr) {
    
  } else {
    
  }
  _impl_.tx_hash_.SetAllocated(tx_hash, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.tx_hash_.IsDefault()) {
    _impl_.tx_hash_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:iroha.protocol.GetEngineReceipts.tx_hash)
}

// -------------------------------------------------------------------

// Query_Payload

// .iroha.protocol.QueryPayloadMeta meta = 1;
inline bool Query_Payload::_internal_has_meta() const {
  return this != internal_default_instance() && _impl_.meta_ != nullptr;
}
inline bool Query_Payload::has_meta() const {
  return _internal_has_meta();
}
inline void Query_Payload::clear_meta() {
  if (GetArenaForAllocation() == nullptr && _impl_.meta_ != nullptr) {
    delete _impl_.meta_;
  }
  _impl_.meta_ = nullptr;
}
inline const ::iroha::protocol::QueryPayloadMeta& Query_Payload::_internal_meta() const {
  const ::iroha::protocol::QueryPayloadMeta* p = _impl_.meta_;
  return p != nullptr ? *p : reinterpret_cast<const ::iroha::protocol::QueryPayloadMeta&>(
      ::iroha::protocol::_QueryPayloadMeta_default_instance_);
}
inline const ::iroha::protocol::QueryPayloadMeta& Query_Payload::meta() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.Query.Payload.meta)
  return _internal_meta();
}
inline void Query_Payload::unsafe_arena_set_allocated_meta(
    ::iroha::protocol::QueryPayloadMeta* meta) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.meta_);
  }
  _impl_.meta_ = meta;
  if (meta) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:iroha.protocol.Query.Payload.meta)
}
inline ::iroha::protocol::QueryPayloadMeta* Query_Payload::release_meta() {
  
  ::iroha::protocol::QueryPayloadMeta* temp = _impl_.meta_;
  _impl_.meta_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::iroha::protocol::QueryPayloadMeta* Query_Payload::unsafe_arena_release_meta() {
  // @@protoc_insertion_point(field_release:iroha.protocol.Query.Payload.meta)
  
  ::iroha::protocol::QueryPayloadMeta* temp = _impl_.meta_;
  _impl_.meta_ = nullptr;
  return temp;
}
inline ::iroha::protocol::QueryPayloadMeta* Query_Payload::_internal_mutable_meta() {
  
  if (_impl_.meta_ == nullptr) {
    auto* p = CreateMaybeMessage<::iroha::protocol::QueryPayloadMeta>(GetArenaForAllocation());
    _impl_.meta_ = p;
  }
  return _impl_.meta_;
}
inline ::iroha::protocol::QueryPayloadMeta* Query_Payload::mutable_meta() {
  ::iroha::protocol::QueryPayloadMeta* _msg = _internal_mutable_meta();
  // @@protoc_insertion_point(field_mutable:iroha.protocol.Query.Payload.meta)
  return _msg;
}
inline void Query_Payload::set_allocated_meta(::iroha::protocol::QueryPayloadMeta* meta) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.meta_;
  }
  if (meta) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(meta);
    if (message_arena != submessage_arena) {
      meta = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, meta, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.meta_ = meta;
  // @@protoc_insertion_point(field_set_allocated:iroha.protocol.Query.Payload.meta)
}

// .iroha.protocol.GetAccount get_account = 3;
inline bool Query_Payload::_internal_has_get_account() const {
  return query_case() == kGetAccount;
}
inline bool Query_Payload::has_get_account() const {
  return _internal_has_get_account();
}
inline void Query_Payload::set_has_get_account() {
  _impl_._oneof_case_[0] = kGetAccount;
}
inline void Query_Payload::clear_get_account() {
  if (_internal_has_get_account()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.query_.get_account_;
    }
    clear_has_query();
  }
}
inline ::iroha::protocol::GetAccount* Query_Payload::release_get_account() {
  // @@protoc_insertion_point(field_release:iroha.protocol.Query.Payload.get_account)
  if (_internal_has_get_account()) {
    clear_has_query();
    ::iroha::protocol::GetAccount* temp = _impl_.query_.get_account_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.query_.get_account_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::iroha::protocol::GetAccount& Query_Payload::_internal_get_account() const {
  return _internal_has_get_account()
      ? *_impl_.query_.get_account_
      : reinterpret_cast< ::iroha::protocol::GetAccount&>(::iroha::protocol::_GetAccount_default_instance_);
}
inline const ::iroha::protocol::GetAccount& Query_Payload::get_account() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.Query.Payload.get_account)
  return _internal_get_account();
}
inline ::iroha::protocol::GetAccount* Query_Payload::unsafe_arena_release_get_account() {
  // @@protoc_insertion_point(field_unsafe_arena_release:iroha.protocol.Query.Payload.get_account)
  if (_internal_has_get_account()) {
    clear_has_query();
    ::iroha::protocol::GetAccount* temp = _impl_.query_.get_account_;
    _impl_.query_.get_account_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Query_Payload::unsafe_arena_set_allocated_get_account(::iroha::protocol::GetAccount* get_account) {
  clear_query();
  if (get_account) {
    set_has_get_account();
    _impl_.query_.get_account_ = get_account;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:iroha.protocol.Query.Payload.get_account)
}
inline ::iroha::protocol::GetAccount* Query_Payload::_internal_mutable_get_account() {
  if (!_internal_has_get_account()) {
    clear_query();
    set_has_get_account();
    _impl_.query_.get_account_ = CreateMaybeMessage< ::iroha::protocol::GetAccount >(GetArenaForAllocation());
  }
  return _impl_.query_.get_account_;
}
inline ::iroha::protocol::GetAccount* Query_Payload::mutable_get_account() {
  ::iroha::protocol::GetAccount* _msg = _internal_mutable_get_account();
  // @@protoc_insertion_point(field_mutable:iroha.protocol.Query.Payload.get_account)
  return _msg;
}

// .iroha.protocol.GetSignatories get_signatories = 4;
inline bool Query_Payload::_internal_has_get_signatories() const {
  return query_case() == kGetSignatories;
}
inline bool Query_Payload::has_get_signatories() const {
  return _internal_has_get_signatories();
}
inline void Query_Payload::set_has_get_signatories() {
  _impl_._oneof_case_[0] = kGetSignatories;
}
inline void Query_Payload::clear_get_signatories() {
  if (_internal_has_get_signatories()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.query_.get_signatories_;
    }
    clear_has_query();
  }
}
inline ::iroha::protocol::GetSignatories* Query_Payload::release_get_signatories() {
  // @@protoc_insertion_point(field_release:iroha.protocol.Query.Payload.get_signatories)
  if (_internal_has_get_signatories()) {
    clear_has_query();
    ::iroha::protocol::GetSignatories* temp = _impl_.query_.get_signatories_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.query_.get_signatories_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::iroha::protocol::GetSignatories& Query_Payload::_internal_get_signatories() const {
  return _internal_has_get_signatories()
      ? *_impl_.query_.get_signatories_
      : reinterpret_cast< ::iroha::protocol::GetSignatories&>(::iroha::protocol::_GetSignatories_default_instance_);
}
inline const ::iroha::protocol::GetSignatories& Query_Payload::get_signatories() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.Query.Payload.get_signatories)
  return _internal_get_signatories();
}
inline ::iroha::protocol::GetSignatories* Query_Payload::unsafe_arena_release_get_signatories() {
  // @@protoc_insertion_point(field_unsafe_arena_release:iroha.protocol.Query.Payload.get_signatories)
  if (_internal_has_get_signatories()) {
    clear_has_query();
    ::iroha::protocol::GetSignatories* temp = _impl_.query_.get_signatories_;
    _impl_.query_.get_signatories_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Query_Payload::unsafe_arena_set_allocated_get_signatories(::iroha::protocol::GetSignatories* get_signatories) {
  clear_query();
  if (get_signatories) {
    set_has_get_signatories();
    _impl_.query_.get_signatories_ = get_signatories;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:iroha.protocol.Query.Payload.get_signatories)
}
inline ::iroha::protocol::GetSignatories* Query_Payload::_internal_mutable_get_signatories() {
  if (!_internal_has_get_signatories()) {
    clear_query();
    set_has_get_signatories();
    _impl_.query_.get_signatories_ = CreateMaybeMessage< ::iroha::protocol::GetSignatories >(GetArenaForAllocation());
  }
  return _impl_.query_.get_signatories_;
}
inline ::iroha::protocol::GetSignatories* Query_Payload::mutable_get_signatories() {
  ::iroha::protocol::GetSignatories* _msg = _internal_mutable_get_signatories();
  // @@protoc_insertion_point(field_mutable:iroha.protocol.Query.Payload.get_signatories)
  return _msg;
}

// .iroha.protocol.GetAccountTransactions get_account_transactions = 5;
inline bool Query_Payload::_internal_has_get_account_transactions() const {
  return query_case() == kGetAccountTransactions;
}
inline bool Query_Payload::has_get_account_transactions() const {
  return _internal_has_get_account_transactions();
}
inline void Query_Payload::set_has_get_account_transactions() {
  _impl_._oneof_case_[0] = kGetAccountTransactions;
}
inline void Query_Payload::clear_get_account_transactions() {
  if (_internal_has_get_account_transactions()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.query_.get_account_transactions_;
    }
    clear_has_query();
  }
}
inline ::iroha::protocol::GetAccountTransactions* Query_Payload::release_get_account_transactions() {
  // @@protoc_insertion_point(field_release:iroha.protocol.Query.Payload.get_account_transactions)
  if (_internal_has_get_account_transactions()) {
    clear_has_query();
    ::iroha::protocol::GetAccountTransactions* temp = _impl_.query_.get_account_transactions_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.query_.get_account_transactions_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::iroha::protocol::GetAccountTransactions& Query_Payload::_internal_get_account_transactions() const {
  return _internal_has_get_account_transactions()
      ? *_impl_.query_.get_account_transactions_
      : reinterpret_cast< ::iroha::protocol::GetAccountTransactions&>(::iroha::protocol::_GetAccountTransactions_default_instance_);
}
inline const ::iroha::protocol::GetAccountTransactions& Query_Payload::get_account_transactions() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.Query.Payload.get_account_transactions)
  return _internal_get_account_transactions();
}
inline ::iroha::protocol::GetAccountTransactions* Query_Payload::unsafe_arena_release_get_account_transactions() {
  // @@protoc_insertion_point(field_unsafe_arena_release:iroha.protocol.Query.Payload.get_account_transactions)
  if (_internal_has_get_account_transactions()) {
    clear_has_query();
    ::iroha::protocol::GetAccountTransactions* temp = _impl_.query_.get_account_transactions_;
    _impl_.query_.get_account_transactions_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Query_Payload::unsafe_arena_set_allocated_get_account_transactions(::iroha::protocol::GetAccountTransactions* get_account_transactions) {
  clear_query();
  if (get_account_transactions) {
    set_has_get_account_transactions();
    _impl_.query_.get_account_transactions_ = get_account_transactions;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:iroha.protocol.Query.Payload.get_account_transactions)
}
inline ::iroha::protocol::GetAccountTransactions* Query_Payload::_internal_mutable_get_account_transactions() {
  if (!_internal_has_get_account_transactions()) {
    clear_query();
    set_has_get_account_transactions();
    _impl_.query_.get_account_transactions_ = CreateMaybeMessage< ::iroha::protocol::GetAccountTransactions >(GetArenaForAllocation());
  }
  return _impl_.query_.get_account_transactions_;
}
inline ::iroha::protocol::GetAccountTransactions* Query_Payload::mutable_get_account_transactions() {
  ::iroha::protocol::GetAccountTransactions* _msg = _internal_mutable_get_account_transactions();
  // @@protoc_insertion_point(field_mutable:iroha.protocol.Query.Payload.get_account_transactions)
  return _msg;
}

// .iroha.protocol.GetAccountAssetTransactions get_account_asset_transactions = 6;
inline bool Query_Payload::_internal_has_get_account_asset_transactions() const {
  return query_case() == kGetAccountAssetTransactions;
}
inline bool Query_Payload::has_get_account_asset_transactions() const {
  return _internal_has_get_account_asset_transactions();
}
inline void Query_Payload::set_has_get_account_asset_transactions() {
  _impl_._oneof_case_[0] = kGetAccountAssetTransactions;
}
inline void Query_Payload::clear_get_account_asset_transactions() {
  if (_internal_has_get_account_asset_transactions()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.query_.get_account_asset_transactions_;
    }
    clear_has_query();
  }
}
inline ::iroha::protocol::GetAccountAssetTransactions* Query_Payload::release_get_account_asset_transactions() {
  // @@protoc_insertion_point(field_release:iroha.protocol.Query.Payload.get_account_asset_transactions)
  if (_internal_has_get_account_asset_transactions()) {
    clear_has_query();
    ::iroha::protocol::GetAccountAssetTransactions* temp = _impl_.query_.get_account_asset_transactions_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.query_.get_account_asset_transactions_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::iroha::protocol::GetAccountAssetTransactions& Query_Payload::_internal_get_account_asset_transactions() const {
  return _internal_has_get_account_asset_transactions()
      ? *_impl_.query_.get_account_asset_transactions_
      : reinterpret_cast< ::iroha::protocol::GetAccountAssetTransactions&>(::iroha::protocol::_GetAccountAssetTransactions_default_instance_);
}
inline const ::iroha::protocol::GetAccountAssetTransactions& Query_Payload::get_account_asset_transactions() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.Query.Payload.get_account_asset_transactions)
  return _internal_get_account_asset_transactions();
}
inline ::iroha::protocol::GetAccountAssetTransactions* Query_Payload::unsafe_arena_release_get_account_asset_transactions() {
  // @@protoc_insertion_point(field_unsafe_arena_release:iroha.protocol.Query.Payload.get_account_asset_transactions)
  if (_internal_has_get_account_asset_transactions()) {
    clear_has_query();
    ::iroha::protocol::GetAccountAssetTransactions* temp = _impl_.query_.get_account_asset_transactions_;
    _impl_.query_.get_account_asset_transactions_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Query_Payload::unsafe_arena_set_allocated_get_account_asset_transactions(::iroha::protocol::GetAccountAssetTransactions* get_account_asset_transactions) {
  clear_query();
  if (get_account_asset_transactions) {
    set_has_get_account_asset_transactions();
    _impl_.query_.get_account_asset_transactions_ = get_account_asset_transactions;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:iroha.protocol.Query.Payload.get_account_asset_transactions)
}
inline ::iroha::protocol::GetAccountAssetTransactions* Query_Payload::_internal_mutable_get_account_asset_transactions() {
  if (!_internal_has_get_account_asset_transactions()) {
    clear_query();
    set_has_get_account_asset_transactions();
    _impl_.query_.get_account_asset_transactions_ = CreateMaybeMessage< ::iroha::protocol::GetAccountAssetTransactions >(GetArenaForAllocation());
  }
  return _impl_.query_.get_account_asset_transactions_;
}
inline ::iroha::protocol::GetAccountAssetTransactions* Query_Payload::mutable_get_account_asset_transactions() {
  ::iroha::protocol::GetAccountAssetTransactions* _msg = _internal_mutable_get_account_asset_transactions();
  // @@protoc_insertion_point(field_mutable:iroha.protocol.Query.Payload.get_account_asset_transactions)
  return _msg;
}

// .iroha.protocol.GetTransactions get_transactions = 7;
inline bool Query_Payload::_internal_has_get_transactions() const {
  return query_case() == kGetTransactions;
}
inline bool Query_Payload::has_get_transactions() const {
  return _internal_has_get_transactions();
}
inline void Query_Payload::set_has_get_transactions() {
  _impl_._oneof_case_[0] = kGetTransactions;
}
inline void Query_Payload::clear_get_transactions() {
  if (_internal_has_get_transactions()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.query_.get_transactions_;
    }
    clear_has_query();
  }
}
inline ::iroha::protocol::GetTransactions* Query_Payload::release_get_transactions() {
  // @@protoc_insertion_point(field_release:iroha.protocol.Query.Payload.get_transactions)
  if (_internal_has_get_transactions()) {
    clear_has_query();
    ::iroha::protocol::GetTransactions* temp = _impl_.query_.get_transactions_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.query_.get_transactions_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::iroha::protocol::GetTransactions& Query_Payload::_internal_get_transactions() const {
  return _internal_has_get_transactions()
      ? *_impl_.query_.get_transactions_
      : reinterpret_cast< ::iroha::protocol::GetTransactions&>(::iroha::protocol::_GetTransactions_default_instance_);
}
inline const ::iroha::protocol::GetTransactions& Query_Payload::get_transactions() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.Query.Payload.get_transactions)
  return _internal_get_transactions();
}
inline ::iroha::protocol::GetTransactions* Query_Payload::unsafe_arena_release_get_transactions() {
  // @@protoc_insertion_point(field_unsafe_arena_release:iroha.protocol.Query.Payload.get_transactions)
  if (_internal_has_get_transactions()) {
    clear_has_query();
    ::iroha::protocol::GetTransactions* temp = _impl_.query_.get_transactions_;
    _impl_.query_.get_transactions_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Query_Payload::unsafe_arena_set_allocated_get_transactions(::iroha::protocol::GetTransactions* get_transactions) {
  clear_query();
  if (get_transactions) {
    set_has_get_transactions();
    _impl_.query_.get_transactions_ = get_transactions;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:iroha.protocol.Query.Payload.get_transactions)
}
inline ::iroha::protocol::GetTransactions* Query_Payload::_internal_mutable_get_transactions() {
  if (!_internal_has_get_transactions()) {
    clear_query();
    set_has_get_transactions();
    _impl_.query_.get_transactions_ = CreateMaybeMessage< ::iroha::protocol::GetTransactions >(GetArenaForAllocation());
  }
  return _impl_.query_.get_transactions_;
}
inline ::iroha::protocol::GetTransactions* Query_Payload::mutable_get_transactions() {
  ::iroha::protocol::GetTransactions* _msg = _internal_mutable_get_transactions();
  // @@protoc_insertion_point(field_mutable:iroha.protocol.Query.Payload.get_transactions)
  return _msg;
}

// .iroha.protocol.GetAccountAssets get_account_assets = 8;
inline bool Query_Payload::_internal_has_get_account_assets() const {
  return query_case() == kGetAccountAssets;
}
inline bool Query_Payload::has_get_account_assets() const {
  return _internal_has_get_account_assets();
}
inline void Query_Payload::set_has_get_account_assets() {
  _impl_._oneof_case_[0] = kGetAccountAssets;
}
inline void Query_Payload::clear_get_account_assets() {
  if (_internal_has_get_account_assets()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.query_.get_account_assets_;
    }
    clear_has_query();
  }
}
inline ::iroha::protocol::GetAccountAssets* Query_Payload::release_get_account_assets() {
  // @@protoc_insertion_point(field_release:iroha.protocol.Query.Payload.get_account_assets)
  if (_internal_has_get_account_assets()) {
    clear_has_query();
    ::iroha::protocol::GetAccountAssets* temp = _impl_.query_.get_account_assets_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.query_.get_account_assets_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::iroha::protocol::GetAccountAssets& Query_Payload::_internal_get_account_assets() const {
  return _internal_has_get_account_assets()
      ? *_impl_.query_.get_account_assets_
      : reinterpret_cast< ::iroha::protocol::GetAccountAssets&>(::iroha::protocol::_GetAccountAssets_default_instance_);
}
inline const ::iroha::protocol::GetAccountAssets& Query_Payload::get_account_assets() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.Query.Payload.get_account_assets)
  return _internal_get_account_assets();
}
inline ::iroha::protocol::GetAccountAssets* Query_Payload::unsafe_arena_release_get_account_assets() {
  // @@protoc_insertion_point(field_unsafe_arena_release:iroha.protocol.Query.Payload.get_account_assets)
  if (_internal_has_get_account_assets()) {
    clear_has_query();
    ::iroha::protocol::GetAccountAssets* temp = _impl_.query_.get_account_assets_;
    _impl_.query_.get_account_assets_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Query_Payload::unsafe_arena_set_allocated_get_account_assets(::iroha::protocol::GetAccountAssets* get_account_assets) {
  clear_query();
  if (get_account_assets) {
    set_has_get_account_assets();
    _impl_.query_.get_account_assets_ = get_account_assets;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:iroha.protocol.Query.Payload.get_account_assets)
}
inline ::iroha::protocol::GetAccountAssets* Query_Payload::_internal_mutable_get_account_assets() {
  if (!_internal_has_get_account_assets()) {
    clear_query();
    set_has_get_account_assets();
    _impl_.query_.get_account_assets_ = CreateMaybeMessage< ::iroha::protocol::GetAccountAssets >(GetArenaForAllocation());
  }
  return _impl_.query_.get_account_assets_;
}
inline ::iroha::protocol::GetAccountAssets* Query_Payload::mutable_get_account_assets() {
  ::iroha::protocol::GetAccountAssets* _msg = _internal_mutable_get_account_assets();
  // @@protoc_insertion_point(field_mutable:iroha.protocol.Query.Payload.get_account_assets)
  return _msg;
}

// .iroha.protocol.GetAccountDetail get_account_detail = 9;
inline bool Query_Payload::_internal_has_get_account_detail() const {
  return query_case() == kGetAccountDetail;
}
inline bool Query_Payload::has_get_account_detail() const {
  return _internal_has_get_account_detail();
}
inline void Query_Payload::set_has_get_account_detail() {
  _impl_._oneof_case_[0] = kGetAccountDetail;
}
inline void Query_Payload::clear_get_account_detail() {
  if (_internal_has_get_account_detail()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.query_.get_account_detail_;
    }
    clear_has_query();
  }
}
inline ::iroha::protocol::GetAccountDetail* Query_Payload::release_get_account_detail() {
  // @@protoc_insertion_point(field_release:iroha.protocol.Query.Payload.get_account_detail)
  if (_internal_has_get_account_detail()) {
    clear_has_query();
    ::iroha::protocol::GetAccountDetail* temp = _impl_.query_.get_account_detail_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.query_.get_account_detail_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::iroha::protocol::GetAccountDetail& Query_Payload::_internal_get_account_detail() const {
  return _internal_has_get_account_detail()
      ? *_impl_.query_.get_account_detail_
      : reinterpret_cast< ::iroha::protocol::GetAccountDetail&>(::iroha::protocol::_GetAccountDetail_default_instance_);
}
inline const ::iroha::protocol::GetAccountDetail& Query_Payload::get_account_detail() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.Query.Payload.get_account_detail)
  return _internal_get_account_detail();
}
inline ::iroha::protocol::GetAccountDetail* Query_Payload::unsafe_arena_release_get_account_detail() {
  // @@protoc_insertion_point(field_unsafe_arena_release:iroha.protocol.Query.Payload.get_account_detail)
  if (_internal_has_get_account_detail()) {
    clear_has_query();
    ::iroha::protocol::GetAccountDetail* temp = _impl_.query_.get_account_detail_;
    _impl_.query_.get_account_detail_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Query_Payload::unsafe_arena_set_allocated_get_account_detail(::iroha::protocol::GetAccountDetail* get_account_detail) {
  clear_query();
  if (get_account_detail) {
    set_has_get_account_detail();
    _impl_.query_.get_account_detail_ = get_account_detail;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:iroha.protocol.Query.Payload.get_account_detail)
}
inline ::iroha::protocol::GetAccountDetail* Query_Payload::_internal_mutable_get_account_detail() {
  if (!_internal_has_get_account_detail()) {
    clear_query();
    set_has_get_account_detail();
    _impl_.query_.get_account_detail_ = CreateMaybeMessage< ::iroha::protocol::GetAccountDetail >(GetArenaForAllocation());
  }
  return _impl_.query_.get_account_detail_;
}
inline ::iroha::protocol::GetAccountDetail* Query_Payload::mutable_get_account_detail() {
  ::iroha::protocol::GetAccountDetail* _msg = _internal_mutable_get_account_detail();
  // @@protoc_insertion_point(field_mutable:iroha.protocol.Query.Payload.get_account_detail)
  return _msg;
}

// .iroha.protocol.GetRoles get_roles = 10;
inline bool Query_Payload::_internal_has_get_roles() const {
  return query_case() == kGetRoles;
}
inline bool Query_Payload::has_get_roles() const {
  return _internal_has_get_roles();
}
inline void Query_Payload::set_has_get_roles() {
  _impl_._oneof_case_[0] = kGetRoles;
}
inline void Query_Payload::clear_get_roles() {
  if (_internal_has_get_roles()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.query_.get_roles_;
    }
    clear_has_query();
  }
}
inline ::iroha::protocol::GetRoles* Query_Payload::release_get_roles() {
  // @@protoc_insertion_point(field_release:iroha.protocol.Query.Payload.get_roles)
  if (_internal_has_get_roles()) {
    clear_has_query();
    ::iroha::protocol::GetRoles* temp = _impl_.query_.get_roles_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.query_.get_roles_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::iroha::protocol::GetRoles& Query_Payload::_internal_get_roles() const {
  return _internal_has_get_roles()
      ? *_impl_.query_.get_roles_
      : reinterpret_cast< ::iroha::protocol::GetRoles&>(::iroha::protocol::_GetRoles_default_instance_);
}
inline const ::iroha::protocol::GetRoles& Query_Payload::get_roles() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.Query.Payload.get_roles)
  return _internal_get_roles();
}
inline ::iroha::protocol::GetRoles* Query_Payload::unsafe_arena_release_get_roles() {
  // @@protoc_insertion_point(field_unsafe_arena_release:iroha.protocol.Query.Payload.get_roles)
  if (_internal_has_get_roles()) {
    clear_has_query();
    ::iroha::protocol::GetRoles* temp = _impl_.query_.get_roles_;
    _impl_.query_.get_roles_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Query_Payload::unsafe_arena_set_allocated_get_roles(::iroha::protocol::GetRoles* get_roles) {
  clear_query();
  if (get_roles) {
    set_has_get_roles();
    _impl_.query_.get_roles_ = get_roles;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:iroha.protocol.Query.Payload.get_roles)
}
inline ::iroha::protocol::GetRoles* Query_Payload::_internal_mutable_get_roles() {
  if (!_internal_has_get_roles()) {
    clear_query();
    set_has_get_roles();
    _impl_.query_.get_roles_ = CreateMaybeMessage< ::iroha::protocol::GetRoles >(GetArenaForAllocation());
  }
  return _impl_.query_.get_roles_;
}
inline ::iroha::protocol::GetRoles* Query_Payload::mutable_get_roles() {
  ::iroha::protocol::GetRoles* _msg = _internal_mutable_get_roles();
  // @@protoc_insertion_point(field_mutable:iroha.protocol.Query.Payload.get_roles)
  return _msg;
}

// .iroha.protocol.GetRolePermissions get_role_permissions = 11;
inline bool Query_Payload::_internal_has_get_role_permissions() const {
  return query_case() == kGetRolePermissions;
}
inline bool Query_Payload::has_get_role_permissions() const {
  return _internal_has_get_role_permissions();
}
inline void Query_Payload::set_has_get_role_permissions() {
  _impl_._oneof_case_[0] = kGetRolePermissions;
}
inline void Query_Payload::clear_get_role_permissions() {
  if (_internal_has_get_role_permissions()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.query_.get_role_permissions_;
    }
    clear_has_query();
  }
}
inline ::iroha::protocol::GetRolePermissions* Query_Payload::release_get_role_permissions() {
  // @@protoc_insertion_point(field_release:iroha.protocol.Query.Payload.get_role_permissions)
  if (_internal_has_get_role_permissions()) {
    clear_has_query();
    ::iroha::protocol::GetRolePermissions* temp = _impl_.query_.get_role_permissions_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.query_.get_role_permissions_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::iroha::protocol::GetRolePermissions& Query_Payload::_internal_get_role_permissions() const {
  return _internal_has_get_role_permissions()
      ? *_impl_.query_.get_role_permissions_
      : reinterpret_cast< ::iroha::protocol::GetRolePermissions&>(::iroha::protocol::_GetRolePermissions_default_instance_);
}
inline const ::iroha::protocol::GetRolePermissions& Query_Payload::get_role_permissions() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.Query.Payload.get_role_permissions)
  return _internal_get_role_permissions();
}
inline ::iroha::protocol::GetRolePermissions* Query_Payload::unsafe_arena_release_get_role_permissions() {
  // @@protoc_insertion_point(field_unsafe_arena_release:iroha.protocol.Query.Payload.get_role_permissions)
  if (_internal_has_get_role_permissions()) {
    clear_has_query();
    ::iroha::protocol::GetRolePermissions* temp = _impl_.query_.get_role_permissions_;
    _impl_.query_.get_role_permissions_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Query_Payload::unsafe_arena_set_allocated_get_role_permissions(::iroha::protocol::GetRolePermissions* get_role_permissions) {
  clear_query();
  if (get_role_permissions) {
    set_has_get_role_permissions();
    _impl_.query_.get_role_permissions_ = get_role_permissions;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:iroha.protocol.Query.Payload.get_role_permissions)
}
inline ::iroha::protocol::GetRolePermissions* Query_Payload::_internal_mutable_get_role_permissions() {
  if (!_internal_has_get_role_permissions()) {
    clear_query();
    set_has_get_role_permissions();
    _impl_.query_.get_role_permissions_ = CreateMaybeMessage< ::iroha::protocol::GetRolePermissions >(GetArenaForAllocation());
  }
  return _impl_.query_.get_role_permissions_;
}
inline ::iroha::protocol::GetRolePermissions* Query_Payload::mutable_get_role_permissions() {
  ::iroha::protocol::GetRolePermissions* _msg = _internal_mutable_get_role_permissions();
  // @@protoc_insertion_point(field_mutable:iroha.protocol.Query.Payload.get_role_permissions)
  return _msg;
}

// .iroha.protocol.GetAssetInfo get_asset_info = 12;
inline bool Query_Payload::_internal_has_get_asset_info() const {
  return query_case() == kGetAssetInfo;
}
inline bool Query_Payload::has_get_asset_info() const {
  return _internal_has_get_asset_info();
}
inline void Query_Payload::set_has_get_asset_info() {
  _impl_._oneof_case_[0] = kGetAssetInfo;
}
inline void Query_Payload::clear_get_asset_info() {
  if (_internal_has_get_asset_info()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.query_.get_asset_info_;
    }
    clear_has_query();
  }
}
inline ::iroha::protocol::GetAssetInfo* Query_Payload::release_get_asset_info() {
  // @@protoc_insertion_point(field_release:iroha.protocol.Query.Payload.get_asset_info)
  if (_internal_has_get_asset_info()) {
    clear_has_query();
    ::iroha::protocol::GetAssetInfo* temp = _impl_.query_.get_asset_info_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.query_.get_asset_info_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::iroha::protocol::GetAssetInfo& Query_Payload::_internal_get_asset_info() const {
  return _internal_has_get_asset_info()
      ? *_impl_.query_.get_asset_info_
      : reinterpret_cast< ::iroha::protocol::GetAssetInfo&>(::iroha::protocol::_GetAssetInfo_default_instance_);
}
inline const ::iroha::protocol::GetAssetInfo& Query_Payload::get_asset_info() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.Query.Payload.get_asset_info)
  return _internal_get_asset_info();
}
inline ::iroha::protocol::GetAssetInfo* Query_Payload::unsafe_arena_release_get_asset_info() {
  // @@protoc_insertion_point(field_unsafe_arena_release:iroha.protocol.Query.Payload.get_asset_info)
  if (_internal_has_get_asset_info()) {
    clear_has_query();
    ::iroha::protocol::GetAssetInfo* temp = _impl_.query_.get_asset_info_;
    _impl_.query_.get_asset_info_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Query_Payload::unsafe_arena_set_allocated_get_asset_info(::iroha::protocol::GetAssetInfo* get_asset_info) {
  clear_query();
  if (get_asset_info) {
    set_has_get_asset_info();
    _impl_.query_.get_asset_info_ = get_asset_info;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:iroha.protocol.Query.Payload.get_asset_info)
}
inline ::iroha::protocol::GetAssetInfo* Query_Payload::_internal_mutable_get_asset_info() {
  if (!_internal_has_get_asset_info()) {
    clear_query();
    set_has_get_asset_info();
    _impl_.query_.get_asset_info_ = CreateMaybeMessage< ::iroha::protocol::GetAssetInfo >(GetArenaForAllocation());
  }
  return _impl_.query_.get_asset_info_;
}
inline ::iroha::protocol::GetAssetInfo* Query_Payload::mutable_get_asset_info() {
  ::iroha::protocol::GetAssetInfo* _msg = _internal_mutable_get_asset_info();
  // @@protoc_insertion_point(field_mutable:iroha.protocol.Query.Payload.get_asset_info)
  return _msg;
}

// .iroha.protocol.GetPendingTransactions get_pending_transactions = 13;
inline bool Query_Payload::_internal_has_get_pending_transactions() const {
  return query_case() == kGetPendingTransactions;
}
inline bool Query_Payload::has_get_pending_transactions() const {
  return _internal_has_get_pending_transactions();
}
inline void Query_Payload::set_has_get_pending_transactions() {
  _impl_._oneof_case_[0] = kGetPendingTransactions;
}
inline void Query_Payload::clear_get_pending_transactions() {
  if (_internal_has_get_pending_transactions()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.query_.get_pending_transactions_;
    }
    clear_has_query();
  }
}
inline ::iroha::protocol::GetPendingTransactions* Query_Payload::release_get_pending_transactions() {
  // @@protoc_insertion_point(field_release:iroha.protocol.Query.Payload.get_pending_transactions)
  if (_internal_has_get_pending_transactions()) {
    clear_has_query();
    ::iroha::protocol::GetPendingTransactions* temp = _impl_.query_.get_pending_transactions_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.query_.get_pending_transactions_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::iroha::protocol::GetPendingTransactions& Query_Payload::_internal_get_pending_transactions() const {
  return _internal_has_get_pending_transactions()
      ? *_impl_.query_.get_pending_transactions_
      : reinterpret_cast< ::iroha::protocol::GetPendingTransactions&>(::iroha::protocol::_GetPendingTransactions_default_instance_);
}
inline const ::iroha::protocol::GetPendingTransactions& Query_Payload::get_pending_transactions() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.Query.Payload.get_pending_transactions)
  return _internal_get_pending_transactions();
}
inline ::iroha::protocol::GetPendingTransactions* Query_Payload::unsafe_arena_release_get_pending_transactions() {
  // @@protoc_insertion_point(field_unsafe_arena_release:iroha.protocol.Query.Payload.get_pending_transactions)
  if (_internal_has_get_pending_transactions()) {
    clear_has_query();
    ::iroha::protocol::GetPendingTransactions* temp = _impl_.query_.get_pending_transactions_;
    _impl_.query_.get_pending_transactions_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Query_Payload::unsafe_arena_set_allocated_get_pending_transactions(::iroha::protocol::GetPendingTransactions* get_pending_transactions) {
  clear_query();
  if (get_pending_transactions) {
    set_has_get_pending_transactions();
    _impl_.query_.get_pending_transactions_ = get_pending_transactions;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:iroha.protocol.Query.Payload.get_pending_transactions)
}
inline ::iroha::protocol::GetPendingTransactions* Query_Payload::_internal_mutable_get_pending_transactions() {
  if (!_internal_has_get_pending_transactions()) {
    clear_query();
    set_has_get_pending_transactions();
    _impl_.query_.get_pending_transactions_ = CreateMaybeMessage< ::iroha::protocol::GetPendingTransactions >(GetArenaForAllocation());
  }
  return _impl_.query_.get_pending_transactions_;
}
inline ::iroha::protocol::GetPendingTransactions* Query_Payload::mutable_get_pending_transactions() {
  ::iroha::protocol::GetPendingTransactions* _msg = _internal_mutable_get_pending_transactions();
  // @@protoc_insertion_point(field_mutable:iroha.protocol.Query.Payload.get_pending_transactions)
  return _msg;
}

// .iroha.protocol.GetBlock get_block = 14;
inline bool Query_Payload::_internal_has_get_block() const {
  return query_case() == kGetBlock;
}
inline bool Query_Payload::has_get_block() const {
  return _internal_has_get_block();
}
inline void Query_Payload::set_has_get_block() {
  _impl_._oneof_case_[0] = kGetBlock;
}
inline void Query_Payload::clear_get_block() {
  if (_internal_has_get_block()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.query_.get_block_;
    }
    clear_has_query();
  }
}
inline ::iroha::protocol::GetBlock* Query_Payload::release_get_block() {
  // @@protoc_insertion_point(field_release:iroha.protocol.Query.Payload.get_block)
  if (_internal_has_get_block()) {
    clear_has_query();
    ::iroha::protocol::GetBlock* temp = _impl_.query_.get_block_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.query_.get_block_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::iroha::protocol::GetBlock& Query_Payload::_internal_get_block() const {
  return _internal_has_get_block()
      ? *_impl_.query_.get_block_
      : reinterpret_cast< ::iroha::protocol::GetBlock&>(::iroha::protocol::_GetBlock_default_instance_);
}
inline const ::iroha::protocol::GetBlock& Query_Payload::get_block() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.Query.Payload.get_block)
  return _internal_get_block();
}
inline ::iroha::protocol::GetBlock* Query_Payload::unsafe_arena_release_get_block() {
  // @@protoc_insertion_point(field_unsafe_arena_release:iroha.protocol.Query.Payload.get_block)
  if (_internal_has_get_block()) {
    clear_has_query();
    ::iroha::protocol::GetBlock* temp = _impl_.query_.get_block_;
    _impl_.query_.get_block_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Query_Payload::unsafe_arena_set_allocated_get_block(::iroha::protocol::GetBlock* get_block) {
  clear_query();
  if (get_block) {
    set_has_get_block();
    _impl_.query_.get_block_ = get_block;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:iroha.protocol.Query.Payload.get_block)
}
inline ::iroha::protocol::GetBlock* Query_Payload::_internal_mutable_get_block() {
  if (!_internal_has_get_block()) {
    clear_query();
    set_has_get_block();
    _impl_.query_.get_block_ = CreateMaybeMessage< ::iroha::protocol::GetBlock >(GetArenaForAllocation());
  }
  return _impl_.query_.get_block_;
}
inline ::iroha::protocol::GetBlock* Query_Payload::mutable_get_block() {
  ::iroha::protocol::GetBlock* _msg = _internal_mutable_get_block();
  // @@protoc_insertion_point(field_mutable:iroha.protocol.Query.Payload.get_block)
  return _msg;
}

// .iroha.protocol.GetPeers get_peers = 15;
inline bool Query_Payload::_internal_has_get_peers() const {
  return query_case() == kGetPeers;
}
inline bool Query_Payload::has_get_peers() const {
  return _internal_has_get_peers();
}
inline void Query_Payload::set_has_get_peers() {
  _impl_._oneof_case_[0] = kGetPeers;
}
inline void Query_Payload::clear_get_peers() {
  if (_internal_has_get_peers()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.query_.get_peers_;
    }
    clear_has_query();
  }
}
inline ::iroha::protocol::GetPeers* Query_Payload::release_get_peers() {
  // @@protoc_insertion_point(field_release:iroha.protocol.Query.Payload.get_peers)
  if (_internal_has_get_peers()) {
    clear_has_query();
    ::iroha::protocol::GetPeers* temp = _impl_.query_.get_peers_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.query_.get_peers_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::iroha::protocol::GetPeers& Query_Payload::_internal_get_peers() const {
  return _internal_has_get_peers()
      ? *_impl_.query_.get_peers_
      : reinterpret_cast< ::iroha::protocol::GetPeers&>(::iroha::protocol::_GetPeers_default_instance_);
}
inline const ::iroha::protocol::GetPeers& Query_Payload::get_peers() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.Query.Payload.get_peers)
  return _internal_get_peers();
}
inline ::iroha::protocol::GetPeers* Query_Payload::unsafe_arena_release_get_peers() {
  // @@protoc_insertion_point(field_unsafe_arena_release:iroha.protocol.Query.Payload.get_peers)
  if (_internal_has_get_peers()) {
    clear_has_query();
    ::iroha::protocol::GetPeers* temp = _impl_.query_.get_peers_;
    _impl_.query_.get_peers_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Query_Payload::unsafe_arena_set_allocated_get_peers(::iroha::protocol::GetPeers* get_peers) {
  clear_query();
  if (get_peers) {
    set_has_get_peers();
    _impl_.query_.get_peers_ = get_peers;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:iroha.protocol.Query.Payload.get_peers)
}
inline ::iroha::protocol::GetPeers* Query_Payload::_internal_mutable_get_peers() {
  if (!_internal_has_get_peers()) {
    clear_query();
    set_has_get_peers();
    _impl_.query_.get_peers_ = CreateMaybeMessage< ::iroha::protocol::GetPeers >(GetArenaForAllocation());
  }
  return _impl_.query_.get_peers_;
}
inline ::iroha::protocol::GetPeers* Query_Payload::mutable_get_peers() {
  ::iroha::protocol::GetPeers* _msg = _internal_mutable_get_peers();
  // @@protoc_insertion_point(field_mutable:iroha.protocol.Query.Payload.get_peers)
  return _msg;
}

// .iroha.protocol.GetEngineReceipts get_engine_receipts = 16;
inline bool Query_Payload::_internal_has_get_engine_receipts() const {
  return query_case() == kGetEngineReceipts;
}
inline bool Query_Payload::has_get_engine_receipts() const {
  return _internal_has_get_engine_receipts();
}
inline void Query_Payload::set_has_get_engine_receipts() {
  _impl_._oneof_case_[0] = kGetEngineReceipts;
}
inline void Query_Payload::clear_get_engine_receipts() {
  if (_internal_has_get_engine_receipts()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.query_.get_engine_receipts_;
    }
    clear_has_query();
  }
}
inline ::iroha::protocol::GetEngineReceipts* Query_Payload::release_get_engine_receipts() {
  // @@protoc_insertion_point(field_release:iroha.protocol.Query.Payload.get_engine_receipts)
  if (_internal_has_get_engine_receipts()) {
    clear_has_query();
    ::iroha::protocol::GetEngineReceipts* temp = _impl_.query_.get_engine_receipts_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.query_.get_engine_receipts_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::iroha::protocol::GetEngineReceipts& Query_Payload::_internal_get_engine_receipts() const {
  return _internal_has_get_engine_receipts()
      ? *_impl_.query_.get_engine_receipts_
      : reinterpret_cast< ::iroha::protocol::GetEngineReceipts&>(::iroha::protocol::_GetEngineReceipts_default_instance_);
}
inline const ::iroha::protocol::GetEngineReceipts& Query_Payload::get_engine_receipts() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.Query.Payload.get_engine_receipts)
  return _internal_get_engine_receipts();
}
inline ::iroha::protocol::GetEngineReceipts* Query_Payload::unsafe_arena_release_get_engine_receipts() {
  // @@protoc_insertion_point(field_unsafe_arena_release:iroha.protocol.Query.Payload.get_engine_receipts)
  if (_internal_has_get_engine_receipts()) {
    clear_has_query();
    ::iroha::protocol::GetEngineReceipts* temp = _impl_.query_.get_engine_receipts_;
    _impl_.query_.get_engine_receipts_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Query_Payload::unsafe_arena_set_allocated_get_engine_receipts(::iroha::protocol::GetEngineReceipts* get_engine_receipts) {
  clear_query();
  if (get_engine_receipts) {
    set_has_get_engine_receipts();
    _impl_.query_.get_engine_receipts_ = get_engine_receipts;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:iroha.protocol.Query.Payload.get_engine_receipts)
}
inline ::iroha::protocol::GetEngineReceipts* Query_Payload::_internal_mutable_get_engine_receipts() {
  if (!_internal_has_get_engine_receipts()) {
    clear_query();
    set_has_get_engine_receipts();
    _impl_.query_.get_engine_receipts_ = CreateMaybeMessage< ::iroha::protocol::GetEngineReceipts >(GetArenaForAllocation());
  }
  return _impl_.query_.get_engine_receipts_;
}
inline ::iroha::protocol::GetEngineReceipts* Query_Payload::mutable_get_engine_receipts() {
  ::iroha::protocol::GetEngineReceipts* _msg = _internal_mutable_get_engine_receipts();
  // @@protoc_insertion_point(field_mutable:iroha.protocol.Query.Payload.get_engine_receipts)
  return _msg;
}

inline bool Query_Payload::has_query() const {
  return query_case() != QUERY_NOT_SET;
}
inline void Query_Payload::clear_has_query() {
  _impl_._oneof_case_[0] = QUERY_NOT_SET;
}
inline Query_Payload::QueryCase Query_Payload::query_case() const {
  return Query_Payload::QueryCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// Query

// .iroha.protocol.Query.Payload payload = 1;
inline bool Query::_internal_has_payload() const {
  return this != internal_default_instance() && _impl_.payload_ != nullptr;
}
inline bool Query::has_payload() const {
  return _internal_has_payload();
}
inline void Query::clear_payload() {
  if (GetArenaForAllocation() == nullptr && _impl_.payload_ != nullptr) {
    delete _impl_.payload_;
  }
  _impl_.payload_ = nullptr;
}
inline const ::iroha::protocol::Query_Payload& Query::_internal_payload() const {
  const ::iroha::protocol::Query_Payload* p = _impl_.payload_;
  return p != nullptr ? *p : reinterpret_cast<const ::iroha::protocol::Query_Payload&>(
      ::iroha::protocol::_Query_Payload_default_instance_);
}
inline const ::iroha::protocol::Query_Payload& Query::payload() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.Query.payload)
  return _internal_payload();
}
inline void Query::unsafe_arena_set_allocated_payload(
    ::iroha::protocol::Query_Payload* payload) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.payload_);
  }
  _impl_.payload_ = payload;
  if (payload) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:iroha.protocol.Query.payload)
}
inline ::iroha::protocol::Query_Payload* Query::release_payload() {
  
  ::iroha::protocol::Query_Payload* temp = _impl_.payload_;
  _impl_.payload_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::iroha::protocol::Query_Payload* Query::unsafe_arena_release_payload() {
  // @@protoc_insertion_point(field_release:iroha.protocol.Query.payload)
  
  ::iroha::protocol::Query_Payload* temp = _impl_.payload_;
  _impl_.payload_ = nullptr;
  return temp;
}
inline ::iroha::protocol::Query_Payload* Query::_internal_mutable_payload() {
  
  if (_impl_.payload_ == nullptr) {
    auto* p = CreateMaybeMessage<::iroha::protocol::Query_Payload>(GetArenaForAllocation());
    _impl_.payload_ = p;
  }
  return _impl_.payload_;
}
inline ::iroha::protocol::Query_Payload* Query::mutable_payload() {
  ::iroha::protocol::Query_Payload* _msg = _internal_mutable_payload();
  // @@protoc_insertion_point(field_mutable:iroha.protocol.Query.payload)
  return _msg;
}
inline void Query::set_allocated_payload(::iroha::protocol::Query_Payload* payload) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.payload_;
  }
  if (payload) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(payload);
    if (message_arena != submessage_arena) {
      payload = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, payload, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.payload_ = payload;
  // @@protoc_insertion_point(field_set_allocated:iroha.protocol.Query.payload)
}

// .iroha.protocol.Signature signature = 2;
inline bool Query::_internal_has_signature() const {
  return this != internal_default_instance() && _impl_.signature_ != nullptr;
}
inline bool Query::has_signature() const {
  return _internal_has_signature();
}
inline const ::iroha::protocol::Signature& Query::_internal_signature() const {
  const ::iroha::protocol::Signature* p = _impl_.signature_;
  return p != nullptr ? *p : reinterpret_cast<const ::iroha::protocol::Signature&>(
      ::iroha::protocol::_Signature_default_instance_);
}
inline const ::iroha::protocol::Signature& Query::signature() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.Query.signature)
  return _internal_signature();
}
inline void Query::unsafe_arena_set_allocated_signature(
    ::iroha::protocol::Signature* signature) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.signature_);
  }
  _impl_.signature_ = signature;
  if (signature) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:iroha.protocol.Query.signature)
}
inline ::iroha::protocol::Signature* Query::release_signature() {
  
  ::iroha::protocol::Signature* temp = _impl_.signature_;
  _impl_.signature_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::iroha::protocol::Signature* Query::unsafe_arena_release_signature() {
  // @@protoc_insertion_point(field_release:iroha.protocol.Query.signature)
  
  ::iroha::protocol::Signature* temp = _impl_.signature_;
  _impl_.signature_ = nullptr;
  return temp;
}
inline ::iroha::protocol::Signature* Query::_internal_mutable_signature() {
  
  if (_impl_.signature_ == nullptr) {
    auto* p = CreateMaybeMessage<::iroha::protocol::Signature>(GetArenaForAllocation());
    _impl_.signature_ = p;
  }
  return _impl_.signature_;
}
inline ::iroha::protocol::Signature* Query::mutable_signature() {
  ::iroha::protocol::Signature* _msg = _internal_mutable_signature();
  // @@protoc_insertion_point(field_mutable:iroha.protocol.Query.signature)
  return _msg;
}
inline void Query::set_allocated_signature(::iroha::protocol::Signature* signature) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.signature_);
  }
  if (signature) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(signature));
    if (message_arena != submessage_arena) {
      signature = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, signature, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.signature_ = signature;
  // @@protoc_insertion_point(field_set_allocated:iroha.protocol.Query.signature)
}

// -------------------------------------------------------------------

// BlocksQuery

// .iroha.protocol.QueryPayloadMeta meta = 1;
inline bool BlocksQuery::_internal_has_meta() const {
  return this != internal_default_instance() && _impl_.meta_ != nullptr;
}
inline bool BlocksQuery::has_meta() const {
  return _internal_has_meta();
}
inline void BlocksQuery::clear_meta() {
  if (GetArenaForAllocation() == nullptr && _impl_.meta_ != nullptr) {
    delete _impl_.meta_;
  }
  _impl_.meta_ = nullptr;
}
inline const ::iroha::protocol::QueryPayloadMeta& BlocksQuery::_internal_meta() const {
  const ::iroha::protocol::QueryPayloadMeta* p = _impl_.meta_;
  return p != nullptr ? *p : reinterpret_cast<const ::iroha::protocol::QueryPayloadMeta&>(
      ::iroha::protocol::_QueryPayloadMeta_default_instance_);
}
inline const ::iroha::protocol::QueryPayloadMeta& BlocksQuery::meta() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.BlocksQuery.meta)
  return _internal_meta();
}
inline void BlocksQuery::unsafe_arena_set_allocated_meta(
    ::iroha::protocol::QueryPayloadMeta* meta) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.meta_);
  }
  _impl_.meta_ = meta;
  if (meta) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:iroha.protocol.BlocksQuery.meta)
}
inline ::iroha::protocol::QueryPayloadMeta* BlocksQuery::release_meta() {
  
  ::iroha::protocol::QueryPayloadMeta* temp = _impl_.meta_;
  _impl_.meta_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::iroha::protocol::QueryPayloadMeta* BlocksQuery::unsafe_arena_release_meta() {
  // @@protoc_insertion_point(field_release:iroha.protocol.BlocksQuery.meta)
  
  ::iroha::protocol::QueryPayloadMeta* temp = _impl_.meta_;
  _impl_.meta_ = nullptr;
  return temp;
}
inline ::iroha::protocol::QueryPayloadMeta* BlocksQuery::_internal_mutable_meta() {
  
  if (_impl_.meta_ == nullptr) {
    auto* p = CreateMaybeMessage<::iroha::protocol::QueryPayloadMeta>(GetArenaForAllocation());
    _impl_.meta_ = p;
  }
  return _impl_.meta_;
}
inline ::iroha::protocol::QueryPayloadMeta* BlocksQuery::mutable_meta() {
  ::iroha::protocol::QueryPayloadMeta* _msg = _internal_mutable_meta();
  // @@protoc_insertion_point(field_mutable:iroha.protocol.BlocksQuery.meta)
  return _msg;
}
inline void BlocksQuery::set_allocated_meta(::iroha::protocol::QueryPayloadMeta* meta) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.meta_;
  }
  if (meta) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(meta);
    if (message_arena != submessage_arena) {
      meta = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, meta, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.meta_ = meta;
  // @@protoc_insertion_point(field_set_allocated:iroha.protocol.BlocksQuery.meta)
}

// .iroha.protocol.Signature signature = 2;
inline bool BlocksQuery::_internal_has_signature() const {
  return this != internal_default_instance() && _impl_.signature_ != nullptr;
}
inline bool BlocksQuery::has_signature() const {
  return _internal_has_signature();
}
inline const ::iroha::protocol::Signature& BlocksQuery::_internal_signature() const {
  const ::iroha::protocol::Signature* p = _impl_.signature_;
  return p != nullptr ? *p : reinterpret_cast<const ::iroha::protocol::Signature&>(
      ::iroha::protocol::_Signature_default_instance_);
}
inline const ::iroha::protocol::Signature& BlocksQuery::signature() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.BlocksQuery.signature)
  return _internal_signature();
}
inline void BlocksQuery::unsafe_arena_set_allocated_signature(
    ::iroha::protocol::Signature* signature) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.signature_);
  }
  _impl_.signature_ = signature;
  if (signature) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:iroha.protocol.BlocksQuery.signature)
}
inline ::iroha::protocol::Signature* BlocksQuery::release_signature() {
  
  ::iroha::protocol::Signature* temp = _impl_.signature_;
  _impl_.signature_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::iroha::protocol::Signature* BlocksQuery::unsafe_arena_release_signature() {
  // @@protoc_insertion_point(field_release:iroha.protocol.BlocksQuery.signature)
  
  ::iroha::protocol::Signature* temp = _impl_.signature_;
  _impl_.signature_ = nullptr;
  return temp;
}
inline ::iroha::protocol::Signature* BlocksQuery::_internal_mutable_signature() {
  
  if (_impl_.signature_ == nullptr) {
    auto* p = CreateMaybeMessage<::iroha::protocol::Signature>(GetArenaForAllocation());
    _impl_.signature_ = p;
  }
  return _impl_.signature_;
}
inline ::iroha::protocol::Signature* BlocksQuery::mutable_signature() {
  ::iroha::protocol::Signature* _msg = _internal_mutable_signature();
  // @@protoc_insertion_point(field_mutable:iroha.protocol.BlocksQuery.signature)
  return _msg;
}
inline void BlocksQuery::set_allocated_signature(::iroha::protocol::Signature* signature) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.signature_);
  }
  if (signature) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(signature));
    if (message_arena != submessage_arena) {
      signature = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, signature, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.signature_ = signature;
  // @@protoc_insertion_point(field_set_allocated:iroha.protocol.BlocksQuery.signature)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace protocol
}  // namespace iroha

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::iroha::protocol::Field> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::iroha::protocol::Field>() {
  return ::iroha::protocol::Field_descriptor();
}
template <> struct is_proto_enum< ::iroha::protocol::Direction> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::iroha::protocol::Direction>() {
  return ::iroha::protocol::Direction_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_queries_2eproto
